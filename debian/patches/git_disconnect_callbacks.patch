From 84ec5f5a11908e636ff3b992aecfc5c8f8faddb5 Mon Sep 17 00:00:00 2001
From: Bastien Nocera <hadess@hadess.net>
Date: Wed, 20 Nov 2013 16:10:46 +0000
Subject: lib: Fix cancellation handling

We weren't checking for cancellation properly, not passing
cancellables to sub-routines, and not reporting cancelled calls
correctly.
---
diff --git a/lib/bluetooth-client.c b/lib/bluetooth-client.c
index 1fe7e6d..e224033 100644
--- a/lib/bluetooth-client.c
+++ b/lib/bluetooth-client.c
@@ -1661,23 +1661,20 @@ connect_callback (GDBusProxy   *proxy,
 		  ConnectData  *conndata)
 {
 	GVariant *variant;
-	gboolean retval;
 	GError *error = NULL;
 
 	variant = g_dbus_proxy_call_finish (proxy, res, &error);
 	if (variant == NULL) {
-		retval = FALSE;
 		g_debug ("Connect failed for %s: %s",
 			 g_dbus_proxy_get_object_path (proxy), error->message);
-		g_error_free (error);
+		g_simple_async_result_take_error (conndata->simple, error);
 	} else {
 		g_debug ("Connect succeeded for %s",
 			 g_dbus_proxy_get_object_path (proxy));
 		g_variant_unref (variant);
-		retval = TRUE;
+		g_simple_async_result_set_op_res_gboolean (conndata->simple, TRUE);
 	}
 
-	g_simple_async_result_set_op_res_gboolean (conndata->simple, retval);
 	g_simple_async_result_complete_in_idle (conndata->simple);
 
 	g_object_unref (conndata->simple);
@@ -1699,10 +1696,11 @@ disconnect_callback (GDBusProxy   *proxy,
 			g_debug ("Disconnect failed for %s: %s",
 				 g_dbus_proxy_get_object_path (G_DBUS_PROXY (conndata->device)),
 				 error->message);
-			g_error_free (error);
+			g_simple_async_result_take_error (conndata->simple, error);
 		} else {
 			g_debug ("Disconnect succeeded for %s",
 				 g_dbus_proxy_get_object_path (G_DBUS_PROXY (conndata->device)));
+			g_simple_async_result_set_op_res_gboolean (conndata->simple, retval);
 		}
 	} else {
 		GDBusProxy *service;
@@ -1716,6 +1714,10 @@ disconnect_callback (GDBusProxy   *proxy,
 				 g_dbus_proxy_get_object_path (proxy),
 				 g_dbus_proxy_get_interface_name (proxy),
 				 error->message);
+			if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
+				g_simple_async_result_take_error (conndata->simple, error);
+				goto bail;
+			}
 			g_error_free (error);
 		} else {
 			g_debug ("Disconnect succeeded for %s on %s",
@@ -1737,14 +1739,14 @@ disconnect_callback (GDBusProxy   *proxy,
 				   g_variant_new ("()"),
 				   G_DBUS_CALL_FLAGS_NONE,
 				   -1,
-				   NULL,
+				   g_object_get_data (G_OBJECT (conndata->simple), "cancellable"),
 				   (GAsyncReadyCallback) disconnect_callback,
 				   conndata);
 
 		return;
 	}
 
-	g_simple_async_result_set_op_res_gboolean (conndata->simple, retval);
+bail:
 	g_simple_async_result_complete_in_idle (conndata->simple);
 
 	g_object_unref (proxy);
@@ -1836,6 +1838,7 @@ bluetooth_client_connect_service (BluetoothClient     *client,
 		g_object_set_data_full (G_OBJECT (simple), "device",
 					g_strdup (device), g_free);
 	}
+	g_simple_async_result_set_check_cancellable (simple, cancellable);
 
 	gtk_tree_model_get (GTK_TREE_MODEL (priv->store), &iter,
 			    BLUETOOTH_COLUMN_PROXY, &proxy,
@@ -1891,7 +1894,7 @@ bluetooth_client_connect_service (BluetoothClient     *client,
 				   NULL,
 				   G_DBUS_CALL_FLAGS_NONE,
 				   -1,
-				   NULL,
+				   cancellable,
 				   (GAsyncReadyCallback) connect_callback,
 				   conndata);
 	} else if (table != NULL) {
@@ -1914,14 +1917,14 @@ bluetooth_client_connect_service (BluetoothClient     *client,
 				   NULL,
 				   G_DBUS_CALL_FLAGS_NONE,
 				   -1,
-				   NULL,
+				   cancellable,
 				   (GAsyncReadyCallback) disconnect_callback,
 				   conndata);
 	} else if (table == NULL) {
 		g_debug ("Calling device_call_disconnect() for %s",
 			 g_dbus_proxy_get_object_path (proxy));
 		device_call_disconnect (DEVICE (proxy),
-					NULL,
+					cancellable,
 					(GAsyncReadyCallback) disconnect_callback,
 					conndata);
 		g_object_unref (proxy);
@@ -1956,7 +1959,10 @@ bluetooth_client_connect_service_finish (BluetoothClient *client,
 
 	g_warn_if_fail (g_simple_async_result_get_source_tag (simple) == bluetooth_client_connect_service);
 
-	return g_simple_async_result_get_op_res_gboolean (simple);
+	if (g_simple_async_result_get_op_res_gboolean (simple))
+		return TRUE;
+	g_simple_async_result_propagate_error (simple, error);
+	return FALSE;
 }
 
 #define BOOL_STR(x) (x ? "True" : "False")
--
cgit v0.9.2
