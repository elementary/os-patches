From: Mate Kukri <mate.kukri@canonical.com>
Date: Tue, 13 Feb 2024 16:23:06 +0000
Subject: Revert "loader/powerpc/ieee1275: Use new allocation function for
 kernel and initrd"

This reverts commit 0ac3d938a318231b0302df3e955efe0bf5053717.
---
 grub-core/loader/powerpc/ieee1275/linux.c | 55 +++++--------------------------
 1 file changed, 9 insertions(+), 46 deletions(-)

diff --git a/grub-core/loader/powerpc/ieee1275/linux.c b/grub-core/loader/powerpc/ieee1275/linux.c
index 4864e5f..e6d0715 100644
--- a/grub-core/loader/powerpc/ieee1275/linux.c
+++ b/grub-core/loader/powerpc/ieee1275/linux.c
@@ -30,7 +30,6 @@
 #include <grub/lib/cmdline.h>
 #include <grub/cache.h>
 #include <grub/linux.h>
-#include <grub/ieee1275/alloc.h>
 
 GRUB_MOD_LICENSE ("GPLv3+");
 
@@ -117,22 +116,6 @@ grub_linux_claimmap_iterate (grub_addr_t target, grub_size_t size,
   return ctx.found_addr;
 }
 
-static grub_addr_t
-grub_linux_claimmap_iterate_restricted (grub_size_t size, grub_size_t align)
-{
-  struct regions_claim_request rcr = {
-    .flags = GRUB_MM_ADD_REGION_CONSECUTIVE,
-    .total = size,
-    .init_region = false,
-    .addr = (grub_uint64_t) -1,
-    .align = align,
-  };
-
-  grub_machine_mmap_iterate (grub_regions_claim, &rcr);
-
-  return rcr.addr;
-}
-
 static grub_err_t
 grub_linux_boot (void)
 {
@@ -244,18 +227,10 @@ grub_linux_load64 (grub_elf_t elf, const char *filename)
   offset = entry - base_addr;
   /* Linux's incorrectly contains a virtual address.  */
 
-  if (grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_POWER_VM) ||
-      grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_POWER_KVM))
-    {
-      seg_addr = grub_linux_claimmap_iterate_restricted (linux_size, align);
-    }
-  else
-    {
-      /* On some systems, firmware occupies the memory we're trying to use.
-       * Happily, Linux can be loaded anywhere (it relocates itself).  Iterate
-       * until we find an open area.  */
-      seg_addr = grub_linux_claimmap_iterate (base_addr & ~ELF64_LOADMASK, linux_size, align);
-    }
+  /* On some systems, firmware occupies the memory we're trying to use.
+   * Happily, Linux can be loaded anywhere (it relocates itself).  Iterate
+   * until we find an open area.  */
+  seg_addr = grub_linux_claimmap_iterate (base_addr & ~ELF64_LOADMASK, linux_size, align);
   if (seg_addr == (grub_addr_t) -1)
     return grub_error (GRUB_ERR_OUT_OF_MEMORY, "couldn't claim memory");
 
@@ -364,25 +339,13 @@ grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
 
   size = grub_get_initrd_size (&initrd_ctx);
 
+  first_addr = linux_addr + linux_size;
 
-  if (grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_POWER_VM) ||
-      grub_ieee1275_test_flag (GRUB_IEEE1275_FLAG_POWER_KVM))
-    {
-      addr = grub_linux_claimmap_iterate_restricted (size, 0x100000);
-    }
-  else
-    {
-      /* Attempt to claim at a series of addresses until successful in
-         the same way that grub_rescue_cmd_linux does.  */
-      first_addr = linux_addr + linux_size;
-      addr = grub_linux_claimmap_iterate (first_addr, size, 0x100000);
-    }
-
+  /* Attempt to claim at a series of addresses until successful in
+     the same way that grub_rescue_cmd_linux does.  */
+  addr = grub_linux_claimmap_iterate (first_addr, size, 0x100000);
   if (addr == (grub_addr_t) -1)
-    {
-      grub_error (GRUB_ERR_OUT_OF_MEMORY, "out of memory");
-      goto fail;
-    }
+     goto fail;
 
   grub_dprintf ("loader", "Loading initrd at 0x%x, size 0x%x\n", addr, size);
 
