Description: Qt 4.8/a11y branch patch (upstream)
Author: Frederik Gladhorn <frederik.gladhorn@nokia.com>
Last-Update: 2012-01-09
Forwarded: not-needed

---
 examples/declarative/ui-components/slideswitch/qml/slideswitch/content/Switch.qml |    1 
 src/declarative/accessible/accessible.pri                                         |    2 
 src/declarative/accessible/qdeclarativeaccessible.cpp                             |   80 +
 src/declarative/accessible/qdeclarativeaccessible_p.h                             |  314 ++++++
 src/declarative/declarative.pro                                                   |    1 
 src/declarative/graphicsitems/qdeclarativeflickable.cpp                           |    9 
 src/declarative/graphicsitems/qdeclarativeitem.cpp                                |   57 +
 src/declarative/graphicsitems/qdeclarativeitem.h                                  |    4 
 src/declarative/graphicsitems/qdeclarativeitem_p.h                                |    6 
 src/declarative/graphicsitems/qdeclarativeitemsmodule.cpp                         |    5 
 src/declarative/graphicsitems/qdeclarativetext.cpp                                |    2 
 src/declarative/qml/qdeclarativeengine_p.h                                        |    4 
 src/declarative/util/qdeclarativeaccessibility.cpp                                |  232 +++++
 src/declarative/util/qdeclarativeaccessibility_p.h                                |  110 ++
 src/declarative/util/qdeclarativeanimation.cpp                                    |    9 
 src/declarative/util/qdeclarativeanimation_p_p.h                                  |    6 
 src/declarative/util/qdeclarativebehavior.cpp                                     |   12 
 src/declarative/util/qdeclarativetransitionmanager.cpp                            |   23 
 src/declarative/util/qdeclarativeview.cpp                                         |    6 
 src/declarative/util/qdeclarativeview.h                                           |    4 
 src/declarative/util/util.pri                                                     |    2 
 src/gui/accessible/accessible.pri                                                 |    1 
 src/gui/accessible/qaccessible.cpp                                                |   39 
 src/gui/accessible/qaccessible.h                                                  |    2 
 src/gui/accessible/qaccessible2.cpp                                               |  105 ++
 src/gui/accessible/qaccessible2.h                                                 |    8 
 src/gui/accessible/qaccessible_mac.mm                                             |    7 
 src/gui/accessible/qaccessible_mac_cocoa.mm                                       |   69 -
 src/gui/accessible/qaccessible_mac_p.h                                            |   12 
 src/gui/accessible/qaccessible_win.cpp                                            |   99 +-
 src/gui/accessible/qaccessibleuielement_mac.mm                                    |  182 +++
 src/gui/accessible/qaccessibleuielement_mac_p.h                                   |   27 
 src/plugins/accessible/widgets/main.cpp                                           |   26 
 src/plugins/accessible/widgets/qaccessibledeclarativeimplementation.cpp           |   11 
 src/plugins/accessible/widgets/qaccessibledeclarativeimplementation.h             |   37 
 src/plugins/accessible/widgets/qaccessibledeclarativeobject.cpp                   |  401 ++++++++
 src/plugins/accessible/widgets/qaccessibledeclarativeobject.h                     |  172 +++
 src/plugins/accessible/widgets/qaccessibledeclarativeview.cpp                     |  104 ++
 src/plugins/accessible/widgets/qaccessibledeclarativeview.h                       |   73 +
 src/plugins/accessible/widgets/qaccessiblegraphicsviewimplementation.cpp          |  168 +++
 src/plugins/accessible/widgets/qaccessiblegraphicsviewimplementation.h            |   30 
 src/plugins/accessible/widgets/widgets.pro                                        |   17 
 tools/accessibilityinspector/accessibilityinspector.cpp                           |  149 +++
 tools/accessibilityinspector/accessibilityinspector.h                             |   48 +
 tools/accessibilityinspector/accessibilityinspector.pri                           |   23 
 tools/accessibilityinspector/accessibilityinspector.pro                           |   11 
 tools/accessibilityinspector/accessibilityscenemanager.cpp                        |  459 ++++++++++
 tools/accessibilityinspector/accessibilityscenemanager.h                          |   76 +
 tools/accessibilityinspector/main.cpp                                             |   78 +
 tools/accessibilityinspector/optionswidget.cpp                                    |    2 
 tools/accessibilityinspector/optionswidget.h                                      |   75 +
 tools/accessibilityinspector/phase1.qml                                           |   52 +
 tools/accessibilityinspector/screenreader.cpp                                     |  121 ++
 tools/accessibilityinspector/screenreader.h                                       |   42 
 tools/accessibilityinspector/screenreader_mac.mm                                  |   19 
 tools/accessibilityinspector/testqml.qrc                                          |    5 
 56 files changed, 3540 insertions(+), 99 deletions(-)

--- a/examples/declarative/ui-components/slideswitch/qml/slideswitch/content/Switch.qml
+++ b/examples/declarative/ui-components/slideswitch/qml/slideswitch/content/Switch.qml
@@ -44,6 +44,7 @@
 Item {
     id: toggleswitch
     width: background.width; height: background.height
+    property string accessibleRole : "CheckBox"
 
 //![1]
     property bool on: false
--- /dev/null
+++ b/src/declarative/accessible/accessible.pri
@@ -0,0 +1,2 @@
+SOURCES += $$PWD/qdeclarativeaccessible.cpp
+HEADERS += $$PWD/qdeclarativeaccessible_p.h
--- /dev/null
+++ b/src/declarative/accessible/qdeclarativeaccessible.cpp
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtDeclarative module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qdeclarativeaccessible_p.h"
+
+#include <qdeclarativeexpression.h>
+#include <qdeclarativecontext.h>
+#include <qdeclarativeinfo.h>
+
+#include <private/qdeclarativeproperty_p.h>
+#include <private/qdeclarativeitem_p.h>
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qstringlist.h>
+
+#include <QtGui/qevent.h>
+
+#include <private/qobject_p.h>
+
+#ifndef QT_NO_ACCESSIBILITY
+
+QT_BEGIN_NAMESPACE
+
+
+QDeclarativeAccessibleAttached::QDeclarativeAccessibleAttached(QObject *parent=0)
+    : QObject(parent)
+{
+    Q_ASSERT(parent);
+}
+
+QDeclarativeAccessibleAttached::~QDeclarativeAccessibleAttached()
+{
+}
+
+QDeclarativeAccessibleAttached *QDeclarativeAccessibleAttached::qmlAttachedProperties(QObject *obj)
+{
+    return new QDeclarativeAccessibleAttached(obj);
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_GESTURES
--- /dev/null
+++ b/src/declarative/accessible/qdeclarativeaccessible_p.h
@@ -0,0 +1,314 @@
+/****************************************************************************
+**
+** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtDeclarative module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QDECLARATIVEACCESSIBLE_H
+#define QDECLARATIVEACCESSIBLE_H
+
+#include <qdeclarativeitem.h>
+
+#include <QtCore/qobject.h>
+#include <QtCore/qstring.h>
+
+#ifndef QT_NO_ACCESSIBILITY
+
+#include <private/qdeclarativeglobal_p.h>
+#include <qaccessible.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Declarative)
+
+class Q_DECLARATIVE_PRIVATE_EXPORT QDeclarativeAccessibleAttached : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(Role role READ role WRITE setRole NOTIFY roleChanged)
+    Q_PROPERTY(QString name READ name WRITE setName NOTIFY nameChanged)
+    Q_PROPERTY(QString description READ description WRITE setDescription NOTIFY descriptionChanged)
+
+public:
+    Q_ENUMS(Role Event Action)
+
+    /* Stupid copy of enums from QAccessible */
+    enum Role {
+        NoRole         = 0x00000000,
+        TitleBar       = 0x00000001,
+        MenuBar        = 0x00000002,
+        ScrollBar      = 0x00000003,
+        Grip           = 0x00000004,
+        Sound          = 0x00000005,
+        Cursor         = 0x00000006,
+        Caret          = 0x00000007,
+        AlertMessage   = 0x00000008,
+        Window         = 0x00000009,
+        Client         = 0x0000000A,
+        PopupMenu      = 0x0000000B,
+        MenuItem       = 0x0000000C,
+        ToolTip        = 0x0000000D,
+        Application    = 0x0000000E,
+        Document       = 0x0000000F,
+        Pane           = 0x00000010,
+        Chart          = 0x00000011,
+        Dialog         = 0x00000012,
+        Border         = 0x00000013,
+        Grouping       = 0x00000014,
+        Separator      = 0x00000015,
+        ToolBar        = 0x00000016,
+        StatusBar      = 0x00000017,
+        Table          = 0x00000018,
+        ColumnHeader   = 0x00000019,
+        RowHeader      = 0x0000001A,
+        Column         = 0x0000001B,
+        Row            = 0x0000001C,
+        Cell           = 0x0000001D,
+        Link           = 0x0000001E,
+        HelpBalloon    = 0x0000001F,
+        Assistant      = 0x00000020,
+        List           = 0x00000021,
+        ListItem       = 0x00000022,
+        Tree           = 0x00000023,
+        TreeItem       = 0x00000024,
+        PageTab        = 0x00000025,
+        PropertyPage   = 0x00000026,
+        Indicator      = 0x00000027,
+        Graphic        = 0x00000028,
+        StaticText     = 0x00000029,
+        EditableText   = 0x0000002A,  // Editable, selectable, etc.
+        PushButton     = 0x0000002B,
+        Button         = PushButton,
+        CheckBox       = 0x0000002C,
+        RadioButton    = 0x0000002D,
+        ComboBox       = 0x0000002E,
+        // DropList       = 0x0000002F,
+        ProgressBar    = 0x00000030,
+        Dial           = 0x00000031,
+        HotkeyField    = 0x00000032,
+        Slider         = 0x00000033,
+        SpinBox        = 0x00000034,
+        Canvas         = 0x00000035,
+        Animation      = 0x00000036,
+        Equation       = 0x00000037,
+        ButtonDropDown = 0x00000038,
+        ButtonMenu     = 0x00000039,
+        ButtonDropGrid = 0x0000003A,
+        Whitespace     = 0x0000003B,
+        PageTabList    = 0x0000003C,
+        Clock          = 0x0000003D,
+        Splitter       = 0x0000003E,
+        // Additional Qt roles where enum value does not map directly to MSAA:
+        LayeredPane    = 0x0000003F,
+        UserRole       = 0x0000ffff
+    };
+
+    enum Event {
+        SoundPlayed          = 0x0001,
+        Alert                = 0x0002,
+        ForegroundChanged    = 0x0003,
+        MenuStart            = 0x0004,
+        MenuEnd              = 0x0005,
+        PopupMenuStart       = 0x0006,
+        PopupMenuEnd         = 0x0007,
+        ContextHelpStart     = 0x000C,
+        ContextHelpEnd       = 0x000D,
+        DragDropStart        = 0x000E,
+        DragDropEnd          = 0x000F,
+        DialogStart          = 0x0010,
+        DialogEnd            = 0x0011,
+        ScrollingStart       = 0x0012,
+        ScrollingEnd         = 0x0013,
+
+        MenuCommand          = 0x0018,
+
+        // Values from IAccessible2
+        ActionChanged        = 0x0101,
+        ActiveDescendantChanged,
+        AttributeChanged,
+        DocumentContentChanged,
+        DocumentLoadComplete,
+        DocumentLoadStopped,
+        DocumentReload,
+        HyperlinkEndIndexChanged,
+        HyperlinkNumberOfAnchorsChanged,
+        HyperlinkSelectedLinkChanged,
+        HypertextLinkActivated,
+        HypertextLinkSelected,
+        HyperlinkStartIndexChanged,
+        HypertextChanged,
+        HypertextNLinksChanged,
+        ObjectAttributeChanged,
+        PageChanged,
+        SectionChanged,
+        TableCaptionChanged,
+        TableColumnDescriptionChanged,
+        TableColumnHeaderChanged,
+        TableModelChanged,
+        TableRowDescriptionChanged,
+        TableRowHeaderChanged,
+        TableSummaryChanged,
+        TextAttributeChanged,
+        TextCaretMoved,
+        // TextChanged, deprecated, use TextUpdated
+        TextColumnChanged = TextCaretMoved + 2,
+        TextInserted,
+        TextRemoved,
+        TextUpdated,
+        TextSelectionChanged,
+        VisibleDataChanged,
+
+        ObjectCreated        = 0x8000,
+        ObjectDestroyed      = 0x8001,
+        ObjectShow           = 0x8002,
+        ObjectHide           = 0x8003,
+        ObjectReorder        = 0x8004,
+        Focus                = 0x8005,
+        Selection            = 0x8006,
+        SelectionAdd         = 0x8007,
+        SelectionRemove      = 0x8008,
+        SelectionWithin      = 0x8009,
+        StateChanged         = 0x800A,
+        LocationChanged      = 0x800B,
+        NameChanged          = 0x800C,
+        DescriptionChanged   = 0x800D,
+        ValueChanged         = 0x800E,
+        ParentChanged        = 0x800F,
+        HelpChanged          = 0x80A0,
+        DefaultActionChanged = 0x80B0,
+        AcceleratorChanged   = 0x80C0
+    };
+
+    enum Action {
+        DefaultAction       = 0,
+        Press               = -1,
+        FirstStandardAction = Press,
+        SetFocus            = -2,
+        Increase            = -3,
+        Decrease            = -4,
+        Accept              = -5,
+        Cancel              = -6,
+        Select              = -7,
+        ClearSelection      = -8,
+        RemoveSelection     = -9,
+        ExtendSelection     = -10,
+        AddToSelection      = -11,
+        LastStandardAction  = AddToSelection
+    };
+
+    QDeclarativeAccessibleAttached(QObject *parent);
+    ~QDeclarativeAccessibleAttached();
+
+    Role role() const { return (Role)m_role; }
+    void setRole(Role role)
+    {
+        m_role = (char)role;
+        emit roleChanged();
+        // There is no way to signify role changes at the moment.
+        // QAccessible::updateAccessibility(parent(), 0, QAccessible::);
+    }
+
+    QString name() const { return m_name; }
+    void setName(const QString &name)
+    {
+        m_name = name;
+        emit nameChanged();
+        QAccessible::updateAccessibility(parent(), 0, QAccessible::NameChanged);
+    }
+
+    QString description() const { return m_description; }
+    void setDescription(const QString &description)
+    {
+        m_description = description;
+        emit descriptionChanged();
+        QAccessible::updateAccessibility(parent(), 0, QAccessible::DescriptionChanged);
+    }
+
+    QDeclarativeItem *item() const {
+        return static_cast<QDeclarativeItem*>(parent());
+    }
+
+    // Factory function
+    static QDeclarativeAccessibleAttached *qmlAttachedProperties(QObject *);
+
+    // Property getter
+    static QObject *attachedProperties(const QObject *obj)
+    {
+        return qmlAttachedPropertiesObject<QDeclarativeAccessibleAttached>(obj, false);
+    }
+
+    static QVariant property(const QObject *object, const char *propertyName)
+    {
+        if (QObject *attachedObject = QDeclarativeAccessibleAttached::attachedProperties(object))
+            return attachedObject->property(propertyName);
+        return QVariant();
+    }
+
+    static bool setProperty(QObject *object, const char *propertyName, const QVariant &value)
+    {
+        QObject *obj = qmlAttachedPropertiesObject<QDeclarativeAccessibleAttached>(object, true);
+        if (!obj) {
+            qWarning("cannot set property Accessible.%s of QObject %s", propertyName, object->metaObject()->className());
+            return false;
+        }
+        return obj->setProperty(propertyName, value);
+    }
+
+
+Q_SIGNALS:
+    void roleChanged();
+    void nameChanged();
+    void descriptionChanged();
+private:
+    char m_role;
+    QString m_name;
+    QString m_description;
+};
+
+
+QT_END_NAMESPACE
+
+QML_DECLARE_TYPE(QDeclarativeAccessibleAttached)
+QML_DECLARE_TYPEINFO(QDeclarativeAccessibleAttached, QML_HAS_ATTACHED_PROPERTIES)
+
+QT_END_HEADER
+
+#endif // QT_NO_ACCESSIBILITY
+
+#endif
--- a/src/declarative/declarative.pro
+++ b/src/declarative/declarative.pro
@@ -23,6 +23,7 @@
 include(graphicsitems/graphicsitems.pri)
 include(qml/qml.pri)
 include(debugger/debugger.pri)
+include(accessible/accessible.pri)
 
 symbian: {
     TARGET.UID3=0x2001E623
--- a/src/declarative/graphicsitems/qdeclarativeflickable.cpp
+++ b/src/declarative/graphicsitems/qdeclarativeflickable.cpp
@@ -41,6 +41,9 @@
 
 #include "private/qdeclarativeflickable_p.h"
 #include "private/qdeclarativeflickable_p_p.h"
+#include "private/qdeclarativeengine_p.h"
+#include "private/qdeclarativeaccessible_p.h"
+
 #include <qdeclarativeinfo.h>
 #include <QGraphicsSceneMouseEvent>
 #include <QPointer>
@@ -1718,6 +1721,7 @@
 void QDeclarativeFlickable::movementStarting()
 {
     Q_D(QDeclarativeFlickable);
+
     if (d->hMoved && !d->hData.moving) {
         d->hData.moving = true;
         emit movingChanged();
@@ -1737,6 +1741,7 @@
 void QDeclarativeFlickable::movementEnding()
 {
     Q_D(QDeclarativeFlickable);
+
     movementXEnding();
     movementYEnding();
     d->hData.smoothVelocity.setValue(0);
--- a/src/declarative/graphicsitems/qdeclarativeitem.cpp
+++ b/src/declarative/graphicsitems/qdeclarativeitem.cpp
@@ -53,6 +53,8 @@
 #include <qdeclarativestategroup_p.h>
 #include <qdeclarativecomponent.h>
 #include <qdeclarativeinfo.h>
+// ### Due to the workaround mentioned in accessibleRole()
+#include <qdeclarativetext_p.h>
 
 #include <QDebug>
 #include <QPen>
@@ -62,6 +64,8 @@
 #include <QtScript/qscriptengine.h>
 #include <QtGui/qgraphicstransform.h>
 #include <qlistmodelinterface_p.h>
+#include <QAccessible>
+#include <private/qdeclarativeaccessible_p.h>
 
 #include <float.h>
 
@@ -1718,7 +1722,11 @@
 */
 void QDeclarativeItem::setParentItem(QDeclarativeItem *parent)
 {
+    Q_D(QDeclarativeItem);
     QGraphicsObject::setParentItem(parent);
+    if (d->isAccessible && parentItem()) {
+        parentItem()->d_func()->setAccessibleFlagAndListener();
+    }
 }
 
 /*!
@@ -2964,6 +2972,13 @@
         d->keyHandler->componentComplete();
     if (d->_contents)
         d->_contents->complete();
+
+    // Enable accessibility for items with accessible content. This also
+    // enables accessibility for the ancestors of souch items.
+    if (accessibleRole() != QAccessible::Pane) {
+        QAccessible::updateAccessibility(this, 0, QAccessible::ObjectCreated);
+        d->setAccessibleFlagAndListener();
+    }
 }
 
 QDeclarativeStateGroup *QDeclarativeItemPrivate::_states()
@@ -2998,6 +3013,25 @@
     baseline.anchorLine = QDeclarativeAnchorLine::Baseline;
 }
 
+void QDeclarativeItemPrivate::setAccessibleFlagAndListener()
+{
+    Q_Q(QDeclarativeItem);
+    QDeclarativeItem *item = q;
+    while (item) {
+        if (item->d_func()->isAccessible)
+            break; // already set - grandparents should have the flag set as well.
+
+        if (qmlEngine(item) != 0) {
+            item->d_func()->addItemChangeListener(QDeclarativeEnginePrivate::getAccessibilityUpdater(qmlEngine(item)),
+                QDeclarativeItemPrivate::Geometry | QDeclarativeItemPrivate::Visibility |
+                QDeclarativeItemPrivate::Opacity | QDeclarativeItemPrivate::Destroyed);
+        }
+
+        item->d_func()->isAccessible = true;
+        item = item->parentItem();
+    }
+}
+
 QPointF QDeclarativeItemPrivate::computeTransformOrigin() const
 {
     Q_Q(const QDeclarativeItem);
@@ -3204,6 +3238,29 @@
     update();
 }
 
+QAccessible::Role QDeclarativeItem::accessibleRole() const
+{
+    // ### Workaround for setAccessibleRole() not working.
+    // Text items are special since they are defined
+    // entirely from C++ (setting the role from QML works.)
+    // See http://bugreports.qt.nokia.com/browse/QTBUG-20077
+    if (qobject_cast<QDeclarativeText*>(const_cast<QDeclarativeItem *>(this)))
+        return QAccessible::StaticText;
+
+    QVariant v = QDeclarativeAccessibleAttached::property(this, "role");
+    bool ok;
+    QAccessible::Role role = (QAccessible::Role)v.toInt(&ok);
+    if (!ok)    // Not sure if this check is needed.
+        role = QAccessible::Pane;
+    return role;
+}
+
+void QDeclarativeItem::setAccessibleRole(QAccessible::Role role)
+{
+    QDeclarativeAccessibleAttached::setProperty(this, "role", QVariant(int(role)));
+}
+
+
 /*!
   \property QDeclarativeItem::anchors
   \internal
--- a/src/declarative/graphicsitems/qdeclarativeitem.h
+++ b/src/declarative/graphicsitems/qdeclarativeitem.h
@@ -51,6 +51,7 @@
 #include <QtGui/qgraphicstransform.h>
 #include <QtGui/qfont.h>
 #include <QtGui/qaction.h>
+#include <QtGui/qaccessible.h>
 
 QT_BEGIN_HEADER
 
@@ -139,6 +140,9 @@
     bool smooth() const;
     void setSmooth(bool);
 
+    QAccessible::Role accessibleRole() const;
+    void setAccessibleRole(QAccessible::Role);
+
     QRectF boundingRect() const;
     virtual void paint(QPainter *, const QStyleOptionGraphicsItem *, QWidget *);
 
--- a/src/declarative/graphicsitems/qdeclarativeitem_p.h
+++ b/src/declarative/graphicsitems/qdeclarativeitem_p.h
@@ -70,6 +70,7 @@
 
 #include <QtCore/qlist.h>
 #include <QtCore/qdebug.h>
+#include <QtGui/qaccessible.h>
 
 #include <private/qgraphicsitem_p.h>
 
@@ -128,7 +129,8 @@
       componentComplete(true), keepMouse(false),
       smooth(false), transformOriginDirty(true), doneEventPreHandler(false),
       inheritedLayoutMirror(false), effectiveLayoutMirror(false), isMirrorImplicit(true),
-      inheritMirrorFromParent(false), inheritMirrorFromItem(false), hadFocus(false), hadActiveFocus(false), keyHandler(0),
+      inheritMirrorFromParent(false), inheritMirrorFromItem(false),
+      isAccessible(0), hadFocus(false), hadActiveFocus(false), keyHandler(0),
       mWidth(0), mHeight(0), mImplicitWidth(0), mImplicitHeight(0), attachedLayoutDirection(0)
     {
         QGraphicsItemPrivate::acceptedMouseButtons = 0;
@@ -289,6 +291,7 @@
     bool isMirrorImplicit:1;
     bool inheritMirrorFromParent:1;
     bool inheritMirrorFromItem:1;
+    bool isAccessible:1;
     bool hadFocus:1;
     bool hadActiveFocus:1;
 
@@ -301,6 +304,7 @@
 
     QDeclarativeLayoutMirroringAttached* attachedLayoutDirection;
 
+    void setAccessibleFlagAndListener();
 
     QPointF computeTransformOrigin() const;
 
@@ -603,6 +607,7 @@
     static const SigMap sigMap[];
 };
 
+
 Q_DECLARE_OPERATORS_FOR_FLAGS(QDeclarativeItemPrivate::ChangeTypes);
 
 QT_END_NAMESPACE
--- a/src/declarative/graphicsitems/qdeclarativeitemsmodule.cpp
+++ b/src/declarative/graphicsitems/qdeclarativeitemsmodule.cpp
@@ -45,6 +45,7 @@
 #include <QtGui/qvalidator.h>
 #include <QtGui/qgraphicseffect.h>
 
+#include "private/qdeclarativeaccessible_p.h"
 #include "private/qdeclarativeevents_p_p.h"
 #include "private/qdeclarativescalegrid_p_p.h"
 #include "private/qdeclarativeanimatedimage_p.h"
@@ -177,6 +178,10 @@
 
     qmlRegisterUncreatableType<QDeclarativeKeyNavigationAttached>("QtQuick",1,0,"KeyNavigation",QDeclarativeKeyNavigationAttached::tr("KeyNavigation is only available via attached properties"));
     qmlRegisterUncreatableType<QDeclarativeKeysAttached>("QtQuick",1,0,"Keys",QDeclarativeKeysAttached::tr("Keys is only available via attached properties"));
+#ifndef QT_NO_ACCESSIBILITY
+    qmlRegisterUncreatableType<QDeclarativeAccessibleAttached>("QtQuick",1,0,"Accessible",QDeclarativeAccessibleAttached::tr("Accessible is only available via attached properties"));
+    qmlRegisterUncreatableType<QDeclarativeAccessibleAttached>("QtQuick",1,1,"Accessible",QDeclarativeAccessibleAttached::tr("Accessible is only available via attached properties"));
+#endif
 
     // QtQuick 1.1 items
     qmlRegisterType<QDeclarativePinchArea>("QtQuick",1,1,"PinchArea");
--- a/src/declarative/graphicsitems/qdeclarativetext.cpp
+++ b/src/declarative/graphicsitems/qdeclarativetext.cpp
@@ -709,6 +709,8 @@
 QDeclarativeText::QDeclarativeText(QDeclarativeItem *parent)
   : QDeclarativeImplicitSizeItem(*(new QDeclarativeTextPrivate), parent)
 {
+    // Enable this when QTBUG-20077 is fixed.
+    //setAccessibleRole(QAccessible::StaticText);
 }
 
 QDeclarativeText::~QDeclarativeText()
--- a/src/declarative/qml/qdeclarativeengine_p.h
+++ b/src/declarative/qml/qdeclarativeengine_p.h
@@ -71,6 +71,7 @@
 #include "private/qdeclarativevaluetypescriptclass_p.h"
 #include "private/qdeclarativemetatype_p.h"
 #include "private/qdeclarativedirparser_p.h"
+#include "private/qdeclarativeaccessibility_p.h"
 
 #include <QtScript/QScriptClass>
 #include <QtScript/QScriptValue>
@@ -237,6 +238,8 @@
 
     mutable QMutex mutex;
 
+    QDeclarativeAccessibilityUpdater accessibilityUpdater;
+
     QDeclarativeTypeLoader typeLoader;
     QDeclarativeImportDatabase importDatabase;
 
@@ -311,6 +314,7 @@
     static QScriptValue formatTime(QScriptContext*, QScriptEngine*);
     static QScriptValue formatDateTime(QScriptContext*, QScriptEngine*);
 #endif
+    static QDeclarativeAccessibilityUpdater *getAccessibilityUpdater(QDeclarativeEngine *e) { return &e->d_func()->accessibilityUpdater; }
     static QScriptEngine *getScriptEngine(QDeclarativeEngine *e) { if (!e) return 0; return &e->d_func()->scriptEngine; }
     static QDeclarativeEngine *getEngine(QScriptEngine *e) { return static_cast<QDeclarativeScriptEngine*>(e)->p->q_func(); }
     static QDeclarativeEnginePrivate *get(QDeclarativeEngine *e) { return e->d_func(); }
--- /dev/null
+++ b/src/declarative/util/qdeclarativeaccessibility.cpp
@@ -0,0 +1,136 @@
+/****************************************************************************
+ **
+ ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+ ** All rights reserved.
+ ** Contact: Nokia Corporation (qt-info@nokia.com)
+ **
+ ** This file is part of the QtDeclarative module of the Qt Toolkit.
+ **
+ ** $QT_BEGIN_LICENSE:LGPL$
+ ** No Commercial Usage
+ ** This file contains pre-release code and may not be distributed.
+ ** You may use this file in accordance with the terms and conditions
+ ** contained in the Technology Preview License Agreement accompanying
+ ** this package.
+ **
+ ** GNU Lesser General Public License Usage
+ ** Alternatively, this file may be used under the terms of the GNU Lesser
+ ** General Public License version 2.1 as published by the Free Software
+ ** Foundation and appearing in the file LICENSE.LGPL included in the
+ ** packaging of this file.  Please review the following information to
+ ** ensure the GNU Lesser General Public License version 2.1 requirements
+ ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+ **
+ ** In addition, as a special exception, Nokia gives you certain additional
+ ** rights.  These rights are described in the Nokia Qt LGPL Exception
+ ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+ **
+ ** If you have questions regarding the use of this file, please contact
+ ** Nokia at qt-info@nokia.com.
+ **
+ **
+ **
+ **
+ **
+ **
+ **
+ **
+ ** $QT_END_LICENSE$
+ **
+ ****************************************************************************/
+
+#include "qdeclarativeaccessibility_p.h"
+
+#include <qaccessible.h>
+#include "qdeclarativeitem.h"
+
+QT_BEGIN_NAMESPACE
+
+QDeclarativeAccessibilityUpdater::QDeclarativeAccessibilityUpdater()
+{
+}
+
+QDeclarativeAccessibilityUpdater::~QDeclarativeAccessibilityUpdater()
+{
+
+}
+
+/*
+// QSGItemChangeListener:
+void QmlAccessibilityUpdateManager::itemGeometryChanged(QSGItem *item, const QRectF &, const QRectF &)
+{
+    locationChanged(item);
+}
+
+void QmlAccessibilityUpdateManager::itemSiblingOrderChanged(QSGItem *)
+{
+
+}
+
+void QmlAccessibilityUpdateManager::itemVisibilityChanged(QSGItem *item)
+{
+    if (!QSGItemPrivate::get(item)->isAccessible)
+        return;
+
+    QAccessible::updateAccessibility(item, 0, item->isVisible() ? QAccessible::ObjectShow : QAccessible::ObjectHide );
+}
+
+void QmlAccessibilityUpdateManager::itemOpacityChanged(QSGItem *item)
+{
+    if (!QSGItemPrivate::get(item)->isAccessible)
+        return;
+    QAccessible::updateAccessibility(item, 0, qFuzzyIsNull(item->opacity()) ?  QAccessible::ObjectShow : QAccessible::ObjectHide );
+}
+
+void QmlAccessibilityUpdateManager::itemDestroyed(QSGItem *item)
+{
+    QAccessible::updateAccessibility(item, 0, QAccessible::ObjectDestroyed);
+}
+*/
+
+void QDeclarativeAccessibilityUpdater::itemSiblingOrderChanged(QDeclarativeItem *)
+{
+
+}
+
+void QDeclarativeAccessibilityUpdater::itemVisibilityChanged(QDeclarativeItem *item)
+{
+    QAccessible::updateAccessibility(item, 0, item->isVisible() ? QAccessible::ObjectShow : QAccessible::ObjectHide );
+}
+
+void QDeclarativeAccessibilityUpdater::itemOpacityChanged(QDeclarativeItem *item)
+{
+    QAccessible::updateAccessibility(item, 0, qFuzzyIsNull(item->opacity()) ?  QAccessible::ObjectShow : QAccessible::ObjectHide );
+}
+
+void QDeclarativeAccessibilityUpdater::itemDestroyed(QDeclarativeItem *item)
+{
+    QAccessible::updateAccessibility(item, 0, QAccessible::ObjectDestroyed);
+}
+
+bool QDeclarativeAccessibilityUpdater::isAccessible(QObject *object)
+{
+/*     if (QSGItem *item = qobject_cast<QSGItem *>(object)) {
+        return QSGItemPrivate::get(item)->isAccessible;
+     } else
+*/
+    {
+        // QDeclarativeItem
+        return true;
+     }
+}
+
+QObject *QDeclarativeAccessibilityUpdater::parent(QObject *object)
+{
+/*
+    if (QSGItem *item = qobject_cast<QSGItem *>(object)) {
+        return item->parentItem();
+     } else
+*/
+     {
+        // QDeclarativeItem
+        return 0;
+     }
+}
+
+QT_END_NAMESPACE
--- /dev/null
+++ b/src/declarative/util/qdeclarativeaccessibility_p.h
@@ -0,0 +1,91 @@
+/****************************************************************************
+ **
+ ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+ ** All rights reserved.
+ ** Contact: Nokia Corporation (qt-info@nokia.com)
+ **
+ ** This file is part of the QtDeclarative module of the Qt Toolkit.
+ **
+ ** $QT_BEGIN_LICENSE:LGPL$
+ ** No Commercial Usage
+ ** This file contains pre-release code and may not be distributed.
+ ** You may use this file in accordance with the terms and conditions
+ ** contained in the Technology Preview License Agreement accompanying
+ ** this package.
+ **
+ ** GNU Lesser General Public License Usage
+ ** Alternatively, this file may be used under the terms of the GNU Lesser
+ ** General Public License version 2.1 as published by the Free Software
+ ** Foundation and appearing in the file LICENSE.LGPL included in the
+ ** packaging of this file.  Please review the following information to
+ ** ensure the GNU Lesser General Public License version 2.1 requirements
+ ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+ **
+ ** In addition, as a special exception, Nokia gives you certain additional
+ ** rights.  These rights are described in the Nokia Qt LGPL Exception
+ ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+ **
+ ** If you have questions regarding the use of this file, please contact
+ ** Nokia at qt-info@nokia.com.
+ **
+ **
+ **
+ **
+ **
+ **
+ **
+ **
+ ** $QT_END_LICENSE$
+ **
+ ****************************************************************************/
+
+#ifndef QMLACCESSIBILITYUPDATEMANAGER_P_H
+#define QMLACCESSIBILITYUPDATEMANAGER_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <qdeclarative.h>
+#include <private/qdeclarativeitemchangelistener_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QSGItem;
+
+class QDeclarativeAccessibilityUpdater : public QObject, public QDeclarativeItemChangeListener
+{
+Q_OBJECT
+public:
+    QDeclarativeAccessibilityUpdater();
+    ~QDeclarativeAccessibilityUpdater();
+/*
+    // QSGItemChangeListener:
+    void itemGeometryChanged(QSGItem *, const QRectF &, const QRectF &);
+    void itemSiblingOrderChanged(QSGItem *);
+    void itemVisibilityChanged(QSGItem *);
+    void itemOpacityChanged(QSGItem *);
+    void itemDestroyed(QSGItem *);
+*/
+    // QDeclarativeItemChangeListener
+    void itemSiblingOrderChanged(QDeclarativeItem *);
+    void itemVisibilityChanged(QDeclarativeItem *);
+    void itemOpacityChanged(QDeclarativeItem *);
+    void itemDestroyed(QDeclarativeItem *);
+
+    bool isAccessible(QObject *object);
+    QObject *parent(QObject *object);
+private:
+    Q_DISABLE_COPY(QDeclarativeAccessibilityUpdater);
+};
+
+QT_END_NAMESPACE
+
+#endif // QMLACCESSIBILITYUPDATEMANAGER_P_H
--- a/src/declarative/util/qdeclarativeanimation.cpp
+++ b/src/declarative/util/qdeclarativeanimation.cpp
@@ -45,6 +45,7 @@
 #include "private/qdeclarativebehavior_p.h"
 #include "private/qdeclarativestateoperations_p.h"
 #include "private/qdeclarativecontext_p.h"
+#include "private/qdeclarativeaccessibility_p.h"
 
 #include <qdeclarativepropertyvaluesource.h>
 #include <qdeclarative.h>
@@ -221,6 +222,7 @@
         }
         if (!supressStart)
             d->commence();
+
         emit started();
     } else {
         if (d->alwaysRunToEnd) {
--- a/src/declarative/util/qdeclarativeanimation_p_p.h
+++ b/src/declarative/util/qdeclarativeanimation_p_p.h
@@ -210,7 +210,7 @@
     : running(false), paused(false), alwaysRunToEnd(false),
       connectedTimeLine(false), componentComplete(true),
       avoidPropertyValueSourceStart(false), disableUserControl(false),
-      registered(false), loopCount(1), group(0) {}
+      registered(false), loopCount(1), target(0), group(0) {}
 
     bool running:1;
     bool paused:1;
@@ -222,6 +222,7 @@
     bool registered:1;
 
     int loopCount;
+    QObject *target;
 
     void commence();
 
@@ -303,7 +304,7 @@
     Q_DECLARE_PUBLIC(QDeclarativePropertyAnimation)
 public:
     QDeclarativePropertyAnimationPrivate()
-    : QDeclarativeAbstractAnimationPrivate(), target(0), fromSourced(false), fromIsDefined(false), toIsDefined(false),
+    : QDeclarativeAbstractAnimationPrivate(), fromSourced(false), fromIsDefined(false), toIsDefined(false),
       rangeIsSet(false), defaultToInterpolatorType(0), interpolatorType(0), interpolator(0), va(0), actions(0) {}
 
     void init();
@@ -311,7 +312,6 @@
     QVariant from;
     QVariant to;
 
-    QObject *target;
     QString propertyName;
     QString properties;
     QList<QObject *> targets;
--- a/src/declarative/util/qdeclarativebehavior.cpp
+++ b/src/declarative/util/qdeclarativebehavior.cpp
@@ -43,6 +43,7 @@
 
 #include "private/qdeclarativeanimation_p.h"
 #include "private/qdeclarativetransition_p.h"
+#include "private/qdeclarativeaccessible_p.h"
 
 #include <qdeclarativecontext.h>
 #include <qdeclarativeinfo.h>
@@ -143,6 +144,7 @@
 void QDeclarativeBehavior::qtAnimationStateChanged(QAbstractAnimation::State newState,QAbstractAnimation::State)
 {
     Q_D(QDeclarativeBehavior);
+
     if (!d->blockRunningChanged)
         d->animation->notifyRunningChanged(newState == QAbstractAnimation::Running);
 }
--- a/src/declarative/util/qdeclarativetransitionmanager.cpp
+++ b/src/declarative/util/qdeclarativetransitionmanager.cpp
@@ -43,6 +43,8 @@
 
 #include "private/qdeclarativestate_p_p.h"
 #include "private/qdeclarativestate_p.h"
+#include "private/qdeclarativeengine_p.h"
+#include "private/qdeclarativeaccessible_p.h"
 
 #include <qdeclarativebinding_p.h>
 #include <qdeclarativeglobal_p.h>
@@ -64,6 +66,7 @@
     QDeclarativeGuard<QDeclarativeTransition> transition;
     QDeclarativeStateOperation::ActionList bindingsList;
     SimpleActionList completeList;
+    QSet<QObject *>accessibilityTargets;
 };
 
 QDeclarativeTransitionManager::QDeclarativeTransitionManager()
@@ -121,6 +124,9 @@
     QDeclarativeStateOperation::ActionList applyList = list;
     // Determine which actions are binding changes.
     foreach(const QDeclarativeAction &action, applyList) {
+        if (action.property.object())
+            d->accessibilityTargets.insert(action.property.object());
+
         if (action.toBinding)
             d->bindingsList << action;
         if (action.fromBinding)
--- a/src/declarative/util/qdeclarativeview.cpp
+++ b/src/declarative/util/qdeclarativeview.cpp
@@ -736,4 +736,10 @@
 
 }
 
+QDeclarativeItem * QDeclarativeView::accessibleRootItem() const
+{
+    Q_D(const QDeclarativeView);
+    return d->declarativeItemRoot;
+}
+
 QT_END_NAMESPACE
--- a/src/declarative/util/qdeclarativeview.h
+++ b/src/declarative/util/qdeclarativeview.h
@@ -59,6 +59,7 @@
 class QDeclarativeEngine;
 class QDeclarativeContext;
 class QDeclarativeError;
+class QDeclarativeItem;
 
 class QDeclarativeViewPrivate;
 class Q_DECLARATIVE_EXPORT QDeclarativeView : public QGraphicsView
@@ -110,6 +111,9 @@
 private:
     Q_DISABLE_COPY(QDeclarativeView)
     Q_DECLARE_PRIVATE(QDeclarativeView)
+// Accessibility support:
+    friend class QAccessibleDeclarativeView;
+    QDeclarativeItem *accessibleRootItem() const;
 };
 
 QT_END_NAMESPACE
--- a/src/declarative/util/util.pri
+++ b/src/declarative/util/util.pri
@@ -1,6 +1,7 @@
 INCLUDEPATH += $$PWD
 
 SOURCES += \
+    $$PWD/qdeclarativeaccessibility.cpp \
     $$PWD/qdeclarativeapplication.cpp \
     $$PWD/qdeclarativeutilmodule.cpp\
     $$PWD/qdeclarativeview.cpp \
@@ -31,6 +32,7 @@
     $$PWD/qlistmodelinterface.cpp
 
 HEADERS += \
+    $$PWD/qdeclarativeaccessibility_p.h \    
     $$PWD/qdeclarativeapplication_p.h \
     $$PWD/qdeclarativeutilmodule_p.h\
     $$PWD/qdeclarativeview.h \
--- a/src/gui/accessible/accessible.pri
+++ b/src/gui/accessible/accessible.pri
@@ -15,6 +15,7 @@
       mac:!embedded:!qpa {
         HEADERS += accessible/qaccessible_mac_p.h
         OBJECTIVE_SOURCES += accessible/qaccessible_mac.mm \
+                             accessible/qaccessibleuielement_mac.mm \
                              accessible/qaccessible_mac_cocoa.mm
       } else:win32 { 
         SOURCES += accessible/qaccessible_win.cpp
--- a/src/gui/accessible/qaccessible.cpp
+++ b/src/gui/accessible/qaccessible.cpp
@@ -424,14 +424,17 @@
     This enum specifies string information that an accessible object
     returns.
 
-    \value Name         The name of the object. This can be used both
-                        as an identifier or a short description by
-                        accessible clients.
-    \value Description  A short text describing the object.
-    \value Value        The value of the object.
-    \value Help         A longer text giving information about how to use the object.
-    \value Accelerator  The keyboard shortcut that executes the object's default action.
-    \value UserText     The first value to be used for user defined text.
+    \value Name             The name of the object. This can be used both
+                            as an identifier or a short description by
+                            accessible clients.
+    \value Description      A short text describing the object.
+    \value Value            The value of the object.
+    \value Help             A longer text giving information about how to use the object.
+    \value Accelerator      The keyboard shortcut that executes the object's default action.
+    \value DebugDescription A short text describing the accessible object type,
+                            for example the class name. The content of this text
+                            might change and is only suitable for debug output.
+    \value UserText         The first value to be used for user defined text.
 */
 
 /*!
@@ -857,14 +860,20 @@
     \a target. It is the caller's responsibility to delete *\a target
     after use.
 
-    If an object is found, \a target is set to point to the object, and
-    the index of the child of \a target is returned. The return value
-    is 0 if \a target itself is the requested object. \a target is set
-    to null if this object is the target object (i.e. the requested
-    object is a handled by this object).
+    The return value is 0 if \a target itself is the requested object.
 
-    If no object is found \a target is set to null, and the return
-    value is -1.
+    \list
+    \i If an object is found, \a target is set to point to the object, and 0
+    is returned.
+    \i If an object is found, but it is a child object that is handled by
+    this interface, \a target is set to 0 and the child index of the found
+    object is returned.
+    \i If the object found is itself, \a target will be refer to the same
+    object (however, the interface pointer might be different), and 0 is
+    returned.
+    \i If no object is found \a target is set to null, and the return value
+    is -1.
+    \endlist
 
     The \a entry parameter has two different meanings:
     \list
--- a/src/gui/accessible/qaccessible.h
+++ b/src/gui/accessible/qaccessible.h
@@ -230,6 +230,7 @@
         StaticText     = 0x00000029,
         EditableText   = 0x0000002A,  // Editable, selectable, etc.
         PushButton     = 0x0000002B,
+        Button         = PushButton,
         CheckBox       = 0x0000002C,
         RadioButton    = 0x0000002D,
         ComboBox       = 0x0000002E,
@@ -262,6 +263,7 @@
         Value,
         Help,
         Accelerator,
+        DebugDescription,
         UserText     = 0x0000ffff
     };
 
--- a/src/gui/accessible/qaccessible2.cpp
+++ b/src/gui/accessible/qaccessible2.cpp
@@ -244,6 +244,111 @@
     return text.mid(*startOffset, *endOffset - *startOffset);
 }
 
+
+#include <qtextboundaryfinder.h>
+
+QString QAccessibleTextInterface::textBeforeOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+        int *startOffset, int *endOffset, const QString& text)
+{
+    QTextBoundaryFinder::BoundaryType type;
+    switch (boundaryType) {
+    case QAccessible2::CharBoundary:
+        type = QTextBoundaryFinder::Grapheme;
+        break;
+    case QAccessible2::WordBoundary:
+        type = QTextBoundaryFinder::Word;
+        break;
+    case QAccessible2::SentenceBoundary:
+        type = QTextBoundaryFinder::Sentence;
+        break;
+    default:
+        // in any other case return the whole line
+        *startOffset = 0;
+        *endOffset = text.length();
+        return text;
+    }
+
+    QTextBoundaryFinder boundary(type, text);
+    boundary.setPosition(offset);
+
+    if (!boundary.isAtBoundary()) {
+        boundary.toPreviousBoundary();
+    }
+    boundary.toPreviousBoundary();
+    *startOffset = boundary.position();
+    boundary.toNextBoundary();
+    *endOffset = boundary.position();
+
+    return text.mid(*startOffset, *endOffset - *startOffset);
+}
+
+QString QAccessibleTextInterface::textAfterOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+        int *startOffset, int *endOffset, const QString& text)
+{
+    QTextBoundaryFinder::BoundaryType type;
+    switch (boundaryType) {
+    case QAccessible2::CharBoundary:
+        type = QTextBoundaryFinder::Grapheme;
+        break;
+    case QAccessible2::WordBoundary:
+        type = QTextBoundaryFinder::Word;
+        break;
+    case QAccessible2::SentenceBoundary:
+        type = QTextBoundaryFinder::Sentence;
+        break;
+    default:
+        // in any other case return the whole line
+        *startOffset = 0;
+        *endOffset = text.length();
+        return text;
+    }
+
+    QTextBoundaryFinder boundary(type, text);
+    boundary.setPosition(offset);
+
+    boundary.toNextBoundary();
+    *startOffset = boundary.position();
+    boundary.toNextBoundary();
+    *endOffset = boundary.position();
+
+    return text.mid(*startOffset, *endOffset - *startOffset);
+}
+
+QString QAccessibleTextInterface::textAtOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+        int *startOffset, int *endOffset, const QString& text)
+{
+    QTextBoundaryFinder::BoundaryType type;
+    switch (boundaryType) {
+    case QAccessible2::CharBoundary:
+        type = QTextBoundaryFinder::Grapheme;
+        break;
+    case QAccessible2::WordBoundary:
+        type = QTextBoundaryFinder::Word;
+        break;
+    case QAccessible2::SentenceBoundary:
+        type = QTextBoundaryFinder::Sentence;
+        break;
+    default:
+        // in any other case return the whole line
+        *startOffset = 0;
+        *endOffset = text.length();
+        return text;
+    }
+
+    QTextBoundaryFinder boundary(type, text);
+    boundary.setPosition(offset);
+
+    if (!boundary.isAtBoundary()) {
+        boundary.toPreviousBoundary();
+    }
+    *startOffset = boundary.position();
+    boundary.toNextBoundary();
+    *endOffset = boundary.position();
+
+    return text.mid(*startOffset, *endOffset - *startOffset);
+}
+
+
 QAccessibleSimpleEditableTextInterface::QAccessibleSimpleEditableTextInterface(
                 QAccessibleInterface *accessibleInterface)
     : iface(accessibleInterface)
--- a/src/gui/accessible/qaccessible2.h
+++ b/src/gui/accessible/qaccessible2.h
@@ -155,6 +155,14 @@
     virtual void setSelection(int selectionIndex, int startOffset, int endOffset) = 0;
     virtual int characterCount() = 0;
     virtual void scrollToSubstring(int startIndex, int endIndex) = 0;
+
+protected:
+    static QString textBeforeOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+            int *startOffset, int *endOffset, const QString& text);
+    static QString textAfterOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+            int *startOffset, int *endOffset, const QString& text);
+    static QString textAtOffsetFromString(int offset, QAccessible2::BoundaryType boundaryType,
+            int *startOffset, int *endOffset, const QString& text);
 };
 
 class Q_GUI_EXPORT QAccessibleEditableTextInterface: public QAccessible2Interface
--- a/src/gui/accessible/qaccessible_mac.mm
+++ b/src/gui/accessible/qaccessible_mac.mm
@@ -446,7 +446,7 @@
         return qHash(item.cachedObject()) + qHash(item.id());
 }
 
-QAInterface QAInterface::navigate(RelationFlag relation, int entry) const
+QAInterface QAInterface::navigate(QAccessible::RelationFlag relation, int entry) const
 {
         if (!checkValid())
             return QAInterface();
@@ -668,9 +668,10 @@
         return false;
 
     // Some roles are not interesting:
-    if (role == QAccessible::Border ||    // QFrame
+    if (role == QAccessible::Border ||      // QFrame
         role == QAccessible::Application || // We use the system-provided application element.
-        role == QAccessible::MenuItem)      // The system also provides the menu items.
+        role == QAccessible::MenuItem ||    // The system also provides the menu items.
+        role == QAccessible::Pane)          // Generic Container.
         return false;
 
     // It is probably better to access the toolbar buttons directly than having
--- a/src/gui/accessible/qaccessible_mac_cocoa.mm
+++ b/src/gui/accessible/qaccessible_mac_cocoa.mm
@@ -42,6 +42,7 @@
 
 #include "qaccessible.h"
 #include "qaccessible_mac_p.h"
+#include "qaccessibleuielement_mac_p.h"
 #include "qdebug.h"
 #include "qtabwidget.h"
 
@@ -49,7 +50,6 @@
 #include <private/qcocoaview_mac_p.h>
 #include <private/qwidget_p.h>
 
-
 #ifndef QT_NO_ACCESSIBILITY
 
 #ifdef QT_MAC_USE_COCOA
@@ -71,9 +71,17 @@
 typedef QMap<QAccessible::Role, NSString *> QMacAccessibiltyRoleMap;
 Q_GLOBAL_STATIC(QMacAccessibiltyRoleMap, qMacAccessibiltyRoleMap);
 
-static QAInterface interfaceForView(QT_MANGLE_NAMESPACE(QCocoaView) *view)
+static QAccessibleInterface *interfaceForView(QT_MANGLE_NAMESPACE(QCocoaView) *view)
 {
-    return QAInterface(QAccessible::queryAccessibleInterface([view qt_qwidget]));
+    return QAccessible::queryAccessibleInterface([view qt_qwidget]);
+}
+
+static QAccessibleUIElement *createUIElementForView(QT_MANGLE_NAMESPACE(QCocoaView) *view)
+{
+    QAccessibleInterface * interface = QAccessible::queryAccessibleInterface([view qt_qwidget]);
+    id parent = [view superview];
+    QAccessibleUIElement *element = [QAccessibleUIElement elementWithAccessibleInterface:interface parent:parent];
+    return element;
 }
 
 /*
@@ -128,25 +136,40 @@
     Returns a Mac accessibility role for the given interface, or
     NSAccessibilityUnknownRole if no role mapping is found.
 */
-static NSString *macRoleForInterface(QAInterface interface)
+NSString *macRoleForInterface(QAInterface interface)
+{
+    return macRoleForInterface(interface.interfaceWrapper().interface);
+}
+
+NSString *macRoleForInterface(QAccessibleInterface *interface)
 {
-    const QAccessible::Role qtRole = interface.role();
+    if (!interface)
+        return NSAccessibilityUnknownRole;
+
+    const QAccessible::Role qtRole = interface->role(0);
     QMacAccessibiltyRoleMap &roleMap = *qMacAccessibiltyRoleMap();
 
+    // qDebug() << interface->object() << "qtRole" << qtRole;
+
     if (roleMap.isEmpty())
         populateRoleMap();
 
-    MAC_ACCESSIBILTY_DEBUG() << "role for" << interface.object() << "interface role" << hex << qtRole;
+    //MAC_ACCESSIBILTY_DEBUG() << "role for" << interface->object() << "interface role" << hex << qtRole;
 
     if (roleMap.contains(qtRole)) {
-        MAC_ACCESSIBILTY_DEBUG() << "return" <<  roleMap[qtRole];
+        //MAC_ACCESSIBILTY_DEBUG() << "return" <<  roleMap[qtRole];
         return roleMap[qtRole];
     }
 
+#ifdef MAC_ACCESSIBILTY_DEVELOPER_MODE
+    return NSAccessibilityGroupRole;
+#else
     MAC_ACCESSIBILTY_DEBUG() << "return NSAccessibilityUnknownRole";
     return NSAccessibilityUnknownRole;
+#endif
 }
 
+
 /*
     Is the interface a QTabBar embedded in a QTabWidget?
     (as opposed to a stand-alone tab bar)
@@ -199,36 +222,26 @@
 
 - (BOOL)accessibilityIsIgnored
 {
-    QT_PREPEND_NAMESPACE(QAInterface) interface = QT_PREPEND_NAMESPACE(interfaceForView)(self);
-    return isInterfaceIgnored(interface);
+   // MAC_ACCESSIBILTY_DEBUG() << "accessibilityIsIgnored" << self;
+
+    QAccessibleUIElement *acccessibleUIElement = QT_PREPEND_NAMESPACE(createUIElementForView)(self);
+    return [acccessibleUIElement accessibilityIsIgnored];
 }
 
 - (NSArray *)accessibilityAttributeNames
 {
-    QT_PREPEND_NAMESPACE(QAInterface) interface = QT_PREPEND_NAMESPACE(interfaceForView)(self);
-
-    static NSArray *attributes = nil;
-    if (attributes == nil) {
-        attributes = [super accessibilityAttributeNames];
-
-    }
-    return attributes;
+    //MAC_ACCESSIBILTY_DEBUG() << "accessibilityAttributeNames" << self;
+    QAccessibleUIElement *acccessibleUIElement = QT_PREPEND_NAMESPACE(createUIElementForView)(self);
+    return [acccessibleUIElement accessibilityAttributeNames];
 }
 
 - (id)accessibilityAttributeValue:(NSString *)attribute
 {
-    MAC_ACCESSIBILTY_DEBUG() << "accessibilityAttributeValue" << self <<  
-            QT_PREPEND_NAMESPACE(QCFString)::toQString(reinterpret_cast<CFStringRef>(attribute));
+    //MAC_ACCESSIBILTY_DEBUG() << "accessibilityAttributeValue" << self <<
+    //        QT_PREPEND_NAMESPACE(QCFString)::toQString(reinterpret_cast<CFStringRef>(attribute));
 
-    QT_PREPEND_NAMESPACE(QAInterface) interface = QT_PREPEND_NAMESPACE(interfaceForView)(self);
-
-    // Switch on the attribute name and call the appropriate handler function.
-    // Pass the call on to the NSView class for attributes we don't handle.
-    if ([attribute isEqualToString:@"AXRole"]) {
-        return macRoleForInterface(interface);
-    } else {
-        return [super accessibilityAttributeValue:attribute];    
-    }
+    QAccessibleUIElement *acccessibleUIElement = QT_PREPEND_NAMESPACE(createUIElementForView)(self);
+    return [acccessibleUIElement accessibilityAttributeValue : attribute];
 }
 
 @end
--- a/src/gui/accessible/qaccessible_mac_p.h
+++ b/src/gui/accessible/qaccessible_mac_p.h
@@ -160,7 +160,7 @@
     bool operator==(const QAInterface &other) const;
     bool operator!=(const QAInterface &other) const;
 
-    inline QString actionText (int action, Text text) const
+    inline QString actionText (int action, QAccessible::Text text) const
     { return base.interface->actionText(action, text, child); }
 
     QAInterface childAt(int x, int y) const
@@ -230,7 +230,7 @@
         base.interface->doAction(action, child, params);
     }
 
-    QAInterface navigate(RelationFlag relation, int entry) const;
+    QAInterface navigate(QAccessible::RelationFlag relation, int entry) const;
 
     inline QObject * object() const
     {
@@ -283,28 +283,28 @@
         return base.interface->rect(child);
     }
 
-    inline Role role() const
+    inline QAccessible::Role role() const
     {
         if (!checkValid())
             return QAccessible::NoRole;
         return base.interface->role(child);
     }
 
-    inline void setText(Text t, const QString &text) const
+    inline void setText(QAccessible::Text t, const QString &text) const
     {
         if (!checkValid())
             return;
         base.interface->setText(t, child, text);
     }
 
-    inline State state() const
+    inline QAccessible::State state() const
     {
         if (!checkValid())
             return 0;
         return base.interface->state(child);
     }
 
-    inline QString text (Text text) const
+    inline QString text (QAccessible::Text text) const
     {
         if (!checkValid())
             return QString();
--- a/src/gui/accessible/qaccessible_win.cpp
+++ b/src/gui/accessible/qaccessible_win.cpp
@@ -149,9 +149,9 @@
        "UserRole"       /* = 0x0000ffff*/
    };
 
-   if (role >=0x40)
-        role = QAccessible::UserRole;
-   return roles[int(role)];
+   if (role > 0x40)
+       role = QAccessible::NoRole;
+   return roles[role];
 }
 
 static const char *eventString(QAccessible::Event ev)
@@ -254,17 +254,25 @@
     return "unknown";
 };
 
-void showDebug(const char* funcName, const QAccessibleInterface *iface)
+void showDebug_helper(const char* funcName, const QAccessibleInterface *iface, int childEntry)
 {
-    qDebug() << "Role:" << roleString(iface->role(0)) 
-             << "Name:" << iface->text(QAccessible::Name, 0) 
-             << "State:" << QString::number(int(iface->state(0)), 16) 
+    int validEntry = qMax(childEntry, 0);
+    qDebug() << iface->object() << ", childEntry:" << childEntry
+             << "Role:" << roleString(iface->role(validEntry))
+             << "Name:" << iface->text(QAccessible::Name, validEntry)
+             << "State:" << QString::number(int(iface->state(validEntry)), 16)
              << QLatin1String(funcName);
 }
 #else
-# define showDebug(f, iface)
+# define showDebug_helper(f, iface, entry) Q_UNUSED(f); Q_UNUSED(iface); Q_UNUSED(entry)
 #endif
 
+inline void showDebug(const char* funcName, const QAccessibleInterface *iface, int childEntry = 0)
+{
+    showDebug_helper(funcName, iface, childEntry);
+}
+
+
 // This stuff is used for widgets/items with no window handle:
 typedef QMap<int, QPair<QPointer<QObject>, int> > NotifyMap;
 Q_GLOBAL_STATIC(NotifyMap, qAccessibleRecentSentEvents)
@@ -391,7 +399,6 @@
 
     } while (p);
 
-    //qDebug() << "updateAccessibility(), hwnd:" << w << ", object:" << o << "," << eventString(reason);
     if (!w) {
         if (reason != QAccessible::ContextHelpStart &&
              reason != QAccessible::ContextHelpEnd)
@@ -991,7 +998,9 @@
 }
 
 /*
-  IAccessible
+  Used for:
+  * Reading the contents below where the mouse cursor hovers?
+  * A11y development tools (Inspect, Accessibility Explorer, ...)
 */
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::accHitTest(long xLeft, long yTop, VARIANT *pvarID)
 {
@@ -999,20 +1008,33 @@
     if (!accessible->isValid())
         return E_FAIL;
 
-    int control = accessible->childAt(xLeft, yTop);
-    if (control == -1) {
-        (*pvarID).vt = VT_EMPTY;
-        return S_FALSE;
-    }
     QAccessibleInterface *acc = 0;
-    if (control)
-        accessible->navigate(Child, control, &acc);
+    if (QGraphicsView *gv = qobject_cast<QGraphicsView*>(accessible->object())) {
+        /* Optimize hit testing for QGraphicsView, since the default implementation
+         * of QAccessibleDeclarativeObject::childAt() might be very slow.
+         */
+        QPoint p(xLeft, yTop);
+        p = gv->mapFromGlobal(p);
+        QGraphicsItem *item = gv->itemAt(p);
+        QObject *obj = item ? item->toGraphicsObject() : 0;
+        if (obj)
+            acc = QAccessible::queryAccessibleInterface(obj);
+    }
     if (!acc) {
-        (*pvarID).vt = VT_I4;
-        (*pvarID).lVal = control;
-        return S_OK;
+        int control = accessible->childAt(xLeft, yTop);
+        if (control == -1) {
+            (*pvarID).vt = VT_EMPTY;
+            return S_FALSE;
+        }
+        if (control)
+            accessible->navigate(Child, control, &acc);
+        if (!acc) {
+            (*pvarID).vt = VT_I4;
+            (*pvarID).lVal = control;
+            Q_ASSERT(control >= 0);
+            return S_OK;
+        }
     }
-
     QWindowsAccessible* wacc = new QWindowsAccessible(acc);
     IDispatch *iface = 0;
     wacc->QueryInterface(IID_IDispatch, (void**)&iface);
@@ -1030,7 +1052,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varID)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1106,6 +1128,7 @@
     if (!acc) {
         (*pvarEnd).vt = VT_I4;
         (*pvarEnd).lVal = control;
+        Q_ASSERT(control >= 0);
         return S_OK;
     }
 
@@ -1163,6 +1186,7 @@
         return E_FAIL;
 
     *pcountChildren = accessible->childCount();
+    Q_ASSERT(*pcountChildren >= 0);
     return S_OK;
 }
 
@@ -1191,7 +1215,7 @@
 */
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::accDoDefaultAction(VARIANT varID)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1202,7 +1226,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accDefaultAction(VARIANT varID, BSTR* pszDefaultAction)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1219,7 +1243,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accDescription(VARIANT varID, BSTR* pszDescription)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1236,7 +1260,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accHelp(VARIANT varID, BSTR *pszHelp)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1258,7 +1282,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accKeyboardShortcut(VARIANT varID, BSTR *pszKeyboardShortcut)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1275,7 +1299,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accName(VARIANT varID, BSTR* pszName)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1298,7 +1322,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accRole(VARIANT varID, VARIANT *pvarRole)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1317,7 +1341,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accState(VARIANT varID, VARIANT *pvarState)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1329,7 +1353,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::get_accValue(VARIANT varID, BSTR* pszValue)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1352,7 +1376,7 @@
 
 HRESULT STDMETHODCALLTYPE QWindowsAccessible::accSelect(long flagsSelect, VARIANT varID)
 {
-    showDebug(__FUNCTION__, accessible);
+    showDebug(__FUNCTION__, accessible, varID.lVal);
     if (!accessible->isValid())
         return E_FAIL;
 
@@ -1393,6 +1417,7 @@
     if (!acc || control == 0) {
         (*pvarID).vt = VT_I4;
         (*pvarID).lVal = control ? control : CHILDID_SELF;
+        Q_ASSERT(control >= 0);
         return S_OK;
     }
 
--- /dev/null
+++ b/src/gui/accessible/qaccessibleuielement_mac.mm
@@ -0,0 +1,182 @@
+#import "qaccessibleuielement_mac_p.h"
+
+#import <AppKit/NSAccessibility.h>
+
+#include <qaccessible.h>
+#include <qdebug.h>
+
+NSString *macRoleForInterface(QAccessibleInterface *interface);
+
+@implementation QAccessibleUIElement
+
+#define MAC_ACCESSIBILTY_DEVELOPER_MODE
+
+- (id)initWithAccessibleInterface:(QAccessibleInterface *)aInterface parent:(id)aParent {
+    if ((self = [super init])) {
+        role = macRoleForInterface(aInterface);
+        interface = aInterface;
+        parent = [aParent retain];
+    }
+    return self;
+}
+
++ (QAccessibleUIElement *)elementWithAccessibleInterface:(QAccessibleInterface *)aInterface parent:(id)aParent {
+    return [[[self alloc] initWithAccessibleInterface:aInterface parent:aParent] autorelease];
+}
+
+- (void)dealloc {
+    delete interface;
+    [parent autorelease];
+    [super dealloc];
+}
+
+- (BOOL)isEqual:(id)object {
+    if ([object isKindOfClass:[QAccessibleUIElement self]]) {
+        QAccessibleUIElement *other = object;
+        return [role isEqualToString:other->role] && [parent isEqual:other->parent];
+    } else {
+        return NO;
+    }
+}
+
+- (NSUInteger)hash {
+    // Equal objects must hash the same.
+    return qHash(interface->object());
+}
+
+//
+// accessibility protocol
+//
+
+// attributes
+
+- (NSArray *)accessibilityAttributeNames {
+    static NSArray *attributes = nil;
+    if (attributes == nil) {
+	attributes = [[NSArray alloc] initWithObjects:
+	    NSAccessibilityRoleAttribute,
+	    NSAccessibilityRoleDescriptionAttribute,
+            NSAccessibilityChildrenAttribute,
+#ifdef MAC_ACCESSIBILTY_DEVELOPER_MODE
+            NSAccessibilityDescriptionAttribute,
+#endif
+	    NSAccessibilityFocusedAttribute,
+	    NSAccessibilityParentAttribute,
+	    NSAccessibilityWindowAttribute,
+	    NSAccessibilityTopLevelUIElementAttribute,
+	    NSAccessibilityPositionAttribute,
+	    NSAccessibilitySizeAttribute,
+	    nil];
+    }
+    return attributes;
+}
+
+- (id)accessibilityAttributeValue:(NSString *)attribute {
+    if ([attribute isEqualToString:NSAccessibilityRoleAttribute]) {
+	return role;
+    } else if ([attribute isEqualToString:NSAccessibilityRoleDescriptionAttribute]) {
+	return NSAccessibilityRoleDescription(role, nil);
+    } else if ([attribute isEqualToString:NSAccessibilityChildrenAttribute]) {
+//        NSMutableArray *kids = [NSMutableArray arrayWithCapacity: 0];
+//        return kids;
+
+        int childCount = interface->childCount();
+        //qDebug() << "widget" << interface->object() << childCount;
+        NSMutableArray *kids = [NSMutableArray arrayWithCapacity: 0];
+        for (int i = 0; i < childCount; ++i) {
+          //  qDebug() << "testing" <<  i;
+            QAccessibleInterface *child = 0;
+            int ret = interface->navigate(QAccessible::Child, i + 1, &child);
+            if (child && ret == 0) {
+                QAccessibleUIElement *uielement = [QAccessibleUIElement elementWithAccessibleInterface:child parent:self];
+//                qDebug() << "add kid"<< i << uielement;
+                [kids addObject: uielement];
+            } else {
+                delete child;
+            }
+        }
+        return kids;
+        //return NSAccessibilityUnignoredChildren(kids);
+
+#ifdef MAC_ACCESSIBILTY_DEVELOPER_MODE
+    } else if ([attribute isEqualToString: NSAccessibilityDescriptionAttribute]) {
+        QObject *object = interface->object();
+        if (object) {
+            const char *className = object->metaObject()->className();
+            return [NSString stringWithUTF8String : className];
+        } else {
+            return @"(no object)";
+        }
+#endif
+    } else if ([attribute isEqualToString:NSAccessibilityFocusedAttribute]) {
+        // Just check if the app thinks we're focused.
+        id focusedElement = [NSApp accessibilityAttributeValue:NSAccessibilityFocusedUIElementAttribute];
+        return [NSNumber numberWithBool:[focusedElement isEqual:self]];
+    } else if ([attribute isEqualToString:NSAccessibilityParentAttribute]) {
+        return NSAccessibilityUnignoredAncestor(parent);
+    } else if ([attribute isEqualToString:NSAccessibilityWindowAttribute]) {
+        // We're in the same window as our parent.
+        return [parent accessibilityAttributeValue:NSAccessibilityWindowAttribute];
+    } else if ([attribute isEqualToString:NSAccessibilityTopLevelUIElementAttribute]) {
+        // We're in the same top level element as our parent.
+        return [parent accessibilityAttributeValue:NSAccessibilityTopLevelUIElementAttribute];
+    } else if ([attribute isEqualToString:NSAccessibilityPositionAttribute]) {
+        QRect rect = interface->rect(0);
+        // qDebug() << "rect" << rect << rect.x()<< rect.y();
+        return [NSValue valueWithPoint: NSMakePoint(rect.x(), rect.y())];
+    } else if ([attribute isEqualToString:NSAccessibilitySizeAttribute]) {
+        QRect rect = interface->rect(0);
+        return [NSValue valueWithSize: NSMakeSize(rect.width(), rect.height())];
+    } else {
+        return nil;
+    }
+}
+
+- (BOOL)accessibilityIsAttributeSettable:(NSString *)attribute {
+    if ([attribute isEqualToString:NSAccessibilityFocusedAttribute]) {
+        // return [parent isFauxUIElementFocusable:self];
+        return YES;
+    } else {
+        return NO;
+    }
+}
+
+- (void)accessibilitySetValue:(id)value forAttribute:(NSString *)attribute {
+    if ([attribute isEqualToString:NSAccessibilityFocusedAttribute]) {
+        // [parent fauxUIElement:self setFocus:value];
+    }
+}
+
+
+// actions
+
+- (NSArray *)accessibilityActionNames {
+    return [NSArray array];
+}
+
+- (NSString *)accessibilityActionDescription:(NSString *)action {
+    Q_UNUSED(action);
+    return nil;
+}
+
+- (void)accessibilityPerformAction:(NSString *)action {
+    Q_UNUSED(action);
+}
+
+
+// misc
+
+- (BOOL)accessibilityIsIgnored {
+    return NO;
+}
+
+- (id)accessibilityHitTest:(NSPoint)point {
+    Q_UNUSED(point);
+    return NSAccessibilityUnignoredAncestor(self);
+}
+
+- (id)accessibilityFocusedUIElement {
+    return NSAccessibilityUnignoredAncestor(self);
+}
+
+@end
--- /dev/null
+++ b/src/gui/accessible/qaccessibleuielement_mac_p.h
@@ -0,0 +1,27 @@
+#import <Cocoa/Cocoa.h>
+
+class QAccessibleInterface;
+@interface QAccessibleUIElement : NSObject {
+    QAccessibleInterface *interface;
+    NSString *role;
+    id parent;
+}
+
+- (id)initWithAccessibleInterface:(QAccessibleInterface *)aInterface parent:(id)aParent;
++ (QAccessibleUIElement *)elementWithAccessibleInterface:(QAccessibleInterface *)aInterface parent:(id)aParent;
+
+@end
+
+/*
+@interface NSObject (FauxUIElementChildSupport)
+
+// Anyone serving as a parent for FauxUIElements must implement this protocol.
+
+- (BOOL)isFauxUIElementFocusable:(FauxUIElement *)fauxElement;
+- (void)fauxUIElement:(FauxUIElement *)fauxElement setFocus:(id)value;
+
+- (NSPoint)fauxUIElementPosition:(FauxUIElement *)fauxElement;
+- (NSSize)fauxUIElementSize:(FauxUIElement *)fauxElement;
+
+@end
+*/
--- a/src/plugins/accessible/widgets/main.cpp
+++ b/src/plugins/accessible/widgets/main.cpp
@@ -45,6 +45,11 @@
 #include "rangecontrols.h"
 #include "complexwidgets.h"
 #include "itemviews.h"
+#include "qaccessibledeclarativeview.h"
+#include "qaccessibledeclarativeobject.h"
+#include "qaccessiblegraphicsviewimplementation.h"
+#include "qdeclarativeitem.h"
+#include "qgraphicsview.h"
 
 #include <qaccessibleplugin.h>
 #include <qplugin.h>
@@ -75,6 +80,8 @@
 QStringList AccessibleFactory::keys() const
 {
     QStringList list;
+    list << QLatin1String("QSGItem");
+    list << QLatin1String("QDeclarativeItem");
 #ifndef QT_NO_LINEEDIT
     list << QLatin1String("QLineEdit");
 #endif
@@ -160,11 +167,28 @@
 QAccessibleInterface *AccessibleFactory::create(const QString &classname, QObject *object)
 {
     QAccessibleInterface *iface = 0;
+
+    if (0) {
+    } else if (QDeclarativeItem *item = qobject_cast<QDeclarativeItem *>(object)) {
+        if (!item->scene())
+            return 0;
+
+        QList<QGraphicsView *> views = item->scene()->views();
+        if (views.isEmpty())
+            return 0;
+        QGraphicsView *view = views.at(0); // Accessibility support for the first view only.
+                                           // (Not a problem for QDeclarative)
+        iface = QAccessibleGraphicsViewImplementation::instantiateObject(item, view);
+    }
+
     if (!object || !object->isWidgetType())
         return iface;
+
     QWidget *widget = static_cast<QWidget*>(object);
 
-    if (false) {
+    if (iface) {
+    } else if (qobject_cast<QDeclarativeView *>(widget) != 0) {
+        iface = new QAccessibleDeclarativeView(widget);
 #ifndef QT_NO_LINEEDIT
     } else if (classname == QLatin1String("QLineEdit")) {
         iface = new QAccessibleLineEdit(widget);
--- /dev/null
+++ b/src/plugins/accessible/widgets/qaccessibledeclarativeimplementation.cpp
@@ -0,0 +1,11 @@
+#include "qaccessibledeclarativeimplementation.h"
+
+QAccessibleDeclarativeImplementation::QAccessibleDeclarativeImplementation()
+    :m_accessibleObject(0)
+{
+}
+
+void QAccessibleDeclarativeImplementation::setBaseObject(QAccessibleObjectEx *accessibleObject)
+{
+    m_accessibleObject = accessibleObject;
+}
--- /dev/null
+++ b/src/plugins/accessible/widgets/qaccessibledeclarativeimplementation.h
@@ -0,0 +1,37 @@
+#ifndef QACCESSIBLEDECLARATIVEIMPLEMENTATION_H
+#define QACCESSIBLEDECLARATIVEIMPLEMENTATION_H
+
+#include <qaccessibleobject.h>
+
+#ifndef QT_NO_ACCESSIBILITY
+
+class QAccessibleDeclarativeObject;
+class QAccessibleDeclarativeImplementation
+{
+public:
+    QAccessibleDeclarativeImplementation();
+    void setBaseObject(QAccessibleObjectEx *accessibleObject);
+
+    /* geometry */
+    virtual QRect itemRect() const = 0;
+    virtual QRect viewRect() const = 0;
+
+    /* hit testing */
+    virtual bool clipsChildren() const = 0;
+
+    /* hierarchy */
+    virtual int childCount() const = 0;
+    virtual int navigate(QAccessible::RelationFlag rel, int entry, QAccessibleInterface **target) const = 0;
+    virtual int indexOfChild(const QAccessibleInterface *iface) const = 0;
+
+    virtual QFlags<QAccessible::StateFlag> state() const = 0;
+    virtual bool isAccessible() const  = 0;
+protected:
+    QAccessibleObjectEx *m_accessibleObject;
+};
+
+#endif // QT_NO_ACCESSIBILITY
+
+QT_END_NAMESPACE
+
+#endif // QACCESSIBLEDECLARATIVEIMPLEMENTATION_H
--- /dev/null
+++ b/src/plugins/accessible/widgets/qaccessibledeclarativeobject.cpp
@@ -0,0 +1,401 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qaccessibledeclarativeobject.h"
+#include <qnamespace.h>
+
+#ifndef QT_NO_ACCESSIBILITY
+
+QT_BEGIN_NAMESPACE
+
+
+/*
+    Creates a new QAccessibleDeclarativeObject instance bases on the objects
+    accessibleRole. Takes ownership of the implementation object.
+*/
+QAccessibleDeclarativeObject *QAccessibleDeclarativeObject::instantiateObject(QObject *object, QAccessibleDeclarativeImplementation *implementation)
+{
+    const QVariant role = QDeclarativeAccessibleAttached::property(object, "role");
+    const QAccessible::Role roleAttribute = static_cast<QAccessible::Role>(role.toInt());
+
+    QAccessibleDeclarativeObject *accessibleObject = 0;
+
+    // Add code here to map roleAttributes to QAccessibleRoles and
+    // QAccessibleDeclarativeObject subclasses.
+    if (0) {
+    } else if (roleAttribute == QAccessible::PushButton) {
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::PushButton);
+    } else if (roleAttribute == QAccessible::StaticText) {
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::StaticText);
+    } else if (roleAttribute == QAccessible::CheckBox) {
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::CheckBox);
+    } else if (roleAttribute == QAccessible::RadioButton) {
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::RadioButton);
+    } else if (roleAttribute == QAccessible::EditableText) {
+        accessibleObject = new QAccessibleDeclarativeEditableTextObject(object, implementation, QAccessible::EditableText);
+
+    /*
+    TODO
+    } else if (roleAttribute == QLatin1String("ProgressBar")) {
+       accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::ProgressBar);
+    } else if (roleAttribute == QLatin1String("Slider")) {
+       accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::Slider);
+*/
+    } else {
+        // This handles unknown roles and items with no role set.
+        accessibleObject = new QAccessibleDeclarativeObject(object, implementation, QAccessible::Pane);
+    }
+
+    // the graphicsview/scene graph implementation might need to call down to
+    // QAccessibleObjectEx, give it a pointer (we still own the object).
+    implementation->setBaseObject(accessibleObject);
+
+    return accessibleObject;
+}
+
+QAccessibleDeclarativeObject::QAccessibleDeclarativeObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role)
+    :QAccessibleObjectEx(object)
+    ,m_implementation(implementation)
+    ,m_role(role)
+{
+
+}
+
+QAccessibleDeclarativeObject::~QAccessibleDeclarativeObject()
+{
+    delete m_implementation;
+}
+
+bool QAccessibleDeclarativeObject::hasChildren() const
+{
+    if (m_role == PushButton ||
+        m_role == CheckBox ||
+        m_role == RadioButton ||
+        m_role == EditableText) {
+        return false;
+    }
+    return true;
+}
+
+QRect QAccessibleDeclarativeObject::rect(int child) const
+{
+    return m_implementation->itemRect();
+}
+
+int QAccessibleDeclarativeObject::childCount() const
+{
+    if (!hasChildren())
+       return 0;
+
+    if (!m_implementation->isAccessible())
+        return 0;
+
+    return m_implementation->childCount();
+}
+
+int QAccessibleDeclarativeObject::navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const
+{
+    if (rel == QAccessible::Child && !hasChildren()) {
+        *target = 0;
+        return -1;
+    }
+
+    return m_implementation->navigate(rel, entry, target);
+}
+
+int QAccessibleDeclarativeObject::indexOfChild(const QAccessibleInterface *iface) const
+{
+    if (iface) {
+        return m_implementation->indexOfChild(iface);
+    }
+    return -1;
+
+}
+
+QFlags<QAccessible::RelationFlag> QAccessibleDeclarativeObject::relationTo(int, const QAccessibleInterface*, int) const
+{
+    return 0;
+}
+
+int QAccessibleDeclarativeObject::childAt(int x, int y) const
+{
+    // Look for children first.
+    // Start with the last child first, because children are ordered in paint order
+    // (which is opposite of hit test order)
+    int hitChild = -1;
+    // If the item clips its children, we can return early if the coordinate is outside its rect
+    if (m_implementation->clipsChildren()) {
+        if (!m_implementation->itemRect().contains(x, y))
+            return -1;
+    }
+    for (int i = childCount(); i > 0 && hitChild == -1; --i) {
+        QAccessibleInterface *child = 0;
+        int id = navigate(QAccessible::Child, i, &child);
+        if (child && id == 0) {
+            if (!(child->state(0) & QAccessible::Invisible)) {
+                if (child->childAt(x, y) != -1)
+                    hitChild = i;
+            }
+            delete child;
+        }
+    }
+
+    if (hitChild == -1) {
+        if (m_implementation->itemRect().contains(x, y))
+            hitChild = 0;
+    }
+
+    return hitChild;
+}
+
+QString QAccessibleDeclarativeObject::text(QAccessible::Text textType, int) const
+{
+    // handles generic behaviour not specific to an item
+    switch (textType) {
+    case QAccessible::DebugDescription:
+        return object()->metaObject()->className();
+        break;
+    case QAccessible::Name: {
+        QVariant accessibleName = QDeclarativeAccessibleAttached::property(object(), "name");
+        if (!accessibleName.isNull())
+            return accessibleName.toString();
+        break;}
+    case QAccessible::Description: {
+        QVariant accessibleDecription = QDeclarativeAccessibleAttached::property(object(), "description");
+        if (!accessibleDecription.isNull())
+            return accessibleDecription.toString();
+        break;}
+    case Value:
+    case Help:
+    case Accelerator:
+    default:
+        break;
+    }
+
+
+    // the following blocks handles item-specific behaviour
+    if (m_role == QAccessible::EditableText) {
+        if (textType == QAccessible::Value) {
+            QVariant text = object()->property("text");
+            return text.toString();
+        } else if (textType == QAccessible::Name) {
+            return object()->objectName();
+        }
+    } else {
+        if (textType == QAccessible::Name) {
+            QVariant text = object()->property("text");
+            return text.toString();
+        }
+    }
+
+
+    return QString();
+}
+
+QAccessible::Role QAccessibleDeclarativeObject::role(int) const
+{
+    return m_role;
+}
+
+QFlags<QAccessible::StateFlag> QAccessibleDeclarativeObject::state(int) const
+{
+    QAccessible::State state = m_implementation->state();
+
+    //QRect viewRect(QPoint(0, 0), m_implementation->size());
+    //QRect itemRect(m_item->scenePos().toPoint(), m_item->boundingRect().size().toSize());
+
+    QRect viewRect = m_implementation->viewRect();
+    QRect itemRect = m_implementation->itemRect();
+
+   // qDebug() << "viewRect" << viewRect << "itemRect" << itemRect;
+    // error case:
+    if (viewRect.isNull() || itemRect.isNull()) {
+        state |= QAccessible::Invisible;
+    }
+
+    if (!viewRect.intersects(itemRect)) {
+        state |= QAccessible::Offscreen;
+        // state |= QAccessible::Invisible; // no set at this point to ease development
+    }
+
+    if (!object()->property("visible").toBool() || qFuzzyIsNull(object()->property("opacity").toDouble())) {
+        state |= QAccessible::Invisible;
+    }
+
+    if ((m_role == CheckBox || m_role == RadioButton) && object()->property("checked").toBool()) {
+        state |= QAccessible::Checked;
+    }
+
+    if (m_role == QAccessible::EditableText)
+        state |= QAccessible::Focusable;
+
+    //qDebug() << "state?" << m_item->property("state").toString() << m_item->property("status").toString() << m_item->property("visible").toString();
+
+    return state;
+}
+
+bool QAccessibleDeclarativeObject::doAction(int action, int child, const QVariantList &params)
+{
+    if (m_role == PushButton && action == QAccessible::Press) {
+        QMetaObject::invokeMethod(object(), "accessibleAction", Q_ARG(QVariant, action));
+    }
+    if ((m_role == CheckBox || m_role == RadioButton) && action == QAccessible::Press) {
+        bool checked = object()->property("checked").toBool();
+        object()->setProperty("checked",  QVariant(!checked));
+    }
+
+    return QAccessibleObjectEx::doAction(action, child, params);
+}
+
+QVariant QAccessibleDeclarativeObject::invokeMethodEx(QAccessible::Method method, int, const QVariantList&)
+{
+    return QVariant();
+}
+
+
+// TEXT interface
+
+QAccessibleDeclarativeTextObject::QAccessibleDeclarativeTextObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role)
+    : QAccessibleDeclarativeObject(object, implementation, role)
+{
+}
+
+QFlags<QAccessible::StateFlag> QAccessibleDeclarativeTextObject::state(int child) const
+{
+    Q_ASSERT(child == 0);
+    return QAccessibleDeclarativeObject::state(child) | HasInvokeExtension;
+}
+
+QString QAccessibleDeclarativeTextObject::text() const
+{
+    QVariant text = object()->property("text");
+    return text.toString();
+}
+
+void QAccessibleDeclarativeTextObject::setText(QAccessible::Text t, int child, const QString& text)
+{
+    Q_ASSERT(child == 0);
+    // do we care about the type?
+    object()->setProperty("text", text);
+}
+
+int QAccessibleDeclarativeTextObject::characterCount()
+{
+    return text().length();
+}
+
+QString QAccessibleDeclarativeTextObject::text(int startOffset, int endOffset)
+{
+    // FIXME: password mode in all of these?
+    return text().mid(startOffset, endOffset - startOffset);
+}
+
+
+
+QString QAccessibleDeclarativeTextObject::textAfterOffset(int offset, QAccessible2::BoundaryType boundaryType, int* startOffset, int* endOffset)
+{
+    return textAfterOffsetFromString(offset, boundaryType, startOffset, endOffset, text());
+}
+
+QString QAccessibleDeclarativeTextObject::textAtOffset(int offset, QAccessible2::BoundaryType boundaryType, int* startOffset, int* endOffset)
+{
+    return textAtOffsetFromString(offset, boundaryType, startOffset, endOffset, text());
+}
+
+QString QAccessibleDeclarativeTextObject::textBeforeOffset(int offset, QAccessible2::BoundaryType boundaryType, int* startOffset, int* endOffset)
+{
+    return textBeforeOffsetFromString(offset, boundaryType, startOffset, endOffset, text());
+}
+
+int QAccessibleDeclarativeTextObject::offsetAtPoint(const QPoint& point, QAccessible2::CoordinateType coordType)
+{
+    // TODO
+    return 0;
+}
+QString QAccessibleDeclarativeTextObject::attributes(int offset, int* startOffset, int* endOffset)
+{
+    // TODO
+    return QString();
+}
+QRect QAccessibleDeclarativeTextObject::characterRect(int offset, QAccessible2::CoordinateType coordType)
+{
+    // TODO
+    return QRect();
+}
+
+
+int QAccessibleDeclarativeTextObject::cursorPosition()
+{
+    return 0;
+}
+void QAccessibleDeclarativeTextObject::setCursorPosition(int position)
+{
+
+}
+void QAccessibleDeclarativeTextObject::scrollToSubstring(int startIndex, int endIndex)
+{
+
+}
+
+int QAccessibleDeclarativeTextObject::selectionCount()
+{
+    return 0;
+}
+void QAccessibleDeclarativeTextObject::selection(int selectionIndex, int* startOffset, int* endOffset)
+{
+
+}
+void QAccessibleDeclarativeTextObject::setSelection(int selectionIndex, int startOffset, int endOffset)
+{
+
+}
+void QAccessibleDeclarativeTextObject::addSelection(int startOffset, int endOffset)
+{
+
+}
+void QAccessibleDeclarativeTextObject::removeSelection(int selectionIndex)
+{
+
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_ACCESSIBILITY
--- /dev/null
+++ b/src/plugins/accessible/widgets/qaccessibledeclarativeobject.h
@@ -0,0 +1,172 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QACCESSIBLEDECLARATIVEITEM_H
+#define QACCESSIBLEDECLARATIVEITEM_H
+
+#include "complexwidgets.h"
+#include "qaccessibledeclarativeimplementation.h"
+#include <QtDeclarative/qdeclarativeview.h>
+#include <QtDeclarative/qdeclarativeitem.h>
+#include <QtDeclarative/qdeclarativeproperty.h>
+#include <private/qdeclarativeaccessible_p.h>
+
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_ACCESSIBILITY
+
+/*
+    -- Declarative Accessibility Overview. --
+
+    QML accessibility is implemented using two class hierarchies and two "view" interface classes.
+
+    * The interface hierarchy.
+    This hierarchy implements QAccessibleInterfaces for the various QML interfaces.
+    The root of the hierarchy is QAccessibleDeclarativeObject - subclass as necessary
+    to implement QML items.
+
+    * The implementation hierarchy.
+    This hierarchy abstracts the implementation differences between Qt Quick1 and Qt Quick2.
+    The base class is QAccessibleDeclarativeImplementation, with two subclasses:
+    QAccessibleGraphicsViewImplementation
+    QAccessibleSceneGraphImplementation
+
+    The two hierarchies are connected: each QAccessibleDeclarativeObject owns a
+    QAccessibleDeclarativeImplementation. (This is the Bridge pattern, for the
+    design pattern inclined.)
+
+    * View interface classes.
+
+    These are the root of the QML accessible tree and connects it to the widget hierarchy.
+
+    QAccessbileDeclarativeView is the root for the QGraphicsView implementation
+    QAccessbileSceneGraphView is the root for the SceneGraph implementation
+
+
+*/
+class QAccessibleDeclarativeObject: public QAccessibleObjectEx
+{
+    Q_ACCESSIBLE_OBJECT
+public:
+    // Use this factory method to instantiate objects. This will create an accessible object of the
+    // correct type depending the accessibleRole attribute. Implementation should be one of
+    // graphicsview or scenegraph.
+    static QAccessibleDeclarativeObject *instantiateObject(QObject *item, QAccessibleDeclarativeImplementation *implementation);
+
+    ~QAccessibleDeclarativeObject();
+
+    QRect rect(int child) const;
+    int childCount() const;
+    int navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const;
+    int indexOfChild(const QAccessibleInterface*) const;
+    QFlags<QAccessible::RelationFlag> relationTo(int, const QAccessibleInterface*, int) const;
+    int childAt(int, int) const;
+    QString text(QAccessible::Text, int) const;
+    QAccessible::Role role(int) const;
+    QFlags<QAccessible::StateFlag> state(int) const;
+    bool doAction(int action, int child, const QVariantList &params);
+    QVariant invokeMethodEx(QAccessible::Method, int, const QVariantList&);
+protected:
+    // For sublcasses, use instantiateObject factory methotd outside the class.
+    QAccessibleDeclarativeObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role);
+
+private:
+    bool hasChildren() const;
+
+private:
+    QAccessibleDeclarativeImplementation *m_implementation;
+    QAccessible::Role m_role;
+};
+
+class QAccessibleDeclarativeTextObject
+        : public QAccessibleDeclarativeObject, public QAccessibleTextInterface
+{
+    Q_ACCESSIBLE_OBJECT
+public:
+    virtual void addSelection(int startOffset, int endOffset);
+    virtual QString attributes(int offset, int *startOffset, int *endOffset);
+    virtual int cursorPosition();
+    virtual QRect characterRect(int offset, QAccessible2::CoordinateType coordType);
+    virtual int selectionCount();
+    virtual int offsetAtPoint(const QPoint &point, QAccessible2::CoordinateType coordType);
+    virtual void selection(int selectionIndex, int *startOffset, int *endOffset);
+    virtual QString text(int startOffset, int endOffset);
+    virtual QString textBeforeOffset (int offset, QAccessible2::BoundaryType boundaryType,
+                              int *startOffset, int *endOffset);
+    virtual QString textAfterOffset(int offset, QAccessible2::BoundaryType boundaryType,
+                            int *startOffset, int *endOffset);
+    virtual QString textAtOffset(int offset, QAccessible2::BoundaryType boundaryType,
+                         int *startOffset, int *endOffset);
+    virtual void removeSelection(int selectionIndex);
+    virtual void setCursorPosition(int position);
+    virtual void setSelection(int selectionIndex, int startOffset, int endOffset);
+    virtual int characterCount();
+    virtual void scrollToSubstring(int startIndex, int endIndex);
+
+    // add invoke extension
+    QFlags<QAccessible::StateFlag> state(int) const;
+
+    virtual void setText(Text t, int child, const QString &text);
+
+protected:
+    QAccessibleDeclarativeTextObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role);
+    QString text() const;
+friend class QAccessibleDeclarativeObject;
+};
+
+class QAccessibleDeclarativeEditableTextObject
+        : public QAccessibleDeclarativeTextObject, public QAccessibleSimpleEditableTextInterface
+{
+
+protected:
+    QAccessibleDeclarativeEditableTextObject(QObject *object, QAccessibleDeclarativeImplementation *implementation, QAccessible::Role role)
+        : QAccessibleDeclarativeTextObject(object, implementation, role), QAccessibleSimpleEditableTextInterface(this)
+    {}
+
+friend class QAccessibleDeclarativeObject;
+};
+
+#endif // QT_NO_ACCESSIBILITY
+
+QT_END_NAMESPACE
+
+#endif // QACCESSIBLEDECLARATIVEITEM_H
--- /dev/null
+++ b/src/plugins/accessible/widgets/qaccessibledeclarativeview.cpp
@@ -0,0 +1,104 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qaccessibledeclarativeview.h"
+#include "qaccessibledeclarativeobject.h"
+#include "qaccessiblegraphicsviewimplementation.h"
+
+#ifndef QT_NO_ACCESSIBILITY
+
+QT_BEGIN_NAMESPACE
+
+QAccessibleDeclarativeView::QAccessibleDeclarativeView(QWidget *widget)
+    :QAccessibleAbstractScrollArea(widget)
+{
+    m_view = static_cast<QDeclarativeView *>(widget);
+}
+
+int QAccessibleDeclarativeView::childCount() const
+{
+    return 1;
+}
+
+int QAccessibleDeclarativeView::navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const
+{
+    //qDebug() << "navigate" << rel << entry << "root" << (void*)m_view->accessibleRootItem();
+    QDeclarativeItem *declarativeRoot = m_view->accessibleRootItem();
+
+    if (rel == QAccessible::Child) {
+        if (entry != 1 || !declarativeRoot) {
+            *target = 0;
+            return -1;
+        }
+        *target = QAccessibleGraphicsViewImplementation::instantiateObject(declarativeRoot, m_view);
+        return 0;
+    }
+
+    return QAccessibleAbstractScrollArea::navigate(rel, entry, target);
+}
+
+QString QAccessibleDeclarativeView::text(QAccessible::Text textType, int child) const
+{
+    if (textType == QAccessible::DebugDescription) {
+        return QLatin1String("QDeclarativeView");
+    }
+    return QAccessibleAbstractScrollArea::text(textType, child);
+}
+
+int QAccessibleDeclarativeView::childAt(int x, int y) const
+{
+    return 1; // return the top-level QML item
+}
+
+int QAccessibleDeclarativeView::indexOfChild(const QAccessibleInterface *iface) const
+{
+    if (iface) {
+        QDeclarativeItem *declarativeRoot = m_view->accessibleRootItem();
+        if (declarativeRoot == iface->object())
+            return 1;
+    }
+    return -1;
+
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_ACCESSIBILITY
--- /dev/null
+++ b/src/plugins/accessible/widgets/qaccessibledeclarativeview.h
@@ -0,0 +1,73 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QACCESSIBLEDECLARATIVEVIEW_H
+#define QACCESSIBLEDECLARATIVEVIEW_H
+
+#include "complexwidgets.h"
+#include <QtDeclarative/qdeclarativeview.h>
+#include <QtDeclarative/qdeclarativeitem.h>
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_ACCESSIBILITY
+
+class QAccessibleDeclarativeView: public QAccessibleAbstractScrollArea
+{
+    Q_ACCESSIBLE_OBJECT
+public:
+    explicit QAccessibleDeclarativeView(QWidget *widget);
+
+    int childCount() const;
+    int navigate(RelationFlag rel, int entry, QAccessibleInterface **target) const;
+    QString text(QAccessible::Text, int) const;
+    int childAt(int x, int y) const;
+    int indexOfChild(const QAccessibleInterface *iface) const;
+
+private:
+    QDeclarativeView *m_view;
+};
+
+#endif // QT_NO_ACCESSIBILITY
+
+QT_END_NAMESPACE
+
+#endif // QACCESSIBLEDECLARATIVEVIEW_H
--- /dev/null
+++ b/src/plugins/accessible/widgets/qaccessiblegraphicsviewimplementation.cpp
@@ -0,0 +1,168 @@
+#include "qaccessiblegraphicsviewimplementation.h"
+#include "qaccessibledeclarativeobject.h"
+
+QAccessibleGraphicsViewImplementation::QAccessibleGraphicsViewImplementation(QGraphicsItem *item, QGraphicsView *view)
+    :QAccessibleDeclarativeImplementation()
+    ,m_item(item)
+    ,m_view(view)
+{
+
+}
+
+
+QAccessibleDeclarativeObject *QAccessibleGraphicsViewImplementation::instantiateObject(QGraphicsObject *item, QGraphicsView *view)
+{
+    QAccessibleGraphicsViewImplementation * impl = new QAccessibleGraphicsViewImplementation(item, view);
+    return QAccessibleDeclarativeObject::instantiateObject(item, impl);
+}
+
+
+int QAccessibleGraphicsViewImplementation::childCount() const
+{
+    QList<QGraphicsItem *> children = m_item->childItems();
+    return children.count();
+}
+
+QRect QAccessibleGraphicsViewImplementation::itemRect() const
+{
+    QRectF sceneRect = m_item->sceneTransform().mapRect(m_item->boundingRect());
+    QPoint pos = m_view->mapFromScene(m_view->mapToGlobal(sceneRect.topLeft().toPoint()));
+    QSize size = sceneRect.size().toSize();
+    return QRect(pos, size);
+}
+
+QRect QAccessibleGraphicsViewImplementation::viewRect() const
+{
+    QPoint screenPos = m_view->mapToGlobal(m_view->pos());
+    return QRect(screenPos, m_view->size());
+}
+
+bool QAccessibleGraphicsViewImplementation::clipsChildren() const
+{
+    return static_cast<QDeclarativeItem *>(m_item)->clip();
+}
+
+static inline bool isAncestor(const QObject *ancestorCandidate, const QObject *child)
+{
+    while (child) {
+        if (child == ancestorCandidate)
+            return true;
+        child = child->parent();
+    }
+    return false;
+}
+
+int QAccessibleGraphicsViewImplementation::navigate(QAccessible::RelationFlag rel, int entry, QAccessibleInterface **target) const
+{
+    //qDebug() << "QAccessibleDeclarativeItem navigate" << rel << entry;
+    Q_ASSERT(entry >= 0);
+
+    *target = 0;
+    if (entry == 0) {
+        *target = instantiateObject(m_item->toGraphicsObject(), m_view);
+        return 0;
+    }
+
+    switch (rel) {
+    case QAccessible::Child: {
+        QList<QGraphicsItem *> children = m_item->childItems();
+        const int childIndex = entry - 1;
+
+        if (childIndex >= children.count())
+            return -1;
+
+        QGraphicsItem *child = children.at(childIndex);
+        QGraphicsObject *childObject = qobject_cast<QGraphicsObject *>(child);
+        if (!childObject)
+            return -1;
+
+        *target = instantiateObject(childObject, m_view);
+        return 0;
+        break;}
+    case QAccessible::Ancestor: {
+        Q_ASSERT(entry >= 1);
+        QGraphicsItem *parent = m_item->parentItem();
+        QGraphicsObject *parentObj = parent ? parent->toGraphicsObject() : 0;
+        if (parent && !parentObj)
+            qWarning("Can not make QGraphicsItems accessible");
+        QAccessibleInterface *ancestor = (parentObj
+                 ? instantiateObject(parentObj, m_view)
+                 : QAccessible::queryAccessibleInterface(m_view));
+        if (entry == 1) {
+            *target = ancestor;
+            return 0;
+        } else if (entry > 1) {
+            int ret = ancestor->navigate(QAccessible::Ancestor, entry - 1, target);
+            delete ancestor;
+            return ret;
+        }
+        break;}
+    case QAccessible::Sibling: {
+        QAccessibleInterface *iface = 0;
+        if (navigate(QAccessible::Ancestor, 1, &iface) == 0) {
+            if (iface) {
+                int ret = iface->navigate(QAccessible::Child, entry, target);
+                delete iface;
+                return ret;
+            }
+        }
+        return -1;
+        break;}
+    case QAccessible::FocusChild: {
+        QGraphicsObject *focusObject = 0;
+        if (m_item->hasFocus()) {
+            focusObject = m_item->toGraphicsObject();
+        } else {
+            if (QGraphicsItem *focusItem = m_view->scene()->focusItem()) {
+                if (m_item->isAncestorOf(focusItem)) {
+                    focusObject = focusItem->toGraphicsObject();
+                }
+            }
+        }
+        //qDebug() << "QAccessibleDeclarativeItem navigate QAccessible::FocusChild" << rel << entry;
+        if (focusObject) {
+            *target = instantiateObject(focusObject, m_view);
+            return 0;
+        }
+    }
+    default: break;
+    }
+
+    return -1;
+
+}
+
+int QAccessibleGraphicsViewImplementation::indexOfChild(const QAccessibleInterface *iface) const
+{
+    // ### No QAccessibleInterfaces are created with a QGraphicsItem.
+    // However, we want to support QML, not QGraphicsView in general.
+    // And since the UI is written in QML, this means we can assume that *all*
+    // QGraphicsItems are actually QGraphicsObjects
+
+    const QGraphicsObject *childObj = static_cast<QGraphicsObject*>(iface->object());
+    if (m_item == childObj)
+        return 0;
+
+    QList<QGraphicsItem*> kids = m_item->childItems();
+    int index = kids.indexOf(const_cast<QGraphicsItem*>(static_cast<const QGraphicsItem*>(childObj)));
+    if (index != -1) {
+        ++index;
+    }
+    return index;
+}
+
+QFlags<QAccessible::StateFlag> QAccessibleGraphicsViewImplementation::state() const
+{
+    QAccessible::State state = QAccessible::Normal;
+
+    if (m_item->hasFocus()) {
+        state |= QAccessible::Focused;
+    }
+    return state;
+}
+
+bool QAccessibleGraphicsViewImplementation::isAccessible() const
+{
+    return true;
+}
+
--- /dev/null
+++ b/src/plugins/accessible/widgets/qaccessiblegraphicsviewimplementation.h
@@ -0,0 +1,30 @@
+#ifndef QACCESSIBLEGRAPHICSVIEWIMPLEMENTATION_H
+#define QACCESSIBLEGRAPHICSVIEWIMPLEMENTATION_H
+
+#include "qaccessibledeclarativeimplementation.h"
+#include <QGraphicsView>
+#include <QGraphicsItem>
+
+class QAccessibleGraphicsViewImplementation : public QAccessibleDeclarativeImplementation
+{
+public:
+    QAccessibleGraphicsViewImplementation(QGraphicsItem *item, QGraphicsView *view);
+    static QAccessibleDeclarativeObject *instantiateObject(QGraphicsObject *item, QGraphicsView *view);
+
+    QRect itemRect() const;
+    QRect viewRect() const;
+
+    bool clipsChildren() const;
+
+    int childCount() const;
+    int navigate(QAccessible::RelationFlag rel, int entry, QAccessibleInterface **target) const;
+    int indexOfChild(const QAccessibleInterface *iface) const;
+
+    QFlags<QAccessible::StateFlag> state() const;
+    virtual bool isAccessible() const;
+private:
+   QGraphicsItem *m_item;
+   QGraphicsView *m_view;
+};
+
+#endif // QACCESSIBLEGRAPHICSVIEWIMPLEMENTATION_H
--- a/src/plugins/accessible/widgets/widgets.pro
+++ b/src/plugins/accessible/widgets/widgets.pro
@@ -5,6 +5,8 @@
 QTDIR_build:DESTDIR  = $$QT_BUILD_TREE/plugins/accessible
 
 QTDIR_build:REQUIRES += "contains(QT_CONFIG, accessibility)"
+QT += declarative
+win32:!wince*: DEFINES += QT_NO_EGL
 
 SOURCES  += main.cpp \
             simplewidgets.cpp \
@@ -12,13 +14,20 @@
             complexwidgets.cpp \
             qaccessiblewidgets.cpp \
             qaccessiblemenu.cpp \
-            itemviews.cpp
+            itemviews.cpp \
+            qaccessibledeclarativeview.cpp \
+            qaccessiblegraphicsviewimplementation.cpp \
+            qaccessibledeclarativeimplementation.cpp \
+            qaccessibledeclarativeobject.cpp
 
 HEADERS  += qaccessiblewidgets.h \
             simplewidgets.h \
             rangecontrols.h \
             complexwidgets.h \
             qaccessiblemenu.h \
-            itemviews.h
-
-
+            qaccessibledeclarativeview.h \
+            qaccessibledeclarativeroles.h \
+            itemviews.h \
+            qaccessiblegraphicsviewimplementation.h \
+            qaccessibledeclarativeimplementation.h \
+            qaccessibledeclarativeobject.h
--- /dev/null
+++ b/tools/accessibilityinspector/accessibilityinspector.cpp
@@ -0,0 +1,149 @@
+#include "accessibilityinspector.h"
+
+#include "screenreader.h"
+#include "optionswidget.h"
+#include "accessibilityscenemanager.h"
+#ifdef QT_ACCESSIBILITY_INSPECTOR_SCENE_GRAPH
+#include <qsgview.h>
+#include <qsgitem.h>
+#endif
+
+#include <qdeclarativeitem.h>
+
+void MouseInterceptingGraphicsScene::mousePressEvent(QGraphicsSceneMouseEvent *event)
+{
+    emit mousePressed(event->scenePos().toPoint());
+    QGraphicsScene::mousePressEvent(event);
+}
+
+void MouseInterceptingGraphicsScene::mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event)
+{
+    emit mouseDobleClicked();
+    QGraphicsScene::mouseDoubleClickEvent(event);
+}
+
+AccessibilitySceneManager *sceneManager = 0;
+QAccessible::UpdateHandler previousUpdateHandler = 0;
+bool updateHandlerRecursion = false;
+void accessibilityUpdateHandler(QObject *object, int who, QAccessible::Event reason)
+{
+    if (updateHandlerRecursion)
+        return;
+
+    if (
+#ifdef QT_ACCESSIBILITY_INSPECTOR_SCENE_GRAPH
+            !qobject_cast<QSGItem *>(object) &&
+#endif
+            !qobject_cast<QDeclarativeItem *>(object))
+        return;
+
+    updateHandlerRecursion = true;
+
+    if (sceneManager) {
+        sceneManager->handleUpdate(object, reason);
+
+        //qDebug() << "update";
+    }
+
+    if (previousUpdateHandler) // call prev just to be sure.
+        previousUpdateHandler(object, who, reason);
+
+    updateHandlerRecursion = false;
+}
+
+AccessibilityInspector::AccessibilityInspector(QObject *parent) :
+    QObject(parent)
+{
+}
+
+AccessibilityInspector::~AccessibilityInspector()
+{
+    delete optionsWidget;
+    delete accessibilityScene;
+    delete accessibilityView;
+    delete accessibilityTreeScene;
+    delete accessibilityTreeView;
+    delete screenReader;
+}
+
+void AccessibilityInspector::inspectWindow(QWidget *window)
+{
+    optionsWidget = new OptionsWidget();
+
+    accessibilityScene = new MouseInterceptingGraphicsScene();
+
+    accessibilityView = new QGraphicsView();
+    accessibilityView->setScene(accessibilityScene);
+    accessibilityView->resize(1024, 768);
+    accessibilityView->scale(1.3, 1.3);
+
+    accessibilityTreeScene = new QGraphicsScene();
+
+    accessibilityTreeView = new QGraphicsView();
+    accessibilityTreeView->setScene(accessibilityTreeScene);
+    accessibilityTreeView->resize(1024, 768);
+
+    sceneManager = new AccessibilitySceneManager();
+    QObject::connect(optionsWidget, SIGNAL(optionsChanged()), sceneManager, SLOT(updateAccessibilitySceneItemFlags()));
+    QObject::connect(optionsWidget, SIGNAL(refreshClicked()), sceneManager, SLOT(populateAccessibilityScene()));
+    QObject::connect(optionsWidget, SIGNAL(refreshClicked()), sceneManager, SLOT(populateAccessibilityTreeScene()));
+    QObject::connect(optionsWidget, SIGNAL(scaleChanged(int)), sceneManager, SLOT(changeScale(int)));
+
+    sceneManager->setOptionsWidget(optionsWidget);
+    sceneManager->setRootWidget(window);
+    sceneManager->setScene(accessibilityScene);
+    sceneManager->setView(accessibilityView);
+    sceneManager->setTreeScene(accessibilityTreeScene);
+    sceneManager->setTreeView(accessibilityTreeView);
+
+    screenReader = new ScreenReader;
+    QObject::connect(accessibilityScene, SIGNAL(mousePressed(QPoint)), screenReader, SLOT(touchPoint(QPoint)));
+    QObject::connect(accessibilityScene, SIGNAL(mouseDobleClicked()), screenReader, SLOT(activate()));
+    QObject::connect(screenReader, SIGNAL(selected(QObject*)), sceneManager, SLOT(setSelected(QObject*)));
+    screenReader->setRootObject(window);
+    screenReader->setOptionsWidget(optionsWidget);
+
+    previousUpdateHandler = QAccessible::installUpdateHandler(accessibilityUpdateHandler);
+
+    QTimer::singleShot(100, sceneManager, SLOT(populateAccessibilityScene()));
+    QTimer::singleShot(100, sceneManager, SLOT(populateAccessibilityTreeScene()));
+
+    QSettings settings;
+    accessibilityView->restoreGeometry(settings.value("accessiblityGeometry").toByteArray());
+    accessibilityView->show();
+    accessibilityTreeView->restoreGeometry(settings.value("treeGeometry").toByteArray());
+    accessibilityTreeView->show();
+    optionsWidget->restoreGeometry(settings.value("optionsGeometry").toByteArray());
+    optionsWidget->show();
+}
+
+void AccessibilityInspector::saveWindowGeometry()
+{
+    QSettings settings;
+    settings.setValue("accessiblityGeometry", accessibilityView->saveGeometry());
+    settings.setValue("treeGeometry", accessibilityTreeView->saveGeometry());
+    settings.setValue("optionsGeometry", optionsWidget->saveGeometry());
+}
+
+QString translateRole(QAccessible::Role role)
+{
+    if (role == 0x2B)
+        return "PushButton";
+    if (role == 0x2C)
+        return "CheckBox";
+    if (role == 0x2D)
+        return "RadioButton";
+    if (role == 0xA)
+        return "Client";
+    if (role == 0x29)
+        return "Static Text";
+    if (role == 0x33)
+        return "Slider";
+    if (role == 0x33)
+        return "Slider";
+    if (role == 0x10)
+        return "Pane";
+
+    return QString::number(role, 16);
+}
+
--- /dev/null
+++ b/tools/accessibilityinspector/accessibilityinspector.h
@@ -0,0 +1,48 @@
+#ifndef ACCESSIBILITYINSPECTOR_H
+#define ACCESSIBILITYINSPECTOR_H
+
+#include <QObject>
+#include <qgraphicsscene.h>
+#include <QAccessible>
+
+QString translateRole(QAccessible::Role role);
+
+class OptionsWidget;
+class MouseInterceptingGraphicsScene;
+class QGraphicsView;
+class QGraphicsScene;
+class AccessibilitySceneManager;
+class ScreenReader;
+class AccessibilityInspector : public QObject
+{
+    Q_OBJECT
+public:
+    explicit AccessibilityInspector(QObject *parent = 0);
+    ~AccessibilityInspector();
+    void inspectWindow(QWidget *window);
+    void saveWindowGeometry();
+signals:
+
+public slots:
+
+private:
+    OptionsWidget *optionsWidget;
+    MouseInterceptingGraphicsScene *accessibilityScene;
+    QGraphicsView *accessibilityView;
+    QGraphicsScene *accessibilityTreeScene;
+    QGraphicsView *accessibilityTreeView;
+    ScreenReader *screenReader;
+};
+
+class MouseInterceptingGraphicsScene : public QGraphicsScene
+{
+Q_OBJECT
+protected:
+    virtual void mousePressEvent(QGraphicsSceneMouseEvent *event);
+    virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);
+signals:
+    void mousePressed(const QPoint point);
+    void mouseDobleClicked();
+};
+
+#endif // ACCESSIBILITYINSPECTOR_H
--- /dev/null
+++ b/tools/accessibilityinspector/accessibilityinspector.pri
@@ -0,0 +1,23 @@
+QT += declarative
+CONFIG += uitools
+INCLUDEPATH += $$PWD
+
+mac {
+    # for text-to-speach
+    LIBS += -framework AppKit
+}
+
+HEADERS += \
+    $$PWD/screenreader.h \
+    $$PWD/optionswidget.h \
+    $$PWD/accessibilityscenemanager.h \
+    $$PWD/accessibilityinspector.h
+SOURCES += \
+    $$PWD/optionswidget.cpp \
+    $$PWD/accessibilityscenemanager.cpp \
+    $$PWD/screenreader.cpp \
+    $$PWD/accessibilityinspector.cpp
+
+OBJECTIVE_SOURCES += $$PWD/screenreader_mac.mm
+
+
--- /dev/null
+++ b/tools/accessibilityinspector/accessibilityinspector.pro
@@ -0,0 +1,11 @@
+include (accessibilityinspector.pri)
+
+SOURCES += main.cpp \
+
+RESOURCES += \
+    testqml.qrc
+
+OTHER_FILES += \
+    phase1.qml
+
+CONFIG += console
--- /dev/null
+++ b/tools/accessibilityinspector/accessibilityscenemanager.cpp
@@ -0,0 +1,459 @@
+#include "accessibilityscenemanager.h"
+
+AccessibilitySceneManager::AccessibilitySceneManager()
+{
+    m_window = 0;
+    m_view = 0;
+    m_scene = 0;
+    m_rootItem = 0;
+    m_optionsWidget = 0;
+    m_selectedObject = 0;
+}
+
+void AccessibilitySceneManager::populateAccessibilityScene()
+{
+    m_scene->clear();
+    m_graphicsItems.clear();
+
+    QAccessibleInterface * rootInterface = QAccessible::queryAccessibleInterface(m_window);
+    if (!rootInterface)
+        return;
+
+    populateAccessibilityScene(rootInterface, 0, m_scene);
+}
+
+void AccessibilitySceneManager::updateAccessibilitySceneItemFlags()
+{
+    qDebug() << "update";
+    foreach (QObject *object, m_graphicsItems.keys()) {
+        if (!object)
+            continue;
+        QAccessibleInterface *interface = QAccessible::queryAccessibleInterface(object);
+        if (!interface)
+            continue;
+        updateItemFlags(m_graphicsItems.value(object), interface);
+        delete interface;
+    }
+}
+
+void AccessibilitySceneManager::populateAccessibilityTreeScene()
+{
+    m_treeScene->clear();
+    QAccessibleInterface * rootInterface = QAccessible::queryAccessibleInterface(m_window);
+    if (!rootInterface)
+        return;
+
+    populateAccessibilityTreeScene(rootInterface, 0);
+}
+
+void AccessibilitySceneManager::handleUpdate(QObject *object, QAccessible::Event reason)
+{
+    QAccessibleInterface *interface = QAccessible::queryAccessibleInterface(object);
+    if (!interface)
+        return;
+
+    QString name = interface->text(QAccessible::Name, 0);
+
+    if (reason == QAccessible::ObjectCreated) {
+  //      qDebug() << "ObjectCreated" << object << name;
+        populateAccessibilityScene(interface, 0, m_scene);
+    }
+
+    QGraphicsRectItem *item = m_graphicsItems.value(object);
+
+    if (!item) {
+//        qDebug() << "populateAccessibilityScene failed for" << object;
+        return;
+    }
+
+    if (reason == QAccessible::LocationChanged) {
+
+        //if (name.startsWith("List"))
+            qDebug() << "locationChange" << object << name << interface->rect(0);
+
+        updateItem(item, interface);
+        for (int i = 0; i < interface->childCount(); ++i) {
+           QAccessibleInterface *child = 0;
+           int ret = interface->navigate(QAccessible::Child, i + 1, &child);
+           if (ret == 0 && child) {
+               updateItem(m_graphicsItems.value(child->object()), child);
+               delete child;
+            }
+        }
+
+        delete interface;
+    } else if (reason == QAccessible::ObjectDestroyed) {
+//        qDebug() << "ObjectDestroyed" << object << name;
+        delete m_graphicsItems.value(object);
+        m_graphicsItems.remove(object);
+        m_animatedObjects.remove(object);
+        if (object == m_selectedObject) {
+            m_selectedObject = 0;
+        }
+    } else if (reason == QAccessible::ObjectHide) {
+//        qDebug() << "ObjectCreated Hide" << object;
+        updateItemFlags(item, interface);
+    } else if (reason == QAccessible::ObjectShow) {
+//        qDebug() << "ObjectCreated Show" << object;
+        updateItemFlags(item, interface);
+    } else if (reason == QAccessible::ScrollingStart) {
+        qDebug() << "ObjectCreated ScrollingStart" << object;
+        QAccessibleInterface *child = 0;
+        for (int i = 0; i < interface->childCount(); ++i) {
+            int ret = interface->navigate(QAccessible::Child, i + 1, &child);
+            if (ret == 0 && child) {
+                m_animatedObjects.insert(child->object());
+                delete child;
+            }
+        }
+    } else if (reason == QAccessible::ScrollingEnd) {
+        // qDebug() << "ObjectCreated ScrollingEnd" << object;
+        foreach (QObject *object, m_animatedObjects) {
+            updateItem(m_graphicsItems.value(object), interface);
+        }
+        delete interface;
+        m_animatedObjects.clear();
+
+    } else {
+        qDebug() << "other update" << object;
+    }
+}
+
+void AccessibilitySceneManager::setSelected(QObject *object)
+{
+    m_scene->update(); // scedule update
+
+    // clear existing selection
+    if (m_selectedObject) {
+        QObject *previousSelectedObject = m_selectedObject;
+        m_selectedObject = 0;
+        updateItem(previousSelectedObject);
+    }
+
+    m_selectedObject = object;
+    updateItem(object);
+
+    populateAccessibilityTreeScene();
+}
+
+void AccessibilitySceneManager::changeScale(int)
+{
+    // No QGraphicsView::setScale :(
+
+    //m_view->scale(scale / 10.0, scale / 10.0);
+    //if (m_rootItem)
+    //    m_view->ensureVisible(m_rootItem);
+}
+
+void AccessibilitySceneManager::updateItems(QObject *root)
+{
+    QAccessibleInterface *interface = QAccessible::queryAccessibleInterface(root);
+    if (!interface)
+        return;
+    updateItem(m_graphicsItems.value(root), interface);
+
+    QAccessibleInterface *child = 0;
+    for (int i = 0; i < interface->childCount(); ++i) {
+        int ret = interface->navigate(QAccessible::Child, i + 1, &child);
+        if (ret == 0 && child) {
+            updateItems(child->object());
+            delete child;
+        }
+    }
+    delete interface;
+}
+
+void AccessibilitySceneManager::updateItem(QObject *object)
+{
+    if (!object)
+        return;
+
+    QAccessibleInterface *interface = QAccessible::queryAccessibleInterface(object);
+    if (!interface)
+        return;
+
+    updateItem(m_graphicsItems.value(object), interface);
+
+    delete interface;
+}
+
+void AccessibilitySceneManager::updateItem(QGraphicsRectItem *item, QAccessibleInterface *interface)
+{
+    if (!item)
+        return;
+
+    QRect rect = interface->rect(0);
+    item->setPos(rect.topLeft());
+    item->setRect(QRect(QPoint(0,0), rect.size()));
+
+    updateItemFlags(item, interface);
+}
+
+void AccessibilitySceneManager::updateItemFlags(QGraphicsRectItem *item, QAccessibleInterface *interface)
+{
+  //  qDebug() << "udpateItemFlags" << interface << interface->object();
+
+    int childCount = interface->childCount();
+
+    bool shouldShow = true;
+
+    if (m_optionsWidget->hideInvisibleItems()) {
+        if (isHidden(interface)) {
+            shouldShow = false;
+        }
+    }
+
+    if (m_optionsWidget->hideOffscreenItems()) {
+        if (interface->state(0) & QAccessible::Offscreen) {
+            shouldShow = false;
+        }
+    }
+
+    if (m_optionsWidget->hidePaneItems()) {
+        if (interface->role(0) & QAccessible::Pane) {
+            shouldShow = false;
+        }
+    }
+
+    item->setVisible(shouldShow);
+
+    if (interface->object() == m_selectedObject)
+        item->setBrush(QColor(Qt::yellow));
+    else
+        item->setBrush(QColor(Qt::white));
+
+    m_view->update();
+}
+
+QGraphicsRectItem * AccessibilitySceneManager::processInterface(QAccessibleInterface * interface, int child, QGraphicsScene *scene)
+{
+    // Process this interface
+
+    QGraphicsRectItem * item = new QGraphicsRectItem();
+    scene->addItem(item);
+    if (!m_rootItem)
+        m_rootItem = item;
+
+    QString name = interface->text(QAccessibleInterface::Name, child);
+    QString description; // = interface->text(QAccessibleInterface::Description, child);
+    QString role = translateRole(interface->role(child));
+    int childCount = interface->childCount();
+
+    /* qDebug() << "name:" << name << "local pos" <<
+               interface->rect(0) << "description" << description << "childCount" << childCount;
+*/
+
+    updateItem(item, interface);
+
+    QGraphicsSimpleTextItem * textItem = new QGraphicsSimpleTextItem();
+    textItem->setParentItem(item);
+    textItem->setPos(QPoint(5, 5));
+
+    QString text;
+    text.append("Name: " + name + " ");
+    if (!description.isEmpty())
+        text.append("Description: " + description + " ");
+    text.append("Role: " + role + " ");
+    if (childCount > 0)
+        text.append("ChildCount: " + QString::number(childCount) + " ");
+    textItem->setText(text);
+
+    QFont font;
+    font.setPointSize(10);
+ //   font.setPointSize(14);
+    textItem->setFont(font);
+
+    return item;
+}
+
+void AccessibilitySceneManager::populateAccessibilityScene(QAccessibleInterface * interface, int child, QGraphicsScene *scene)
+{
+    if (!interface)
+        return;
+
+    QGraphicsRectItem *item = processInterface(interface, child, scene);
+
+    QObject *object = interface->object();
+    if (object) {
+        m_graphicsItems.insert(object, item);
+    }
+
+    // Possibly process children
+    if (child != 0)
+        return;
+
+    int childCount = interface->childCount();
+    for (int i = 0; i < childCount; ++i) {
+        QAccessibleInterface *childInterface = 0;
+        int targetChild = interface->navigate(QAccessible::Child, i + 1, &childInterface);
+        if (childInterface) {
+            populateAccessibilityScene(childInterface, targetChild, scene);
+            delete childInterface;
+        }
+    }
+}
+
+AccessibilitySceneManager::TreeItem AccessibilitySceneManager::computeLevels(QAccessibleInterface * interface, int level)
+{
+    if (interface == 0)
+        return TreeItem();
+
+    TreeItem currentLevel;
+
+    const int childCount = interface->childCount();
+    int usedChildren = 0;
+    for (int i = 1; i <= childCount; ++i) {
+        //qDebug() << "level" << level << "child" << i;
+        // Get the with of the children;
+        QAccessibleInterface *child = 0;
+        int ret = interface->navigate(QAccessible::Child, i, &child);
+        // recurse to "proper" children.
+        if (child != 0 && ret == 0) {
+            ++usedChildren;
+            TreeItem childLevel = computeLevels(child, level + 1);
+            currentLevel.children.append(childLevel);
+            currentLevel.width += childLevel.width + m_treeItemHorizontalPadding;
+            delete child;
+        }
+    }
+
+    // leaf node case
+    if (usedChildren == 0) {
+        currentLevel.width = m_treeItemWidth + m_treeItemHorizontalPadding;
+    }
+
+    // capture information:
+    currentLevel.name = interface->text(QAccessible::Name, 0);
+    currentLevel.description += interface->text(QAccessible::DebugDescription, 0);
+    currentLevel.role = translateRole(interface->role(0));
+    currentLevel.rect = interface->rect(0);
+    currentLevel.state = interface->state(0);
+    currentLevel.object = interface->object();
+
+    return currentLevel;
+}
+
+void AccessibilitySceneManager::populateAccessibilityTreeScene(QAccessibleInterface * interface, int child)
+{
+    if (!interface)
+        return;
+
+    // set some layout metrics:
+    m_treeItemWidth = 90;
+    m_treeItemHorizontalPadding = 10;
+    m_treeItemHeight = 60;
+    m_treeItemVerticalPadding = 30;
+
+    // We want to draw the accessibility hiearchy as a vertical
+    // tree, growing from the root node at the top.
+
+    // First, figure out the number of levels and the width of each level:
+    m_rootTreeItem = computeLevels(interface, 0);
+
+    // create graphics items for each tree item
+    addGraphicsItems(m_rootTreeItem, 0, 0);
+}
+
+void AccessibilitySceneManager::addGraphicsItems(AccessibilitySceneManager::TreeItem item, int row, int xPos)
+{
+    //qDebug() << "add graphics item" << row << item.name << item.role << xPos << item.width << item.children.count();
+
+    int yPos = row * (m_treeItemHeight + m_treeItemVerticalPadding);
+
+    // Process this interface
+    QGraphicsRectItem * graphicsItem = new QGraphicsRectItem();
+    graphicsItem->setPos(xPos, yPos);
+    graphicsItem->setRect(0, 0, m_treeItemWidth, m_treeItemHeight);
+    graphicsItem->setFlag(QGraphicsItem::ItemClipsChildrenToShape);
+
+    if (item.object == m_selectedObject)
+        graphicsItem->setBrush(QColor(Qt::yellow));
+    else
+        graphicsItem->setBrush(QColor(Qt::white));
+
+    if (item.state & QAccessible::Invisible) {
+        QPen linePen;
+        linePen.setStyle(Qt::DashLine);
+        graphicsItem->setPen(linePen);
+    }
+
+    m_treeScene->addItem(graphicsItem);
+
+    QGraphicsTextItem * textItem = new QGraphicsTextItem();
+    textItem->setParentItem(graphicsItem);
+    textItem->setPos(QPoint(0, 0));
+
+    QFont font;
+    font.setPointSize(8);
+    textItem->setFont(font);
+
+    QString text;
+    text += item.name + "\n";
+    text += item.role + "\n";
+    text += item.description.split(" ", QString::SkipEmptyParts).join("\n") + "\n";
+    text += "P:" + QString::number(item.rect.x()) + " " + QString::number(item.rect.y()) + " ";
+    text += "S:" + QString::number(item.rect.width()) + " " + QString::number(item.rect.height()) + "\n";
+
+    textItem->setPlainText(text);
+
+    // recurse to children
+    int childIndex = 0;
+    int childCount = item.children.count();
+    int segmentSize = item.width / qMax(1, childCount);
+    int segmentCenterOffset = segmentSize / 2;
+    int segmentsStart = xPos - (item.width / 2);
+    foreach (TreeItem child, item.children) {
+        // spread the children out, covering the width, centered on xPos
+        int segmentPosition = segmentsStart + (segmentSize * childIndex) + segmentCenterOffset;
+        addGraphicsItems(child, row + 1, segmentPosition);
+        ++childIndex;
+    }
+
+    // add lines from parents to kids
+    int boxBottom = yPos + m_treeItemHeight;
+    int boxMiddleX = xPos + m_treeItemWidth / 2;
+    int yBottomMiddle = boxBottom + m_treeItemVerticalPadding / 2;
+    int boxTop = yPos;
+    int yTopMiddle = boxTop - m_treeItemVerticalPadding / 2;
+
+    if (row > 0) {
+        QGraphicsLineItem *childVerticalStem = new QGraphicsLineItem();
+        childVerticalStem->setLine(boxMiddleX, yTopMiddle, boxMiddleX, boxTop);
+        m_treeScene->addItem(childVerticalStem);
+    }
+
+    if (childCount > 0) {
+        QGraphicsLineItem *parentVerticalStem = new QGraphicsLineItem();
+        parentVerticalStem->setLine(boxMiddleX, boxBottom, boxMiddleX, yBottomMiddle);
+        m_treeScene->addItem(parentVerticalStem);
+    }
+
+    if (childCount > 1) {
+        QGraphicsLineItem *horizontalStem = new QGraphicsLineItem();
+        // match the end points with the horizontal lines
+        int lineStartX = segmentsStart + segmentCenterOffset + m_treeItemWidth / 2;
+        int lineStopX = segmentsStart + segmentSize * (childCount -1) + segmentCenterOffset + m_treeItemWidth / 2;
+        horizontalStem->setLine(lineStartX, yBottomMiddle, lineStopX , yBottomMiddle);
+        m_treeScene->addItem(horizontalStem);
+    }
+}
+
+bool AccessibilitySceneManager::isHidden(QAccessibleInterface *interface)
+{
+    QAccessibleInterface *current = interface;
+    while (current) {
+
+        if (current->state(0) & QAccessible::Invisible) {
+            return true;
+        }
+
+        QAccessibleInterface *parent = 0;
+        current->navigate(QAccessible::Ancestor, 0, &parent);
+
+        if (current != interface)
+            delete current;
+        current = parent;
+    }
+
+    return false;
+}
--- /dev/null
+++ b/tools/accessibilityinspector/accessibilityscenemanager.h
@@ -0,0 +1,76 @@
+#ifndef ACCESSIBILITYSCENEMANAGER_H
+#define ACCESSIBILITYSCENEMANAGER_H
+
+#include <QtGui>
+
+#include "optionswidget.h"
+
+QString translateRole(QAccessible::Role role);
+class AccessibilitySceneManager : public QObject
+{
+Q_OBJECT
+public:
+    AccessibilitySceneManager();
+    void setRootWidget(QWidget * widget) { m_window = widget; }
+    void setView(QGraphicsView *view) { m_view = view; }
+    void setScene(QGraphicsScene *scene) { m_scene = scene; }
+    void setTreeView(QGraphicsView *treeView) { m_treeView = treeView; }
+    void setTreeScene(QGraphicsScene *treeScene) { m_treeScene = treeScene; }
+
+    void setOptionsWidget(OptionsWidget *optionsWidget) { m_optionsWidget = optionsWidget; }
+public slots:
+    void populateAccessibilityScene();
+    void updateAccessibilitySceneItemFlags();
+    void populateAccessibilityTreeScene();
+    void handleUpdate(QObject *object, QAccessible::Event reason);
+    void setSelected(QObject *object);
+
+    void changeScale(int scale);
+private:
+    void updateItems(QObject *root);
+    void updateItem(QObject *object);
+    void updateItem(QGraphicsRectItem *item, QAccessibleInterface *interface);
+    void updateItemFlags(QGraphicsRectItem *item, QAccessibleInterface *interface);
+
+    void populateAccessibilityScene(QAccessibleInterface * interface, int child, QGraphicsScene *scene);
+    QGraphicsRectItem * processInterface(QAccessibleInterface * interface, int child, QGraphicsScene *scene);
+
+    struct TreeItem;
+    TreeItem computeLevels(QAccessibleInterface * interface, int level);
+    void populateAccessibilityTreeScene(QAccessibleInterface * interface, int child);
+    void addGraphicsItems(TreeItem item, int row, int xPos);
+
+    bool isHidden(QAccessibleInterface *interface);
+
+    QWidget *m_window;
+    QGraphicsView *m_view;
+    QGraphicsScene *m_scene;
+    QGraphicsView *m_treeView;
+    QGraphicsScene *m_treeScene;
+    QGraphicsItem *m_rootItem;
+    OptionsWidget *m_optionsWidget;
+    QObject *m_selectedObject;
+
+    QHash<QObject *, QGraphicsRectItem*> m_graphicsItems;
+    QSet<QObject *> m_animatedObjects;
+
+    struct TreeItem {
+        QList<TreeItem> children;
+        int width;
+        QString name;
+        QString role;
+        QString description;
+        QRect rect;
+        QAccessible::State state;
+        QObject *object;
+        TreeItem() : width(0) {}
+    };
+
+    TreeItem m_rootTreeItem;
+    int m_treeItemWidth;
+    int m_treeItemHorizontalPadding;
+    int m_treeItemHeight;
+    int m_treeItemVerticalPadding;
+};
+
+#endif // ACCESSIBILITYSCENEMANAGER_H
--- /dev/null
+++ b/tools/accessibilityinspector/main.cpp
@@ -0,0 +1,78 @@
+#include <QtGui>
+#include <QtDeclarative/QtDeclarative>
+#include <QtUiTools/QtUiTools>
+
+#include "accessibilityinspector.h"
+
+int main(int argc, char **argv)
+{
+    QApplication app(argc, argv);
+
+    if (app.arguments().count() < 2) {
+        qDebug() << "Usage: accessebilityInspector [ ui-file | qml-file ] [Option]";
+        qDebug() << "Option:";
+#ifdef QT_ACCESSIBILITY_INSPECTOR_SCENE_GRAPH
+        qDebug() << "-qtquick1: Use QDeclarativeView instead of QSGView for rendering QML files";
+#endif
+        return 0;
+    }
+
+    QString fileName = app.arguments().at(1);
+    QString mode;
+    if (app.arguments().count() > 2) {
+        mode = app.arguments().at(2);
+    }
+
+    QWidget *window;
+
+    if (fileName.endsWith(".ui")) {
+        QUiLoader loader;
+        QFile file(fileName);
+        file.open(QFile::ReadOnly);
+        window = loader.load(&file, 0);
+    } else if (fileName.endsWith(".qml")){
+        QUrl fileUrl;
+        if (fileName.startsWith(":")) { // detect resources.
+            QString name = fileName;
+            name.remove(0, 2); // reomve ":/"
+            fileUrl.setUrl(QLatin1String("qrc:/") + name);
+        } else {
+            fileUrl = QUrl::fromLocalFile(fileName);
+        }
+
+#ifdef QT_ACCESSIBILITY_INSPECTOR_SCENE_GRAPH
+        if (mode == QLatin1String("-qtquick1"))
+#endif
+        {
+            QDeclarativeView * declarativeView = new QDeclarativeView();
+            declarativeView->setSource(fileUrl);
+            window = declarativeView;
+        }
+#ifdef QT_ACCESSIBILITY_INSPECTOR_SCENE_GRAPH
+        else {
+            QSGView * sceneGraphView = new QSGView();
+            sceneGraphView->setSource(fileUrl);
+            window = sceneGraphView;
+        }
+#endif
+    } else {
+        qDebug() << "Error: don't know what to do with" << fileName;
+    }
+
+    AccessibilityInspector *accessibilityInspector = new AccessibilityInspector();
+
+    accessibilityInspector->inspectWindow(window);
+
+    window->move(50, 50);
+    window->show();
+
+    int ret = app.exec();
+
+    accessibilityInspector->saveWindowGeometry();
+    delete accessibilityInspector;
+
+    return ret;
+
+
+}
+
--- /dev/null
+++ b/tools/accessibilityinspector/optionswidget.cpp
@@ -0,0 +1,2 @@
+#include "optionswidget.h"
+
--- /dev/null
+++ b/tools/accessibilityinspector/optionswidget.h
@@ -0,0 +1,75 @@
+#ifndef OPTIONSWIDGET_H
+#define OPTIONSWIDGET_H
+
+#include <QtGui>
+
+class OptionsWidget : public QWidget
+{
+Q_OBJECT
+public:
+    OptionsWidget()
+        :QWidget()
+    {
+        QVBoxLayout *m_layout = new QVBoxLayout;
+
+        m_refresh = new QPushButton(this);
+        m_refresh->setText(QLatin1String("Refresh"));
+        m_layout->addWidget(m_refresh);
+        connect(m_refresh, SIGNAL(clicked()), SIGNAL(refreshClicked()));
+
+        m_hideInvisibleItems = new QCheckBox(this);
+        m_layout->addWidget(m_hideInvisibleItems);
+        m_hideInvisibleItems->setText("Hide Invisible Items");
+        m_hideInvisibleItems->setChecked(true);
+        connect(m_hideInvisibleItems, SIGNAL(toggled(bool)), SIGNAL(optionsChanged()));
+
+        m_hideOffscreenItems = new QCheckBox(this);
+        m_layout->addWidget(m_hideOffscreenItems);
+        m_hideOffscreenItems->setText("Hide Offscreen Items");
+        m_hideOffscreenItems->setChecked(true);
+        connect(m_hideOffscreenItems, SIGNAL(toggled(bool)), SIGNAL(optionsChanged()));
+
+        m_hidePaneItems = new QCheckBox(this);
+        m_layout->addWidget(m_hidePaneItems);
+        m_hidePaneItems->setText("Hide Items with the Pane role");
+        m_hidePaneItems->setChecked(true);
+        connect(m_hidePaneItems, SIGNAL(toggled(bool)), SIGNAL(optionsChanged()));
+
+        m_enableTextToSpeach = new QCheckBox(this);
+        m_layout->addWidget(m_enableTextToSpeach);
+        m_enableTextToSpeach->setText("Enable Text To Speech");
+        m_enableTextToSpeach->setChecked(false);
+        connect(m_enableTextToSpeach, SIGNAL(toggled(bool)), SIGNAL(optionsChanged()));
+
+
+        m_scale = new QSlider(Qt::Horizontal);
+//        m_layout->addWidget(m_scale);
+        m_scale->setRange(5, 30);
+        m_scale->setValue(1);
+        connect(m_scale, SIGNAL(valueChanged(int)), SIGNAL(scaleChanged(int)));
+
+        this->setLayout(m_layout);
+    }
+
+    bool hideInvisibleItems() { return m_hideInvisibleItems->isChecked(); }
+    bool hideOffscreenItems() { return m_hideOffscreenItems->isChecked(); }
+    bool hidePaneItems() { return m_hidePaneItems->isChecked(); }
+    bool enableTextToSpeach() { return m_enableTextToSpeach->isChecked(); }
+signals:
+    void optionsChanged();
+    void refreshClicked();
+    void scaleChanged(int);
+
+private:
+    QVBoxLayout *m_layout;
+
+    QPushButton *m_refresh;
+    QCheckBox *m_hideInvisibleItems;
+    QCheckBox *m_hideOffscreenItems;
+    QCheckBox *m_hidePaneItems;
+    QCheckBox *m_enableTextToSpeach;
+    QSlider *m_scale;
+};
+
+
+#endif // OPTIONSWIDGET_H
--- /dev/null
+++ b/tools/accessibilityinspector/phase1.qml
@@ -0,0 +1,52 @@
+import QtQuick 2.0
+
+Rectangle {
+    id : rect
+    width: 300
+    height: 200
+
+    Rectangle {
+        width : 200
+        height : 20
+
+        id: button
+        anchors.top : rect.top
+        anchors.topMargin: 30
+        property string text : "Click to activate"
+        property int counter : 0
+
+        accessibleRole : Qt.PushButton
+        function accessibleAction(action) {
+            if (action == Qt.Press)
+                buttonAction()
+        }
+
+        function buttonAction() {
+            ++counter
+            text = "clicked " + counter
+
+            text2.x += 20
+        }
+
+        Text {
+            id : text1
+            anchors.fill: parent
+            text : parent.text
+        }
+
+        MouseArea {
+            id : mouseArea
+            anchors.fill: parent
+            onClicked: parent.buttonAction()
+        }
+    }
+
+    Text {
+        id : text2
+        anchors.top: button.bottom
+        anchors.topMargin: 50
+        text : "Hello World " + x
+
+        Behavior on x { PropertyAnimation { duration: 500 } }
+    }
+}
--- /dev/null
+++ b/tools/accessibilityinspector/screenreader.cpp
@@ -0,0 +1,121 @@
+#include "screenreader.h"
+#include "optionswidget.h"
+#include "accessibilityscenemanager.h"
+#include <QtGui>
+
+#ifdef Q_OS_MAC
+#include <private/qt_mac_p.h>
+#endif
+
+ScreenReader::ScreenReader(QObject *parent) :
+    QObject(parent)
+{
+    m_selectedInterface = 0;
+    m_rootInterface = 0;
+    bool activateCalled = false;
+}
+
+ScreenReader::~ScreenReader()
+{
+    delete m_selectedInterface;
+    delete m_rootInterface;
+}
+
+void ScreenReader::setRootObject(QObject *rootObject)
+{
+    m_rootInterface = QAccessible::queryAccessibleInterface(rootObject);
+}
+
+void ScreenReader::setOptionsWidget(OptionsWidget *optionsWidget)
+{
+    m_optionsWidget = optionsWidget;
+}
+
+void ScreenReader::touchPoint(const QPoint &point)
+{
+    qDebug() << "touch" << point;
+    // Wait and see if this touch is the start of a double-tap
+    // (activate will then be called and cancel the touch processing)
+    m_activateCalled = false;
+    m_currentTouchPoint = point;
+    QTimer::singleShot(200, this, SLOT(processTouchPoint()));
+}
+
+void ScreenReader::processTouchPoint()
+{
+    if (m_activateCalled) {
+        return;
+    }
+
+    if (m_rootInterface == 0) {
+        return;
+    }
+
+    QAccessibleInterface * currentInterface = m_rootInterface;
+
+    int hit = -2;
+    int guardCounter = 0;
+    const int guardMax = 40;
+    while (hit != 0) {
+        ++guardCounter;
+        if (guardCounter > guardMax) {
+            qDebug() << "touchPoint exit recursion overflow";
+            return; // outside
+        }
+
+        hit = currentInterface->childAt(m_currentTouchPoint.x(), m_currentTouchPoint.y());
+        //qDebug() << "hit" << hit;
+        if (hit == -1) {
+            return; // outside
+        } else if (hit == 0) {
+            break; // found it.
+        } else {
+            QAccessibleInterface *childInterface = 0;
+            int child = currentInterface->navigate(QAccessible::Child, hit, &childInterface);
+            if (childInterface == 0) {
+                return; // navigation error
+            }
+
+            if (currentInterface != m_rootInterface)
+                delete currentInterface;
+            currentInterface = childInterface;
+        }
+    }
+
+    m_selectedInterface = currentInterface;
+    emit selected(m_selectedInterface->object());
+    if (m_optionsWidget->enableTextToSpeach())
+        speak(m_selectedInterface->text(QAccessible::Name, 0)
+              /*+ "," + translateRole(m_selectedInterface->role(0)) */);
+
+//    qDebug() << "touchPoint exit found" << m_selectedInterface->text(QAccessible::Name, 0) << m_selectedInterface->object() << m_selectedInterface->rect(0);
+}
+
+void ScreenReader::activate()
+{
+    qDebug() << "ScreenReader::activate";
+    m_activateCalled = true;
+    if (m_selectedInterface) {
+        m_selectedInterface->doAction(QAccessible::Press, 0);
+    }
+}
+
+#ifdef Q_OS_MAC
+
+    // screenreader.mm
+
+#else
+
+void ScreenReader::speak(const QString &text, const QString &/*voice*/)
+{
+    QFile f("festivalspeachhack");
+    f.open(QIODevice::WriteOnly);
+    f.write(text.toLocal8Bit());
+    f.close();
+
+    QProcess *process = new QProcess;
+    process->start("/usr/bin/festival", QStringList() << "--tts" << "festivalspeachhack");
+}
+
+#endif
+
--- /dev/null
+++ b/tools/accessibilityinspector/screenreader.h
@@ -0,0 +1,42 @@
+#ifndef SCREENREADER_H
+#define SCREENREADER_H
+
+#include <QObject>
+#include <QAccessible>
+#include <QAccessibleBridge>
+
+/*
+    A Simple screen reader for touch-based user interfaces.
+
+    Requires a text-to-speach backend. Currently implemented on
+    Mac OS X and using festival on unix.
+*/
+class OptionsWidget;
+class ScreenReader : public QObject
+{
+    Q_OBJECT
+public:
+    explicit ScreenReader(QObject *parent = 0);
+    ~ScreenReader();
+
+    void setRootObject(QObject *rootObject);
+    void setOptionsWidget(OptionsWidget *optionsWidget);
+public slots:
+    void touchPoint(const QPoint &point);
+    void activate();
+protected slots:
+    void processTouchPoint();
+signals:
+    void selected(QObject *object);
+
+protected:
+    void speak(const QString &text, const QString &voice = QString());
+private:
+    QAccessibleInterface *m_selectedInterface;
+    QAccessibleInterface *m_rootInterface;
+    OptionsWidget *m_optionsWidget;
+    QPoint m_currentTouchPoint;
+    bool m_activateCalled;
+};
+
+#endif // SCREENREADER_H
--- /dev/null
+++ b/tools/accessibilityinspector/screenreader_mac.mm
@@ -0,0 +1,19 @@
+#include "screenreader.h"
+#include <QtCore>
+#include <private/qt_mac_p.h>
+
+void ScreenReader::speak(const QString &text, const QString &voice)
+{
+    QString voiceBase = "com.apple.speech.synthesis.voice.";
+    if (voice.isEmpty())
+        voiceBase += "Vici";
+    else
+        voiceBase += voice;
+
+    CFStringRef cfVoice = QCFString::toCFStringRef(voiceBase);
+    NSSpeechSynthesizer *synth = [[NSSpeechSynthesizer alloc] initWithVoice:(NSString *)cfVoice];
+    CFStringRef cfText = QCFString::toCFStringRef(text);
+    [synth startSpeakingString: (NSString *)cfText];
+    CFRelease(cfText);
+    CFRelease(cfVoice);
+}
--- /dev/null
+++ b/tools/accessibilityinspector/testqml.qrc
@@ -0,0 +1,5 @@
+<RCC>
+    <qresource prefix="/qml">
+        <file>phase1.qml</file>
+    </qresource>
+</RCC>
