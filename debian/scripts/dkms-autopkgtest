#!/bin/sh
# Common autopkgtest script for testing a dkms source package.
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# Copyright: (C) 2014 Canonical Ltd.
set -eu

export DEBIAN_FRONTEND=noninteractive

result=0
summary=
crlf="
"

header_packages=
check_for_linux_headers() {
    # Act only on the first run.
    if [ -n "$header_packages" ]; then
        return
    fi

    # Which Linux header packages are installed?
    header_packages=$(dpkg-query -f '${Status} ${Package}\n' -W 'linux-headers-*' 2>/dev/null | sed -r -n 's/^install ok installed //p')
    if [ -n "$header_packages" ]; then
        echo "I: Using the following Linux header packages that were already installed:"
        for p in $header_packages ; do
            echo "I:   $p"
        done
        return
    fi

    # Which Linux header packages could be installed?
    # linux-doc is a dependency generated by autodep8 for autopkgtest-pkg-dkms
    # install only linux-headers-* matching the source version of linux-doc
    wanted_source_version=$(dpkg-query -f '${source:Version}' -W linux-doc 2>/dev/null || true)
    candidates=$(apt-cache search --names-only '^linux-headers-' | awk '{print $1}' | grep -v -E -e '-common(-rt)?$')
    echo "I: No Linux header packages are installed."
    echo "I: Installing all available ones from src:linux $wanted_source_version:"
    for p in $candidates ; do
        if [ -z "$wanted_source_version" ]; then
            echo "I:   $p"
            header_packages="$header_packages $p"
            continue
        fi
        source_versions=$(apt-cache show $p | perl -ne 'if (/^$/) { print $s || $v, "\n"; $s=$v=""; } $s=$1 if /^Source: .* \((.*)\)$/; $v=$1 if /^Version: (.*)$/;')
        for sv in $source_versions ; do
            if [ "$sv" = "$wanted_source_version" ]; then
                echo "I:   install $p"
                header_packages="$header_packages $p"
                continue 2
            fi
        done
        echo "I:   skip    $p"
    done
    RC=0
    apt-get install --no-install-recommends -yq $header_packages </dev/null 2>&1 || RC=$?
    if [ "$RC" -ne 0 ]; then
        echo "E: Linux headers failed to install." >&2
        exit 1
    fi
}

run_pkg() {
    pkg="$1"

    test -x /usr/bin/openssl || apt-get install --no-install-recommends -yq openssl </dev/null 2>&1

    echo "I: Removing binary package $pkg, to get clean state."
    apt-get purge -yq $pkg </dev/null 2>&1 >/dev/null || true

    echo "I: Installing binary package $pkg"
    RC=0
    apt-get install --no-install-recommends -yq $pkg </dev/null 2>&1 || RC=$?
    if [ "$RC" -ne 0 ]; then
        echo "E: Package $pkg failed to install." >&2
        result=1
        return
    fi

    # Try and remove dkms to spot packages which miss a dkms dependency
    echo "I: Checking for missing dkms dependency by trying to deinstall dkms"
    dpkg --remove dkms || true

    if ! dkms_conf=$(dpkg -L $pkg | grep '/usr/src' | grep '/dkms.conf$'); then
        echo "I: Package $pkg has no dkms.conf, skipping."
        return
    fi

    check_for_linux_headers

    echo "I: Testing binary package $pkg"

    dkms_pkg=$(bash -c ". $dkms_conf > /dev/null; echo \$PACKAGE_NAME" 2>/dev/null)
    dkms_ver=$(bash -c ". $dkms_conf > /dev/null; echo \$PACKAGE_VERSION" 2>/dev/null)
    build_depends=$(bash -c ". $dkms_conf > /dev/null; echo \$BUILD_DEPENDS" 2>/dev/null)
    versioned_build_depends=

    for bd in $build_depends
    do
        bdpath=$(ls -d /usr/src/${bd}-*)
        versioned_build_depends="$versioned_build_depends ${bd}/${bdpath#/usr/src/${bd}-}"
    done

    for k in $(ls -dv /lib/modules/*/build)
    do
        test -d "$k" || continue
        kver="${k%/build}"
        kver="${kver#/lib/modules/}"

        # If any linux-meta is in triggers, only test abistems that
        # match triggers otherwise continue. This helps integration
        # with adt-matrix which specifically requests test results
        # against each individual linux-meta and tracks unique results
        # per kernel abi.
        abistem=$(echo $kver | sed 's/-[a-z]*$//')
        case "${ADT_TEST_TRIGGERS-}" in
            *linux-meta*)
                case "$ADT_TEST_TRIGGERS" in
                    *"$abistem"*)
                        ;;
                    *)
                        continue
                        ;;
                esac
        esac

        for bdv in $versioned_build_depends
        do
            echo "I: Trying to install build dependency $bdv for $kver"
            dkms install "$bdv" -k "$kver" || test $? = 77
        done

        echo "I: Trying to build $dkms_pkg/$dkms_ver for $kver"
        res=0
        dkms build -m "$dkms_pkg" -v "$dkms_ver" -k "$kver" || res=$?

        if [ "$res" = 77 ]; then
            echo "I: $dkms_pkg/$dkms_ver is not supported on $kver (BUILD_EXCLUSIVE directive), skipping."
            summary="${summary}I: SKIP $kver${crlf}"
            continue
        fi

        if [ "$res" != 0 ]; then
            echo "E: $dkms_pkg/$dkms_ver failed to build for $kver" >&2
            makelog="/var/lib/dkms/$dkms_pkg/$dkms_ver/build/make.log"
            echo "========== $makelog ==========" >&2
            cat "$makelog" >&2 || true
            echo "====================" >&2
            summary="${summary}I: FAIL $kver${crlf}"
            result=1
            continue
        fi

        if ! dkms install --force -m "$dkms_pkg" -v "$dkms_ver" -k "$kver" ; then
            echo "E: $dkms_pkg/$dkms_ver failed to install for $kver" >&2
            summary="${summary}I: FAIL $kver${crlf}"
            result=1
            continue
        fi

        echo "I: Testing if $dkms_pkg modules are correctly installed."
        dkmsstatus="$(dkms status $dkms_pkg -k $kver)"
        echo "$dkmsstatus"
        if [ -z "$dkmsstatus" ]; then
            echo "E: dkms status output is empty!" >&2
            summary="${summary}I: FAIL $kver${crlf}"
            result=1
            continue
        fi

        if ! echo "$dkmsstatus" | grep -q "installed$"; then
            echo "E: not installed" >&2
            summary="${summary}I: FAIL $kver${crlf}"
            result=1
            continue
        fi

        summary="${summary}I: PASS $kver${crlf}"

    done

    # collect build logs as artifacts
    if [ -d /var/lib/dkms ]; then
        (cd /var/lib/dkms; find $dkms_pkg -name "make.log" -print0 | xargs -r -0 tar cvz) > "${AUTOPKGTEST_ARTIFACTS:-.}/$pkg-make-logs.tar.gz"
    fi

    # skip modprobing for now; this fails too often (needs particular
    # hardware/firmware/etc)
    # for mod in $(awk -F '"' '/^BUILT_MODULE_NAME/ {print $2}' $dkms_conf); do
    #     echo "I: modprobe $mod"
    #     if ! modprobe $mod; then
    #         echo "E: Failed to modprobe module $mod" >&2
    #         exit 1
    #     else
    #         echo "I: $modname loaded"
    #     fi
    # done
}

# Do not (fail to) build the modules upon linux-header-* and *-dkms package
# installation, which can cause apt-get to fail. We will do this later with
# improved error reporting.
# (This only works if the *-dkms package is not yet installed.)
touch /etc/dkms/no-autoinstall

pkg_list="$*"
if [ -z "$pkg_list" ]; then
    test -x /usr/bin/grep-dctrl || apt-get install --no-install-recommends -yq dctrl-tools </dev/null 2>&1
    pkg_list="$(grep-dctrl -FDepends -e '(^| )dkms' -o -FPackage -e '\-dkms' debian/control -sPackage -n)"
fi

for pkg in $pkg_list; do
    # package might be arch: restriction or udeb etc.
    if ! apt-cache show $pkg >/dev/null 2>&1; then
        echo "I: Skipping unavailable package $pkg"
        continue
    fi
    run_pkg $pkg
done

if [ -n "$summary" ]; then
    echo "I: Summary:"
    echo -n "$summary"
fi

rm -f /etc/dkms/no-autoinstall

exit $result

# vim: sw=4:ts=4:et
