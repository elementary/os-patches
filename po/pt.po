# Bash - Bourne Again Shell.
# Copyright (C) 2020 Free Software Foundation, Inc.
# This file is distributed under the same license as the Bash package.
# Pedro Albuquerque <pmra@protonmail.com>, 2018, 2019, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: bash-5.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2020-12-08 03:20+0000\n"
"Last-Translator: Pedro Albuquerque <pmra@protonmail.com>\n"
"Language-Team: Portuguese <translation-team-pt@lists.sourceforge.net>\n"
"Language: pt\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Geany / PoHelper 1.37\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "subscrito de matriz inválido"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: a remover atributo nameref"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: impossível converter matriz indexada para associativa"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: impossível atribuir a índice não numérico"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: tem de usar subscrito ao atribuir a matriz associativa"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: impossível criar: %s"

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""
"bash_execute_unix_command: impossível encontrar mapa de teclado para o "
"comando"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: o 1º carácter não-espaço não é \"\"\""

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "sem \"%c\" de fecho em %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: separador dois pontos em falta"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "\"%s\": impossível desassociar no mapa de teclado do comando"

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "expansão: impossível alocar memória para %s"

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "expansão: falha ao alocar memória para %u elementos"

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "expansão: falha ao alocar memória para \"%s\""

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "\"%s\": aliás inválido"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "Edição de linha não activada"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "\"%s\": mapa de teclado inválido"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: impossível ler: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "\"%s\": nome de função desconhecido"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s: não tem associação a qualquer tecla.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s pode ser chamado via "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "\"%s\": impossível desassociar"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "total de ciclos"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "só tem significado num ciclo \"for\", \"while\" ou \"until\""

#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Devolve o contexto da actual chamada a sub-rotina.\n"
"     \n"
"     Sem EXPR, devolve \"$linha $nomefich\".  Com EXPR, devolve\n"
"     \"$linha $sub-rotina $nomefich\"; esta informação extra pode ser usada\n"
"     para obter um rasto da pilha.\n"
"     \n"
"     O valor de EXPR indica quantas chamadas deve recuar antes da\n"
"     actual; a chamada superior é a chamada 0.\n"
"     Estado de saída:\n"
"     Devolve 0 a não ser que a consola não esteja a executar uma função ou "
"EXPR\n"
"     seja inválida."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "HOME não definida"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "demasiados argumentos"

#: builtins/cd.def:342
msgid "null directory"
msgstr "pasta nula"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "OLDPWD não definida"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "linha %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "aviso: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: uso: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: a opção requer um argumento"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: requer um argumento numérico"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: não encontrado"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: opção inválida"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: nome de opção inválido"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "\"%s\": identificador inválido"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "número octal inválido"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "número hexadecimal inválido"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "número inválido"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: especificação de sinal inválida"

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "\"%s\": especificação de pid ou tarefa inválida"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: variável só de leitura"

#: builtins/common.c:273
#, fuzzy, c-format
msgid "%s: cannot assign"
msgstr "%s: impossível desactivar"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s fora do intervalo"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "argumento"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s fora do intervalo"

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: tarefa inexistente"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: sem controlo da tarefa"

#: builtins/common.c:301
msgid "no job control"
msgstr "sem controlo da tarefa"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: restrita"

#: builtins/common.c:313
msgid "restricted"
msgstr "restrita"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: não é interno da consola"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "erro de escrita: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "erro ao definir atributos do terminal: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "erro ao obter atributos do terminal: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: erro ao obter a pasta actual: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: especificação de tarefa ambígua"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "ajuda indisponível nesta versão"

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: impossível desactivar: %s só de leitura"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: impossível desactivar"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: nome de acção inválido"

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: sem especificação de conclusão"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "aviso: a opção -F pode não resultar como esperado"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "aviso: a opção -C pode não resultar como esperado"

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "a função de conclusão não está em execução"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "só pode ser usado numa função"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "impossível usar \"-f\" para fazer funções"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: função só de leitura"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: variável de referência não pode ser uma matriz"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: não são permitidas auto-referências de nameref"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s: referência circular de nome"

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "\"%s\": nome de variável inválido para referência de nome"

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: impossível destruir variáveis de matriz assim"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: impossível converter matriz associativa em indexada"

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: atribuição de matriz composta citada obsoleta"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "carregamento dinâmico indisponível"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "impossível abrir objecto partilhado %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "impossível encontrar %s no objecto partilhado %s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: interno dinâmico já carregado"

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "carregamento da função %s devolve falha (%d): não carregada"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: não carregada dinamicamente"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: impossível eliminar: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: é uma pasta"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: não é um ficheiro normal"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: ficheiro muito grande"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: impossível executar o binário"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: impossível executar: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "logout\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "não é consola de sessão: use \"exit\""

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Há tarefas interrompidas.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Há tarefas em curso.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "sem comando encontrado"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "especificação de histórico"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: impossível abrir ficheiro temporário: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "actual"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "tarefa %d começou sem controlo de tarefa"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opção ilegal -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: a opção requer um argumento -- %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "hashing desactivado"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabela de hash vazia\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "sucessos\tcomando\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Comandos de consola correspondentes à palavra-chave \""
msgstr[1] "Comandos de consola correspondentes a palavras-chave \""

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"nenhum tópico de ajuda para \"%s\".  Tente \"help help\", \"man -k %s\" ou "
"\"info %s\"."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: impossível abrir: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Estes comandos de consola são definidos internamente. Insira \"help\" para "
"ver a lista.\n"
"Insira \"help nome\" para saber mais sobre a função \"nome\".\n"
"Use \"info bash\" para saber mais sobre a consola em geral.\n"
"Use \"man -k ou \"info\" para saber mais sobre comandos não listados.\n"
"\n"
"Um asterisco (*) junto a um nome significa que o comando está inactivo.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "impossível usar mais de um -anrw"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "posição do histórico"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: datação inválida"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: falha na expansão do histórico"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: falha inlib"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "não são permitidas mais opções com \"-x\""

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: os argumentos têm de ser IDs de processos ou tarefas"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Erro desconhecido"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "esperada expressão"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: não é uma matriz indexada"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: especificação de descritor de ficheiro inválida"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: descritor de ficheiro inválido: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: total de linhas inválido"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: origem de matriz inválida"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: callback inválida"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "nome de variável de matriz vazio"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "requerido suporte a variáveis de matriz"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "%s: carácter de formato em falta"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "\"%c\": especificação de formato de hora inválida"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "\"%c\": carácter de formato inválido"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "aviso: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "problema de análise de formato: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "dígito hex em falta para \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "dígito unicode em falta para \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "nenhuma outra pasta"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s: argumento inválido"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<sem pasta actual>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "pilha de pastas vazia"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "índice da pilha de pastas"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Mostrar a lista de pastas actualmente lembradas.  As pastas\n"
"    entram na lista com o comando \"pushd\"; pode recuar\n"
"    na lista com o comando \"popd\".\n"
"    \n"
"    Opções:\n"
"      -c\tlimpar a pilha de pastas eliminando todos os elementos\n"
"      -l\tnão imprimir versões com prefixo til de pastas relativas\n"
"    \tà sua pasta home\n"
"      -p\timprimir a pilha de pastas com uma entrada por linha\n"
"      -v\timprimir a pilha de pastas com uma entrada por linha com a sua\n"
"    \tposição na pilha como prefixo\n"
"    \n"
"    Argumentos:\n"
"      +N\tmostra a N entrada a contar da esquerda da lista mostrada por\n"
"    \tpastas quando chamada sem opções, começando com zero.\n"
"    \n"
"      -N\tmostra a N entrada a contar da direita da lista mostrada por\n"
"    \tpastas quando chamada sem opções, começando com zero."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Adiciona uma pasta ao cimo da pilha de pastas ou roda a pilha\n"
"    tornando a pasta actual o novo cimo da pilha.\n"
"    Sem argumentos, troca as duas pastas superiores.\n"
"    \n"
"    Opções:\n"
"      -n\tSuprime a troca normal de pastas ao adicionar\n"
"    \tpastas à pilha, só a pilha é manipulada.\n"
"    \n"
"    Argumentos:\n"
"      +N\tRoda a pilha de forma a que a N pasta (contando\n"
"    \tda esquerda da lista mostrada por pastas, começando com\n"
"    \tzero) fique no topo.\n"
"    \n"
"      -N\tRoda a pilha de forma a que a N pasta (contando\n"
"    \tda direita da lista mostrada por pastas, começando com\n"
"    \tzero) fique no topo.\n"
"    \n"
"      PST\tAdiciona PST ao cimo da pilha de pastas, tornando-a a\n"
"    \tnova pasta de trabalho actual.\n"
"    \n"
"    O \"dirs\" interno mostra a pilha de pastas."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Remove entradas da pilha de pastas.  Sem argumentos, remove\n"
"    a pasta superior da pilha e muda para a nova pasta de topo.\n"
"    \n"
"    Opções:\n"
"      -n\tSuprime a troca normal de pastas ao remover\n"
"    \tpastas da pilha, só a pilha é manipulada.\n"
"    \n"
"    Argumentos:\n"
"      +N\tRemove a N pasta contando da esquerda da lista\n"
"    \tmostrada por pastas, começando com zero  Por exemplo: \"popd +0\"\n"
"    \tremove a primeira pasta, \"popd +1\" a segunda.\n"
"    \n"
"      -N\tRemove a N pasta contando da direita da lista\n"
"    \tmostrada por pastas, começando com zero  Por exemplo: \"popd +0\"\n"
"    \tremove a última pasta, \"popd +1\" a penúltima.\n"
"    \n"
"    O \"dirs\" interno mostra a pilha de pastas."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: especificação de inacção inválida"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "erro de leitura: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr "só pode usar \"return\" a partir de uma função ou script baseado"

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "impossível desactivar simultaneamente uma função e uma variável"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: não é variável de matriz"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: não é função"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: impossível exportar"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "total de trocas"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "impossível definir e desactivar opções da consola em simultâneo"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: nome de opção da consola inválido"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "requerido argumento de nome de ficheiro"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: ficheiro não encontrado"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "impossível suspender"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "impossível suspender uma consola de sessão"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s usa o aliás \"%s\"\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s é palavra-chave da consola\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s é uma função\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s é opção interna especial da consola\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s é opção interna da consola\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s é %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s tem hash (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: argumento de limite inválido"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "\"%c\": comando errado"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: impossível obter limite: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "limite"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: impossível modificar limite: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "número octal"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "\"%c\": operador de modo simbólico inválido"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "\"%c\": carácter de modo simbólico inválido"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " linha "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "último comando: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "A abortar..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "INFORM.: "

#: error.c:310
#, fuzzy, c-format
msgid "DEBUG warning: "
msgstr "aviso: "

#: error.c:488
msgid "unknown command error"
msgstr "erro de comando desconhecido"

#: error.c:489
msgid "bad command type"
msgstr "tipo de comando errado"

#: error.c:490
msgid "bad connector"
msgstr "conector errado"

#: error.c:491
msgid "bad jump"
msgstr "salto errado"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: variável desassociada"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aDemasiada inacção à espera de entrada: sessão terminada\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "impossível redireccionar entrada padrão de /dev/null: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "FORMATOHORA: \"%c\": carácter de formato inválido"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] ainda existe"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "erro de pipe"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: nível máximo de aninhamento de eval excedido (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: nível máximo de aninhamento de fonte excedido (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: nível máximo de aninhamento de função excedido (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: restrito: impossível especificar \"/\" em nomes de comando"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: comando não encontrado"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, fuzzy, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: impossível executar o binário"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: interpretador errado"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: impossível executar binário: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "%s: é uma opção interna especial"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "impossível duplicar fd %d para fd %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "nível de recursão da expressão excedido"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "sub-fluxo da pilha de recursividade"

#: expr.c:478
msgid "syntax error in expression"
msgstr "erro de sintaxe na expressão"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "tentativa de atribuição a não-variável"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "erro de sintaxe na atribuição de variável"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "divisão por 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "problema: símbolo expassign errado"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "\":\" esperados para expressão condicional"

#: expr.c:973
msgid "exponent less than 0"
msgstr "expoente menor que 0"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "identificador esperado após pré-incremento ou pré-decremento"

#: expr.c:1057
msgid "missing `)'"
msgstr "\")\" em falta"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "erro de sintaxe: operando esperado"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "erro de sintaxe: operador aritmético inválido"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (símbolo de erro é \"%s\")"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "base aritmética inválida"

#: expr.c:1587
msgid "invalid integer constant"
msgstr "constante inteira inválida"

#: expr.c:1603
msgid "value too great for base"
msgstr "valor muito grande para a base"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: erro de expressão\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: impossível aceder a pastas-mãe"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "impossível repor modo nodelay para fd %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr ""
"impossível alocar novo descritor de ficheiro para entrada bash de fd %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: buffer já existe para o novo fd %d"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pipe pgrp"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "pid %d aparece em tarefa em execução %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "a eliminar tarefa interrompida %d com grupo de processo %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) marcado como ainda activo"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: pid não existente"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Sinal %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Feito"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Interrompido"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Interrompido(%s)"

#: jobs.c:1881
msgid "Running"
msgstr "Em execução"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Feito(%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Sair de %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Estado desconhecido"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(núcleo despejado) "

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (wd: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "setpgid filho (%ld para %ld)"

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: pid %ld não é um filho desta consola"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: sem registo do processo %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_tarefa: tarefa %d está interrompida"

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: sem tarefas actuais"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: tarefa terminada"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: tarefa %d já em 2º plano"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: a ligar WNOHANG para evitar bloquieo indefinido"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: linha %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (núcleo despejado)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(wd agora: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp falhou"

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: sem controlo de tarefa em 2º plano"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: disciplina de linha"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "impossível definir grupo de processo do terminal (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "não há controlo de tarefa nesta consola"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: asserção falhada: %s\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: asserção frustrada\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "desconhecido"

#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc: bloqueio na lista livre clobbered"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: chamado com argumento de bloco já liberto"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: chamado com argumento de bloco não alocado"

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: sub-fluxo detectado; mh_nbytes fora do intervalo"

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: sub-fluxo detectado; magic8 corrompido"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: tamanho dos pontos inicial e final difere"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: chamado com argumento de bloco não alocado"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: sub-fluxo detectado; mh_nbytes fora do intervalo"

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: sub-fluxo detectado; magic8 corrompido"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: tamanho dos pontos inicial e final difere"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: tabela de alocação cheia com FIND_ALLOC?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p já na tabela como alocado?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p já na tabela como livre?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "base inválida"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: anfitrião desconhecido"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: serviço inválido"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: especificação de caminho de rede errada"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "operações de rede não suportadas"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: não pode alterar o idioma (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: não pode alterar o idioma (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: não pode alterar o idioma (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: não pode alterar o idioma (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Tem correio em $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Tem novo correio em $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "O correio em %s já foi lido\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "erro de sintaxe: requerida expressão aritmética"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "erro de sintaxe: \";\" inesperado"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "erro de sintaxe: \"((%s))\""

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: tipo de instrução %d errado"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""
"here-document na linha %d delimitado por fim-de-ficheiro (desejado \"%s\")"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""
"make_redirection: instrução de redireccionamento \"%d\" fora do intervalo"

#: parse.y:2428
#, c-format
msgid ""
"shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line "
"truncated"
msgstr ""
"consola_getc: consola_input_line_size (%zu) excede SIZE_MAX (%lu): linha "
"truncada"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "total here-document máximo excedido"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "EOF inesperado ao procurar \"%c\" correspondentes"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "EOF inesperado ao procurar \"]]\""

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "erro de sintaxe em expressão condicional: símbolo inesperado \"%s\""

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "erro de sintaxe em expressão condicional"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "símbolo inesperado \"%s\", esperado \")\""

#: parse.y:4543
msgid "expected `)'"
msgstr "esperado \")\""

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "argumento \"%s\" inesperado para operador unário condicional"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "argumento inesperado para operador unário condicional"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "símbolo \"%s\" inesperado, esperado operador binário condicional"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "esperado operador binário condicional"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "argumento \"%s\" inesperado para operador binário condicional"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "argumento inesperado para operador binário condicional"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "símbolo \"%c\" inesperado em comando condicional"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "símbolo \"%s\" inesperado em comando condicional"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "símbolo %d inesperado em comando condicional"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "erro de sintaxe junto a símbolo \"%s\" inesperado"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "erro de sintaxe junto a \"%s\""

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "erro de sintaxe: fim de ficheiro inesperado"

#: parse.y:6151
msgid "syntax error"
msgstr "erro de sintaxe"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Use \"%s\" para sair da consola.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "EOF inesperado ao procurar o \")\" correspondente"

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: função \"%s\" não encontrada"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programmable_completion: %s: possível ciclo de repetição"

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULL COMPSPEC"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: conector \"%d\" errado"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: descritor de ficheiro inválido"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: ponteiro de ficheiro NULL"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != fileno xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: \"%c\": carácter de formato inválido"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "descritor de ficheiro fora de alcance"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: redireccionamento ambíguo"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: impossível sobrescrever ficheiro existente"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: restricto: impossível redireccionar saída"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "impossível criar ficheiro temporário para here-document: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: impossível atribuir fd a variável"

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port não suportado em trabalho de rede"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "erro de redireccionamento: impossível duplicar fd"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "impossível encontrar /tmp, por favor crie-a!"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "/tmp tem de ser um nome de pasta válido"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "modo pretty-printing ignorado em consolas interactivas"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: opção inválida"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "impossível definir uid como %d: uid efectiva %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "impossível definir gid como %d: gid efectiva %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "impossível iniciar o depurador; modo de depuração desactivado"

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s: é uma pasta"

#: shell.c:1907
msgid "I have no name!"
msgstr "Não tenho nome!"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, versão %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Uso:\t%s [opção longa GNU] [opção] ...\n"
"\t%s [opção longa GNU] [opção] script-file ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "Opções longas GNU:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Opções da consola:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\tcomando -ilrsD ou -c ou -O shopt_option\t\t(só chamada)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\topção -%s ou -o\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Insira \"%s -c \"help set\"\" para mais informação sobre opções da consola.\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Insira \"%s -c help\" para mais informação sobre comandos internos da "
"consola.\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Use o comando \"bashbug\" para reportar erros.\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Página inicial do bash: <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Ajuda geral para usar programas GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: operação inválida"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Sinal falso"

#: siglist.c:51
msgid "Hangup"
msgstr "Desligar"

#: siglist.c:55
msgid "Interrupt"
msgstr "Interromper"

#: siglist.c:59
msgid "Quit"
msgstr "Sair"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Instrução ilegal"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "BPT trace/trap"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Instrução ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Instrução EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Excepção de vírgula flutuante"

#: siglist.c:87
msgid "Killed"
msgstr "Morto"

#: siglist.c:91
msgid "Bus error"
msgstr "Erro de bus"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Falha de segmentação"

#: siglist.c:99
msgid "Bad system call"
msgstr "Chamada de sistema errada"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Pipe quebrado"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Alarme"

#: siglist.c:111
msgid "Terminated"
msgstr "Terminado"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Condição IO urgente"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Parado (sinal)"

#: siglist.c:127
msgid "Continue"
msgstr "Continuar"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Morte ou paragem do filho"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Parado (entrada tty)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Parado (saída tty)"

#: siglist.c:147
msgid "I/O ready"
msgstr "I/O pronto"

#: siglist.c:151
msgid "CPU limit"
msgstr "Limite do CPU"

#: siglist.c:155
msgid "File limit"
msgstr "Limite do ficheiro"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarme (virtual)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarme (perfil)"

#: siglist.c:167
msgid "Window changed"
msgstr "Janela alterada"

#: siglist.c:171
msgid "Record lock"
msgstr "Bloqueio de registo"

#: siglist.c:175
msgid "User signal 1"
msgstr "Sinal de utilizador 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Sinal de utilizador 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "entrada de dados HTF pendente"

#: siglist.c:187
msgid "power failure imminent"
msgstr "falha de energia iminente"

#: siglist.c:191
msgid "system crash imminent"
msgstr "acidente do sistema iminente"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "migrar processo para outro CPU"

#: siglist.c:199
msgid "programming error"
msgstr "erro de programação"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "concedido modo de monitor HTF"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "retirado modo de monitor HTF"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "sequência de som HTF terminou"

#: siglist.c:215
msgid "Information request"
msgstr "Pedido de informação"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Sinal desconhecido #%d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "má substituição: sem \"%s\" de fecho em %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: impossível atribuir lista a membro de matriz"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "impossível fazer pipe para substituição de processo"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "impossível fazer filho para substituição de processo"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "impossível abrir pipe chamado %s para leitura"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "impossível abrir pipe chamado %s para escrita"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "imossível duplicar pipe chamado %s como fd %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "substituição de comando: byte nulo ignorado na entrada"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "impossível fazer pipe para substituição de comando"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "impossível fazer filho para substituição de comando"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: impossível duplicar pipe como fd 1"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: nome de variável inválido para referência de nome"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: expansão indirecta inválida"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: nome de variável inválido"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: parâmetro não definido"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parâmetro nulo ou não definido"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: expressão de sub-cadeia < 0"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: má substituição"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: impossível atribuir desta forma"

#: subst.c:10111
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""
"futuras versões da consola vão forçar a avaliação como uma substituição "
"aritmética"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "má substituição: sem \"\"\" de fecho em %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "sem par:%s"

#: test.c:147
msgid "argument expected"
msgstr "argumento esperado"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: expressão inteira esperada"

#: test.c:265
msgid "`)' expected"
msgstr "\")\" esperado"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "\")\" esperado, encontrado %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: operador bináro esperado"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: operador unáro esperado"

#: test.c:896
msgid "missing `]'"
msgstr "\"]\" em falta"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "erro de sintaxe: \"%s\" esperado"

#: trap.c:220
msgid "invalid signal number"
msgstr "número de sinal inválido"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "gestor de trap: nível máximo de gestor de captura excedido (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: valor errado em trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""
"run_pending_traps: gestor de sinal é SIG_DFL, a reenviar %d (%s) para mim "
"próprio"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: sinal errado %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "erro ao importar definição de função para \"%s\""

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "nível da consola (%d) muito alto, a repor para 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variável: sem contexto de função no âmbito actual"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: não pode atribuir um valor à variável"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr ""

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: a atribuir inteiro à referência de nome"

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: sem contexto de função no âmbito actual"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s tem exportstr nulo"

#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "carácter %d inválido em exportstr para %s"

#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "sem \"=\" em exportstr para %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: cabeça de consola_variables não é contexto de função"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: sem contexto de global_variables"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""
"pop_scope: cabeça de consola_variables não é âmbito de ambiente temporário"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: impossível abrir como FICHEIRO"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: valor inválido para descritor de ficheiro trace"

#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: valor de compatibilidade fora do intervalo"

#: version.c:46 version2.c:46
#, fuzzy
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Copyright (C) 2020 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Licença GPLv3+: GNU GPL versão 3 ou posterior <http://gnu.org/licenses/gpl."
"html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, versão %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "Este é um programa gratuito; pode alterá-lo e distribuí-lo à vontade."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Não há QUALQUER GARANTIA, até aos limites previstos pela Lei."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: impossível alocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: impossível alocar %lu bytes"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: impossível alocar %lu bytes (%lu bytes alocados)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: impossível alocar %lu bytes"

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [nome[=valor] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] nome [nome ...]"

#: builtins.c:53
msgid ""
"bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpsvPSVX] [-m mapa de teclado] [-f ficheiro] [-q nome] [-u nome] [-r "
"seqtecl] [-x seqtecl:comando-consola] [seqtecl:função-readline ou comando-"
"readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [consola-interno [arg ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [expr]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [pst]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "comando [-pVv] comando [arg ...]"

#: builtins.c:78
#, fuzzy
msgid ""
"declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] "
"[name ...]"
msgstr "declare [-aAfFgiIlnrtux] [-p] [nome[=valor] ...]"

#: builtins.c:80
#, fuzzy
msgid ""
"typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] "
"[name ...]"
msgstr "typeset [-aAfFgiIlnrtux] [-p] nome[=valor] ..."

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [opção] nome[=valor] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f ficheiro] [nome ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [arg ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts optstring name [arg...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a nome] [comando [argumento ...]] [redireccionamento ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e ename] [-lnr] [primeiro] [último] ou fc -s [pat=rep] [comando]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [job_spec]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [job_spec ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p caminho] [-dt] [nome ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [padrão ...]"

#: builtins.c:123
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d desvio] [n], history -anrw [ficheiro] ou history -ps arg "
"[arg...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "tarefas [-lnprs] [tarefaspec ...] ou tarefas -x comando [args]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [tarefaspec ... | pid ...]"

#: builtins.c:134
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s sigspec | -n signum | -sigspec] pid | tarefaspec ... ou kill -l "
"[sigspec]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let arg [arg ...]"

#: builtins.c:138
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a matriz] [-d delim] [-i texto] [-n ncars] [-N ncars] [-p "
"prompt] [-t inacção] [-u fd] [nome ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
#, fuzzy
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCHP] [-o nome-opção] [--] [arg ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [nome ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [nome[=valor] ...] ou export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [nome[=valor] ...] ou readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source ficheiro [argumentos]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". ficheiro [argumentos]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [expr]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[arg] signal_spec ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] nome [nome ...]"

#: builtins.c:171
#, fuzzy
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPT] [limite]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [modo]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p var] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [pid ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOME [in PALAVRAS ... ] ; do COMANDOS; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( exp1; exp2; exp3 )); do COMANDOS; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NOME [in PALAVRAS ... ;] do COMANDOS; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] pipeline"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case PALAVRA in [PADRÃO [| PADRÃO]...) COMANDOS ;;]... esac"

#: builtins.c:194
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if COMANDOS; then COMANDOS; [ elif COMANDOS; then COMANDOS; ]... [ else "
"COMANDOS; ] fi"

#: builtins.c:196
#, fuzzy
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while COMANDOS; do COMANDOS; done"

#: builtins.c:198
#, fuzzy
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until COMANDOS; do COMANDOS; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NOME] comando [redireccionamentos]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "nome de função { COMANDOS ; } ou nome () { COMANDOS ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ COMANDOS ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "job_spec [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( expressão ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ expressão ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "variáveis - nomes e significados de algumas variáveis da consola"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | pasta]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [nomeopção ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] formato [argumentos]"

#: builtins.c:231
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-"
"W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o opção] [-A acção] [-G "
"padrãoglobal] [-W listapalavras] [-F função] [-C comando] [-X padrãofiltro] "
"[-P prefixo] [-S sufixo] [nome ...]"

#: builtins.c:235
msgid ""
"compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-"
"F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o opção] [-A acção] [-G padrãoglobal] [-W "
"listapalavras] [-F função] [-C comando] [-X padrãofiltro] [-P prefixo] [-S "
"sufixo] [palavra]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o opção] [-DEI] [nome ...]"

#: builtins.c:242
msgid ""
"mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"mapfile [-d delim] [-n total] [-O origem] [-s total] [-t] [-u fd] [-C "
"callback] [-c quantia] [matriz]"

#: builtins.c:244
msgid ""
"readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"readarray [-d delim] [-n total] [-O origem] [-s total] [-t] [-u fd] [-C "
"callback] [-c quantum] [matriz]"

#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Definir ou mostrar aliás.\n"
"    \n"
"    Sem argumentos, \"alias imprime a lista de aliás na forma\n"
"    reutilizável \"alias NOME=VALOR\" na saída padrão.\n"
"    \n"
"    Com argumetos, é definido um aliás para cada NOME cujo VALOR é dado.\n"
"    Um espaço final em VALOR causa uma verificação à palavra seguinte para\n"
"    substituição do aliás quando o aliás for expandido.\n"
"    \n"
"    Opções:\n"
"      -p\timprimir todos os aliás definidos em formato reutilizável\n"
"    \n"
"    Estado de saída:\n"
"    alias devolve verdadeiro a não ser que seja fornecido um NOME para o "
"qual\n"
"ainda não haja um aliás."

#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Remover cada NOME da lista de aliás definidos.\n"
"    \n"
"    Opções:\n"
"      -a\tremove todas as definições de aliás\n"
"    \n"
"    Devolve sucesso a não ser que NOME seja um aliás inexistente."

#: builtins.c:291
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated "
"commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Definir associações de teclas e variáveis para Readline.\n"
"    \n"
"    Associar uma sequência de teclas a uma função ou macro Readline, ou\n"
"    defina uma variável Readline. A sintaxe de argumento não-opção é "
"equivalente\n"
"    à encontrada em ~/.inputrc, mas tem de ser passada como argumento "
"único:\n"
"     e.g., bind \"\"\\C-x\\C-r\": re-read-init-file\".\n"
"     \n"
"     Opções:\n"
"        -m  maptecl            Use MAPTECL como mapa de teclado para a "
"duração deste\n"
"                                 comando. Nomes de mapas aceitáveis são "
"emacs,\n"
"                                 emacs-standard, emacs-meta, emacs-ctlx, vi, "
"vi-move,\n"
"                                 vi-command, e vi-insert.\n"
"        -l                      Listar nomes de funções.\n"
"        -P                      Listar nomes de funções e associações.\n"
"        -p                      Listar funções funçãos e associações de "
"forma a que possam\n"
"                                 ser reutilizados como entrada.\n"
"        -S                      Listar sequências de teclas que chamem "
"macros e seus valores\n"
"        -s                      Listar sequências de teclas que chamem "
"macros e seus valores\n"
"                                 de forma a que possam ser reutilizados como "
"entrada.\n"
"        -V                      Listar nomes de variáveis e seus valores\n"
"        -v                      Listar nomes de variáveis e seus valores de "
"forma a que possam\n"
"                                 ser reutilizados como entrada.\n"
"        -q  nome-função     Consultar que teclas chamaram a função em "
"causa.\n"
"        -u  nome-função     Unbind all keys which are bound to the named "
"função.\n"
"        -r  seqtecl          Remover associação de SEQTECL.\n"
"        -f  nomefich         Ler associações de teclas a partir de "
"NOMEFICH.\n"
"        -x  seqtecl:comando-consola\tCausa a execuçaõ de COMANDO-SHELL "
"quando\n"
"     \t\t\t\tSEQTECL for inserido.\n"
"        -X                      Listarsequências de teclas associadas a -x e "
"comandos ligados\n"
"                                 de forma a que possam ser reutilizados como "
"entrada.\n"
"     \n"
"     Estado de saída:\n"
"     bind devolve 0 a não ser que seja dada uma opção desconhecida ou ocorra "
"um erro."

#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Sair de ciclos for, while, ou until.\n"
"     \n"
"     Sai de um ciclo FOR, WHILE ou UNTIL.  Se N for especificado, quebrar N "
"ciclos\n"
"     envolventes.\n"
"     \n"
"     Estado de saída:\n"
"     O estado de saída é 0 a não ser que N não seja maior ou igual que 1."

#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Retomar ciclos for, while, ou until.\n"
"     \n"
"     Retoma a iteração seguinte do ciclo FOR, WHILE ou UNTIL envolvente.\n"
"     Se N for especificado, retoma o N-ésimo ciclo envolvente.\n"
"     \n"
"     Estado de saída:\n"
"     O estado de saída é 0 a não ser que N não seja maior ou igual que 1."

#: builtins.c:354
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Executa comandos internos da consola.\n"
"     \n"
"     Executa SHELL-INTERNO com argumentos ARGs sem realizar procura do "
"comando.\n"
"     Útil quando deseja re-implementar um comando interno da consola como\n"
"     função da consola, mas tem de executar o comando interno dentro da "
"função.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado de saída de SHELL-INTERNO ou falso se SHELL-INTERNO "
"não\n"
"     for um comando interno da consola."

#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Devolver o contexto da actual chamada a sub-rotina.\n"
"     \n"
"     Sem EXPR, devolve \"$linha $nomefich\".  Com EXPR, devolve\n"
"     \"$linha $sub-rotina $nomefich\"; esta informação extra pode ser usada\n"
"     para obter um rasto da pilha.\n"
"     \n"
"     O valor de EXPR indica quantas chamadas deve recuar antes da\n"
"     actual; a chamada superior é a chamada 0.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve 0 a não ser que a consola não esteja a executar uma função ou "
"EXPR\n"
"     seja inválida."

#: builtins.c:387
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname "
"component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully "
"when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Alterar a pasta de trabalho da consola.\n"
"     \n"
"     Altera a pasta actual para PASTA. A PASTA predefinida é o valor da "
"variável\n"
"     HOME.\n"
"     \n"
"     A variável CDPATH define o caminho de procura para a pasta que contém\n"
"     PASTA. Nomes de pasta alternativos em CDPATH são separados por \":"
"\" (:).\n"
"     Um nome de pasta nulo é equivalente à pasta actual. Se PASTA começar "
"com\n"
"     uma barra (/), CDPATH não é usada.\n"
"     \n"
"     Se a pasta não for encontrada e a opção de consola \"cdable_vars\" "
"estiver definida,\n"
"     a palavra é assumida como nome de variável. Se essa variável tiver um "
"valor,\n"
"     será usado como PASTA.\n"
"     \n"
"     Opções:\n"
"        -L\tforçar seguimento de ligações simbólicas: resolve ligações\n"
"     \t\tsimbólicas em PASTA após processar instâncias de \"..\"\n"
"        -P\tusa a estrutura física de pastas sem seguir ligações\n"
"     \t\tsimbólicas: resolve ligações simbólicas em PASTA antes de\n"
"     \t\tprocessar instâncias de \"..\"\n"
"        -e\tse a opção -P for usada e a pasta de trabalho actual não puder\n"
"     \t\tser determinada com sucesso, sair com\n"
"     \t\testado não-zero\n"
"        -@\tem sistemas que o suportam, apresentar um ficheiro com "
"atributos\n"
"     \t\testendidos como uma pasta contendo os atributos do ficheiro.\n"
"     \n"
"     A predefinição é seguir ligações simbólicas, como se \"-L\" fosse "
"especificada.\n"
"     \"..\" é processado colocando o componente de caminho imediatamente "
"anterior\n"
"     como barra ou o começo de PASTA.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve 0 se a pasta for alterada e se $PWD for definida com sucesso "
"quando\n"
"     -P é usada; caso contrário, não-zero."

#: builtins.c:425
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Imprimir o nome da actual pasta de trabalho.\n"
"     \n"
"     Opções:\n"
"        -L\tImprimir o valor de $PWD se nomear a actual pasta de\n"
"     \t\ttrabalho\n"
"        -P\timprimir a pasta física, sem quaisquer ligações simbólicas\n"
"     \n"
"     Por predefinição, \"pwd\" comporta-se como se \"-L\" fosse "
"especificada.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve 0 a não ser que seja indicada uma opçãoinválida ou a pasta "
"actual\n"
"     não possa ser lida."

#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Comando nulo.\n"
"     \n"
"     Sem efeito; o comando não faz nada.\n"
"     \n"
"     Estado de saída:\n"
"     Sempre com sucesso."

#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Devolve um resultado com sucesso.\n"
"     \n"
"     Estado de saída:\n"
"     Sempre com sucesso."

#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Devolve um resultado sem sucesso.\n"
"     \n"
"     Estado de saída:\n"
"     Falha sempre."

#: builtins.c:471
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Executar um comando simples ou mostrar informação sobre comandos.\n"
"     \n"
"     Executa COMANDO com ARGS suprimindo procura de funções da consola ou "
"mostra\n"
"     informação acerca dos COMANDOs especificados. Pode ser usado para "
"chamar comandos\n"
"     em disco quando existe uma função com o mesmo nome.\n"
"     \n"
"     Opções:\n"
"        -p     usar valor predefinido para CAMINHO que garanta que se "
"encontram\n"
"                todos os utilitários padrão\n"
"        -v     imprimir uma descrição de COMANDO similar ao interno \"type"
"\"\n"
"        -V     imprimir uma descrição mais detalhada de COMANDO\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado de saída de COMANDO ou falha se COMANDO não for "
"encontrado."

#: builtins.c:490
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Define valores e atributos de variáveis.\n"
"     \n"
"     Declara variáveis e dá-lhes atributos. Se não indicar NOMEs,\n"
"     mostrar os atributos e valores de todas as variáveis.\n"
"     \n"
"     Opções:\n"
"        -f\trestringe acção ou exibição a nomes e definições de função\n"
"        -F\trestringe exibição só a nomes de função (mais nº de linha e\n"
"     \t\tficheiro fonte ao depurar)\n"
"        -g\tcria variáveis globais quando usado numa função da consola; "
"senão\n"
"     \t\té ignorada\n"
"        -I\tse está a criar uma variável local, herdar atributos e valor\n"
"    \t\tduma variável com o mesmo nome num âmbito anterior\n"
"        -p\tmostra atributos e valores de cada NOME\n"
"     \n"
"     Opções que definem atributos:\n"
"        -a\tpara tornar NOMEs matrizes indexadas (se suportado)\n"
"        -A\tpara tornar NOMEs matrizes associativas (se suportado)\n"
"        -i\tpara dar a NOMEs o atributo \"integer\"\n"
"        -l\tpara converter NOMEs em minúsculas ao atribuir\n"
"        -n\ttornar NOME uma referência à variável chamada pelo seu valor\n"
"        -r\tpara tornar NOMEs só de leitura\n"
"        -t\tpara dar a NOMEs o atributo \"trace\"\n"
"        -u\tpara converter NOMEs em maiúsculas ao atribuir\n"
"        -x\tpara tornar NOMEs exportáveis\n"
"     \n"
"     Usar \"+\" em vez de \"-\" desliga o atributo indicado.\n"
"     \n"
"     Variáveis com o atributo integer têm avaliação aritmética (veja o\n"
"     comando \"let\") realizada quando lhe é atribuído um valor.\n"
"     \n"
"     Quando usado numa função, \"declare\" torna NOMEs locais, como o "
"comando\n"
"     \"local\". A opção \"-g\" suprime este comportamento.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que seja indicada uma opção inválida ou "
"ocorra um\n"
"     erro de atribuição da variável."

#: builtins.c:532
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Define variáveis e atributos.\n"
"     \n"
"     Um sinónimo para \"declare\".  Veja \"help declare\"."

#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Define variáveis locais.\n"
"     \n"
"     Cria uma variável local chamada NOME e dá-lhe VALOR. OPÇÃO pode\n"
"     ser qualquer opção aceite por \"declare\".\n"
"     \n"
"     Variáveis locais só podem ser usadas dentro de uma função; só são "
"visíveis\n"
"     para a função onde foram definidas e para os seus filhos.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que uma opção inválida seja fornecida, "
"ocorra \n"
"     um erro de atribuição ou a consola não esteja a executar uma função."

#: builtins.c:557
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by "
"a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value "
"HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal "
"value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Escreve argumentos para a saída padrão.\n"
"     \n"
"     Mostrar ARGs, separados por espaço único e seguidos de nova linha (LF)\n"
"     na saída padrão.\n"
"     \n"
"     Opções:\n"
"        -n\tnaõ acrescentar nova linha\n"
"        -e\tpermitir interpretação dos escapes seguintes com barra esquerda\n"
"        -E\tsuprimir explicitamente interpretação de escapes com barra "
"esquerda\n"
"     \n"
"     \"echo\" interpreta os seguintes caracteres de escapes com barra "
"esquerda:\n"
"        \\a\talerta (bell)\n"
"        \\b\tbackspace\n"
"        \\c\tsuprimir mais saídas\n"
"        \\e\tcarácter de escape\n"
"        \\E\tcarácter de escape\n"
"        \\f\tform feed\n"
"        \\n\tnova linha (LF)\n"
"        \\r\tcarriage return (CR)\n"
"        \\t\ttabulação horizontal\n"
"        \\v\ttabulação vertical\n"
"        \\\\\tbarra esquerda (\"\\\")\n"
"        \\0nnn\to carácter cujo código ASCII é NNN (octal).  NNN pode ter\n"
"     \t\tde 0 a 3 dígitos octais\n"
"        \\xHH\to carácter de 8-bit cujo valor é HH (hexadecimal).  HH\n"
"     \t\tpode ter um ou dois dígitos hexadecimais\n"
"        \\uHHHH\to carácter Unicode cujo valor é o valor hexadecimal HHHH.\n"
"    \t\tHHHH pode ser de um a quatro dígitos hexadecimais.\n"
"        \\UHHHHHHHH o carácter Unicode cujo valor é o valor hexadecimal\n"
"    \t\tHHHHHHHH. HHHHHHHH pode ser de um a oito dígitos hexadecimais.\n"
"    \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que ocorra um erro de escrita."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Escreve argumentos para a saída padrão.\n"
"     \n"
"     Mostrar ARGs na saída padrão seguidos de nova linha (LF).\n"
"     \n"
"     Opções:\n"
"        -n\tnão acrescentar nova linha\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que ocorra um erro de escrita."

#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Activar e desactivar internos da consola.\n"
"     \n"
"     Activa e desactiva comandos internos da consola. Desativar permite\n"
"     executar um comando de disco com o mesmo nome que comando interno\n"
"     sem ter de usar um caminho completo.\n"
"     \n"
"     Opções:\n"
"        -a\timprimir lista de internos mostrando se estão ou não activos\n"
"        -n\tdesactivar cada NOME ou mostrar uma lista de internos "
"desactivados\n"
"        -p\timprimir a lista de internos em formato reutilizável\n"
"        -s\timprimir só os nomes de internos \"especiais\" Posix\n"
"     \n"
"     Opções que controlam o carregamento dinâmico:\n"
"        -f\tCarregar interno NOME de objecto partilhado NOMEFICH\n"
"        -d\tRemover um interno carregado com -f\n"
"     \n"
"     Sem opções, cada NOME é activado.\n"
"     \n"
"     Para usar o \"test\" encontado em $PATH em vez do interno da consola\n"
"     insira \"enable -n test\".\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que NOME não seja um interno da consola ou "
"ocorra um erro."

#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Executa argumentos como comando da consola.\n"
"     \n"
"     Combina ARGs numa única cadeia, usa o resultado como entrada da "
"consola,\n"
"     e executa os comandos resultantes.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve estado de saída do comando ou sucesso se o comando for nulo."

#: builtins.c:652
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analisa argumentos da opção.\n"
"     \n"
"     Getopts é usado pelos procedimentos da consola para analisar parâmetros "
"posicionais\n"
"     como opções.\n"
"     \n"
"     CADEIAOPÇÕES contém as letras de opção a reconhecer; se uma letra\n"
"     for seguida de \":\", espera-se que a opção tenha um argumento,\n"
"     separado da opção por um espaço.\n"
"     \n"
"     Sempre que é chamado, getopts coloca a opção seguinte na variável\n"
"     da consola $name, inicializa name se não existir e o índice do\n"
"     argumento seguinte a processar na variável da consola OPTIND.\n"
"     OPTIND é inicializado em 1 sempre que a consola ou um script da\n"
"     consola é chamado. Quando uma opção requer um argumento, o\n"
"     getopts coloca esse argumento na variável da consola OPTARG.\n"
"     \n"
"     O getopts reporta erros de duas formas. Se o primeiro carácter\n"
"     de OPTCADEIA é \":\", o getopts usa um relatório de erro\n"
"     silencioso. Neste modo não verá mensagens de erro. Se for vista uma\n"
"     opção inválida, o getopts põe o carácter de opção em OPTARG.\n"
"     Se não houver um argumento requerido, o getopts põe um \":\" no NOME e\n"
"     define OPTARG como o carácter de opção encontrado. Se o getopts não\n"
"     estiver em modo silêncio e for vista uma opção inválida, o getopts\n"
"     põe \"?\" no NOME e limpa OPTARG. Se não houver um argumento "
"requerido,\n"
"     é posto \"?\" no NOME, OPTARG é limpo e é imprimida uma mensagem de\n"
"     diagnóstico.\n"
"     \n"
"     Se a variável da consola OPTERR tiver valor 0, o getopts desactiva a\n"
"     impressão de mensagens de erro, mesmo que o 1º carácter de\n"
"     CADEIAOPÇÕES não seja \":\". OPTERR tem o valor 1 predefinido.\n"
"     \n"
"     O getopts normalmente analisa os parâmetros posicionais, mas se\n"
"     os argumentosforem dados como valores ARG, são eles que são "
"analisados.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso se encontrar uma opção; falha se o fim da opção for\n"
"     encontrado ou se ocorrer um erro."

#: builtins.c:694
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Substitui a consola com o comando indicado.\n"
"     \n"
"     Executar COMANDO, substituindo esta consola pelo programa "
"especificado.\n"
"     ARGUMENTOS tornam-se os argumentos de COMANDO. Se COMANDO não for "
"especificado,\n"
"     quaisquer redireccionamentos têm efeito na consola actual.\n"
"     \n"
"     Opções:\n"
"        -a nome\tpassa NOME como argumento 0 a COMANDO\n"
"        -c\texecuta COMANDO com um ambiente vazio\n"
"        -l\tpõe uma barra no argumento 0 de COMANDO\n"
"     \n"
"     Se o comando não puder ser executado, uma consola não interactiva sai, "
"a não ser que\n"
"     a opção de consola \"execfail\" esteja definida.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que COMANDO não seja encontrado ou ocorra um "
"erro de redireccionamento."

#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Sai da consola.\n"
"     \n"
"     Sai da consola com estado N. Se N for omitido, o estado de saída\n"
"     é o do último comando executado."

#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"Sai de uma consola com sessão.\n"
"     \n"
"     Sai de uma consola com sessão com estado de saída N.  Devolve um erro "
"se não for\n"
"     executado numa consola com sessão."

#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"Mostra ou executa comandos da lista do histórico.\n"
"     \n"
"     fc é usado para listar ou editar e re-executar comandos da lsiat do "
"histórico.\n"
"     PRIMEIRO e ÚLTIMO podem ser números especificando o intervalo, ou "
"PRIMEIRO pode ser\n"
"     cadeia, que significa o comando mais recente começado por essa\n"
"     cadeia.\n"
"     \n"
"     Opções:\n"
"        -e NOMEED\tseleciona o editor a usar.  A predefinição é FCEDIT, "
"depois EDITOR,\n"
"     \t\tdepois vi\n"
"        -l \tlistar linhas em vez de editar\n"
"        -n\tomitir nºs de linha ao ouvir\n"
"        -r\treverter a ordem das linhas (mais recentes primeiro)\n"
"     \n"
"     Com o formato \"fc -s [pat=rep ...] [comando]\", COMANDO é\n"
"     re-executado após a substituição VELHO=NOVO ser realizada.\n"
"     \n"
"     Um aliás útil a usar aqui é r=\"fc -s\", para que inserir \"r cc\"\n"
"     executa o último comando começado por \"cc\" e inserir \"r\" re-"
"executa\n"
"     o último comando.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso ou estado do comando executado; não-zero se ocorrer um "
"erro."

#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Move a tarefa para 1º plano.\n"
"     \n"
"     Coloca a tarefa identificada com JOB_SPEC em 1º plano, tornando-a a\n"
"     tarefa actual. Se JOB_SPEC não existir, é usada a noção da consola de\n"
"     tarefa actual.\n"
"     \n"
"     Estado de saída:\n"
"     Estado do comando colocado em 1º plano ou falha se ocorrer um erro."

#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Move a tarefa para 2º plano.\n"
"     \n"
"     Coloca a tarefa identificada com cada JOB_SPEC em 2º plano, como se "
"tivessem\n"
"     sido iniciados com \"&\". Se JOB_SPEC não existir, é usada a noção da "
"consola de\n"
"     tarefa actual.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que o controlo de tarefas esteja inactivo ou "
"ocorra um erro."

#: builtins.c:793
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Recorda ou mostra localizações de programas.\n"
"     \n"
"     Determina e recorda o caminho completo de cada comando NOME. Se\n"
"     não tiver argumentos, é mostrada informação sobre comando recordados.\n"
"     \n"
"     Opções:\n"
"        -d\tesquecer a localização recordada de cada NOME\n"
"        -l\tmostrar num formato que possa ser usado como entrada\n"
"        -p caminho\tuse CAMINHO como caminho completo para NOME\n"
"        -r\tesquecer todas as localizações recordadas\n"
"        -t\timprimir a localização recordada de cada NOME, precedendo-a\n"
"     \t\tdo correspondente NOME se forem\n"
"     \t\tindicados múltiplos NOMEs\n"
"     Argumentos:\n"
"        NOME\tCada NOME é procurado no $PATH e adicionado à lista\n"
"     \t\tde comandos lembrados.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que NOME não seja encontrado ou indique uma "
"opção inválida."

#: builtins.c:818
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"Mostra informação sobre comandos internos.\n"
"     \n"
"     Mostra breves resumos de comandos internos. Se PADRÃO for\n"
"     especificado, dá ajuda detalhada em todos os comandos que cumpram "
"PADRÃO,\n"
"     senão imprime a lista de tópicos de ajuda.\n"
"     \n"
"     Opções:\n"
"        -d\tmostra uma descrição breve de cada tópico\n"
"        -m\tmostra uso em formato pseudo-manpage\n"
"        -s\tmostra só uma sinopse curta para cada tópico que cumpre\n"
"     \t\tPADRÃO\n"
"     \n"
"     Argumentos:\n"
"        PADRÃO\tPadrão que especifica um tópico de ajuda\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que PADRÃO não seja encontrado ou indique uma "
"opção inválida."

#: builtins.c:842
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Mostra ou manipula a lista do histórico.\n"
"     \n"
"     Mostra a lista do histórico com nºs de linha, prefixando cada entrada\n"
"     modificada com um \"*\". Um argumento de N lista só as últimas N "
"entradas.\n"
"     \n"
"     Opções:\n"
"        -c\tlimpa a lista eliminado todas as entradas\n"
"        -d desvio\telimina a entrada do histórico na posição DESVIO.\n"
"    \t\tDesvios negativos contam-se do final da lista do histórico\n"
"     \n"
"        -a\tacrescenta linhas de histórico desta sessão ao ficheiro de "
"histórico\n"
"        -n\tlê todas as linhas de histórico ainda não lidas do ficheiro de "
"histórico\n"
"     \t\te acrescenta-as à lista de histórico\n"
"        -r\tlê o ficheiro de histórico e acrescenta o conteúdo à lista de\n"
"     \t\thistórico\n"
"        -w\tescreve o histórico actual no ficheiro de histórico\n"
"     \n"
"        -p\trealiza expansão do histórico em cada ARG e mostra o resultado\n"
"     \t\tsem gravar na lista de histórico\n"
"        -s\tacrescenta ARGs à lista de histórico como entrada única\n"
"     \n"
"     Se NOMEFICH for dado, é usado como ficheiro de histórico. Senão,\n"
"     se FICHHIST tiver um valor, será usado, caso contrário ~/."
"bash_history.\n"
"     \n"
"     Se a variável HISTTIMEFORMAT estiver definida e não for nula, o valor é "
"usado\n"
"     como cadeia de formato para strftime(3) para imprimir o carimbo "
"associado\n"
"     a cada entrada de histórico mostrada. Senão, não são imprimidos "
"quaisquer carimbos.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que indique uma opção inválida ou ocorra um "
"erro."

#: builtins.c:879
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Mostra o estado das tarefas.\n"
"     \n"
"     Lista as tarefas activas. JOBSPEC rea cadeiae a saída a essa tarefa.\n"
"     Sem opções, é mostrado o estado de todas as tarefas activas.\n"
"     \n"
"     Opções:\n"
"        -l\tlista IDs de processo além da informação normal\n"
"        -n\tlista só processos com estado alterado desde a última\n"
"     \t\tnotificação\n"
"        -p\tlista só IDs de processo\n"
"        -r\trea cadeiae saída a tarefas em execução\n"
"        -s\trea cadeiae saída a tarefas paradas\n"
"     \n"
"     Se -x for usado, COMANDO é executado após todas as especificações de "
"tarefas\n"
"     que aparecem em ARGS terem sido substituídas pela ID de processo do "
"líder de\n"
"     grupo do processo dessat tarefa.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que indique uma opção inválida ou ocorra um "
"erro.\n"
"     Se -x for usado, devolve o estado de saída de COMANDO."

#: builtins.c:906
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Remove tarefas da consola actual.\n"
"     \n"
"     Remove cada argumento JOBSPEC da tabela de tarefas activas. Sem\n"
"     JOBSPECs, a consola usa a sua noção de tarefa actual.\n"
"     \n"
"     Opções:\n"
"        -a\tremove todas as tarefas se JOBSPEC não for indicado\n"
"        -h\tmarcar cada JOBSPEC para que SIGHUP não seja enviado para a "
"tarefa\n"
"     \t\tse a consola receber um SIGHUP\n"
"        -r\tremove só tarefas em execução\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que uma opção inválida ou JOBSPEC seja "
"indicada."

#: builtins.c:925
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Envia um sinal a uma tarefa.\n"
"     \n"
"     Envia aos processos identificados por PID ou JOBSPEC o sinal chamado\n"
"     SIGSPEC ou SIGNUM. Se nem SIGSPEC nem SIGNUM estiverem presentes,\n"
"     SIGTERM é presumido.\n"
"     \n"
"     Opções:\n"
"        -s sig\tSIG é um nome de sinal\n"
"        -n sig\tSIG é um número de sinal\n"
"        -l\tlista nomes de sinais; se se seguirem argumentos, são\n"
"     \t\tassumidos como nºs de sinal para listar os nomes\n"
"        -L\tsinónimo de -l\n"
"     \n"
"     Mata um interno da consola por dois motivos: permite usar as IDs de "
"tarefa\n"
"     em vez de IDs de processo e permite matar processos se o limite de\n"
"     processos que pode criar for atingido.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que indique uma opção inválida ou ocorra um "
"erro."

#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Avalia as expressões aritméticas.\n"
"     \n"
"     Avalia cada ARG como uma expressão aritmética. A avaliação é feita em\n"
"     inteiros de largura fixa sem verificação de transporte, embora a "
"divisão\n"
"     por 0 seja sinalizada como erro. A seguinte lista de operadores é "
"agrupada\n"
"     em níveis de igual prioridade. Os níveis estão listados\n"
"     por ordem de precedência decrescente.\n"
"     \n"
"     \tid++, id--\tvariável pós-incremento, pós-decremento\n"
"     \t++id, --id\tvariável pré-incremento, pré-decremento\n"
"     \t-, +\t\tmenos, mais unário\n"
"     \t!, ~\t\tnegação lógica e bitwise\n"
"     \t**\t\texponenciação\n"
"     \t*, /, %\t\tmultiplicação, divisão, resto\n"
"     \t+, -\t\tadição, subtracção\n"
"     \t<<, >>\t\tdeslocação esquerda e direita bitwise\n"
"     \t<=, >=, <, >\tcomparação\n"
"     \t==, !=\t\tigualdade, não igualdade\n"
"     \t&\t\tE bitwise\n"
"     \t^\t\tOUEX bitwise\n"
"     \t|\t\tOU bitwise\n"
"     \t&&\t\tE lógico\n"
"     \t||\t\tOU lógico\n"
"     \texpr ? expr : expr\n"
"     \t\t\toperador condicional\n"
"     \t=, *=, /=, %=,\n"
"     \t+=, -=, <<=, >>=,\n"
"     \t&=, ^=, |=\tatribuição\n"
"     \n"
"     As variáveis de consola são permitidas como operandos. O nome da "
"variável\n"
"     é substituído pelo seu valor (convertido em inteiro de largura fixa) "
"dentro\n"
"     de uma expressão. A variável não tem de ter o seu atributo inteiro\n"
"     activado para ser usado numa expressão.\n"
"     \n"
"     Os operadores são avaliados por ordem de precedência. Sub-expressões\n"
"     entre parênteses são avaliadas primeiro e ignoram as regras de\n"
"     precedência acima.\n"
"     \n"
"     Estado de saída:\n"
"     Se o último ARG for avaliado como 0, let devolve 1; senão let devolve 0."

#: builtins.c:994
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters. By default, the backslash character escapes delimiter "
"characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out\n"
"    (in which case it's greater than 128), a variable assignment error "
"occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Lê uma linha da entrada padrão e divide-a em campos.\n"
"     \n"
"     Lê uma linha da entrada padrão ou do descritor de ficheiro FD\n"
"     se a opção -u for usada. A linha é dividida em campos como na divisão\n"
"     de palavras e a primeira palavra é atribuída ao primeiro NOME, a "
"segunda\n"
"     ao segundo NOME, e assim por diante, com quaisquer palavras que "
"sobrem \n"
"     atribuídas ao último NOME. Só caracteres encontrados em $IFS são "
"reconhecidos\n"
"     como delimitadores de palavras.\n"
"     \n"
"     Se não indicar NOMEs, a linha é armazenada na variável RESPONDER.\n"
"     \n"
"     Opções:\n"
"        -a matriz\tatribui as palavras lidas a índices sequenciais da "
"MATRIZ\n"
"     \t\tcomeçando em zero\n"
"        -d delim\tcontinua até que o primeiro carácter de DELIM seja lido, "
"em vez de\n"
"     \t\tnewline\n"
"        -e\tusa Readline para obter a linha numa consola interactiva\n"
"        -i texto\tusa TEXTO como texto inicial para Readline\n"
"        -n ncars\tvolta após ler NCARS caracteres em vez de esperar\n"
"     \t\tpor newline, mas respeita um delimitador se estiver\n"
"     \t\tantes de NCARS caracteres\n"
"        -N ncars\tvolta após ler exactamente NCARS caracteres, a não ser "
"que\n"
"     \t\tEOF seja encontrado ou a leitura esteja inactiva, ignorando\n"
"     \t\tqualquer delimitador\n"
"        -p prompt\timprime PROMPT na saída sem newline final antes de\n"
"     \t\ttentar ler\n"
"        -r\tnão permite que barras esquerdas escapem qualquer carácter\n"
"        -s\tnão ecoa entradas vindas de um terminal\n"
"        -t inacção\tesgota o tempo e devolve falha se uma linha completa\n"
"     \t\tde entrada não for lida em INACÇÃO segundos. O valor da\n"
"     \t\tvariável TMOUT é o predefinido de inacção. INACÇÃO pode ser\n"
"     \t\tuma fracção. Se INACÇÃO for 0, read volta\n"
"     \t\timediatamente, sem tentar ler quaisquer dados, devolvendo\n"
"     \t\tsucesso só se a entrada estiver disponível no descritor de\n"
"     \t\tficheiro especificado. O estado de saída é maior que 128\n"
"     \t\tse a inacção for excedida\n"
"        -u fd\tlê do descritor de ficheiro FD em vez da entrada padrão\n"
"     \n"
"     Estado de saída:\n"
"     O código devolvido é zero, a não ser que end-of-file seja encontrado, "
"haja\n"
"     inacção (caso em que é maior que 128), ocorra um erro de atribuição de "
"variável,\n"
"     ou seja indicado um descritor de ficheiro inválido como argumento de -u."

#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Volta de uma função de consola.\n"
"     \n"
"     Força a saída de uma função ou script baseado com o valor especificado\n"
"     por N. Se N for omitido, o estado de saída é o do último comando\n"
"     executado dentro da função ou script.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve N, ou falha se a consola não estiver a executar uma função ou "
"script."

#: builtins.c:1055
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell "
"functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Define ou limpa valores de opções ou parâmetros posicionais da consola.\n"
"     \n"
"     Altera o valor de atributos ou parâmetros posicionais da consola, ou\n"
"     mostra os nomes e valores de variáveis da consola.\n"
"     \n"
"     Opções:\n"
"        -a  Marca variáveis modificadas ou criadas para exportação.\n"
"         -b Notifica o fim da tarefa imediatamente.\n"
"         -e Sai imediatamente se um comando sair com estado diferente de "
"zero.\n"
"         -f Desactiva geração de nome de ficheiro (globbing).\n"
"         -h Recordar localização de comandos à medida que são procurados.\n"
"         -k Todos os argumentos de atribuição são colocados no ambiente para "
"um\n"
"             comando, não só os que precedem o nome do comando.\n"
"         -m Activa o controlo de tarefas.\n"
"         -n Lê comandos, mas não os executa.\n"
"         -option-name\n"
"             Define a variável correspondente a option-name:\n"
"                  allexport     igual a -a\n"
"                  braceexpand  igual a -B\n"
"                  emacs          usa estilo emacs de edição de linhas\n"
"                  errexit        igual a -e\n"
"                  errtrace      igual a -E\n"
"                  functrace     igual a -T\n"
"                  hashall        igual a -h\n"
"                  histexpand    igual a -H\n"
"                  history        activa histórico de comandos\n"
"                  ignoreeof     a consola não sai após ler EOF\n"
"                  interactive-comments\n"
"                                    permite que comentários apareçam em "
"comandos interactivos\n"
"                  keyword        igual a -k\n"
"                  monitor        igual a -m\n"
"                  noclobber     igual a -C\n"
"                  noexec         igual a -n\n"
"                  noglob         igual a -f\n"
"                  nolog          actualmente aceite mas ignorado\n"
"                  notify         igual a -b\n"
"                  nounset        igual a -u\n"
"                  onecmd         igual a -t\n"
"                  physical      igual a -P\n"
"                  pipefail      o valor devolvido de um pipeline é o estado "
"do\n"
"                                    último comando a sair com estado não-"
"zero,\n"
"                                    ou zero se nenhum saiu com estado não-"
"zero\n"
"                  posix          altera o comportamento do bash onde a "
"operação\n"
"                                    predefinida diferir da norma Posix para "
"cumprir\n"
"                                    a norma\n"
"                  privileged    igual a -p\n"
"                  verbose        igual a -v\n"
"                  vi              usa estilo vi de edição de linhas\n"
"                  xtrace         igual a -x\n"
"        -p  Activado sempre que as ID de utilizador reais e efectivas não\n"
"             coincidam. Desactiva o processamento do ficheiro $ ENV e a \n"
"             importação de funções da consola. Desligar esta opção faz com\n"
"             que os uid e gid efectivos sejam definidos para os uid e gid "
"reais.\n"
"        -t  Sair depois de ler e executar um comando.\n"
"        -u  Trata as variáveis ​​não definidas como erro ao substituir.\n"
"        -v  Imprime as linhas de entrada da consola à medida que são lidas.\n"
"        -x  Imprime comandos e seus argumentos à medida que são executados.\n"
"        -B  a consola realizará expansão de suporte\n"
"        -C  Se definido, não permitir que ficheiros normais existentes "
"sejam\n"
"             sobrescritos pelo redireccionamento da saída.\n"
"        -E  se definido, ERR é herdada pelas funções de consola.\n"
"        -H  Activa estilo ! de substituição do histórico. Esta bandeira\n"
"             está activada por predefinição, em consolas interativas.\n"
"        -P  Se definido, não resolve ligações simbólicas ao executar\n"
"             comandos como \"cd\" que altera a pasta actual.\n"
"        -T  Se definido, DEBUG e RETURN são herdadas por funções de "
"consola.\n"
"        --  Atribui quaisquer outros argumentos aos parâmetros posicionais.\n"
"             Se não houver mais argumentos, os parâmetros posicionais\n"
"             são limpos.\n"
"        -    Atribui quaisquer outros argumentos aos parâmetros "
"posicionais.\n"
"             As opções -x e -v são desactivadas.\n"
"     \n"
"     Usar + em vez de - faz com que as bandeiras sejam desactivadas. As\n"
"     bandeiras também podem ser usadas por chamada da consola. O actual\n"
"     conjunto de bandeiras pode ser encontrado em $-. Os n restantes ARGs\n"
"     são parâmetros posicionais e são atribuídos, em ordem, a $1, $2 .. $n.\n"
"     Se não houver ARGs, todas as variáveis de consola são imprimidas.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que indique uma opção inválida."

#: builtins.c:1140
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Limpa valores e atributos de variáveis e funções da consola.\n"
"     \n"
"     Para cada NOME, remove a correspondente variável ou função.\n"
"     \n"
"     Opções:\n"
"        -f\ttrata cada NOME como função de consola\n"
"        -v\ttrata cada NOME como variável de consola\n"
"        -n\ttrata cada NOME como referência de nome e limpa a própria\n"
"     \t\tvariável em vez da variável que referencia\n"
"     \n"
"     Sem opções, unset primeiro tenta limpar uma variável e, se falhar,\n"
"     tenta limpar uma função.\n"
"     \n"
"     Algumas variáveis não podem ser limpas; veja também \"readonly\".\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que indique uma opção inválida ou NOME seja "
"só de leitura."

#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Define o atributo de exportação em variáveis de consola.\n"
"     \n"
"     Marca cada NOME para exportação automática para o ambiente de futuros\n"
"     comandos executados. Se VALOR for fornecido, atribui VALOR antes de "
"exportar.\n"
"     \n"
"     Opções:\n"
"        -f\trefere funções de consola\n"
"        -n\tremove a propriedade de exportação de cada NOME\n"
"        -p\tmostra uma lista de todas as funções e variáveis exportadas\n"
"     \n"
"     Um argumento \"--\" desactiva futuro processamento da opção.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que indique uma opção inválida ou NOME seja "
"inválido."

#: builtins.c:1181
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marca as variáveis de consola como imutáveis.\n"
"     \n"
"     Marca cada NOME como só de leitura; os valores destes NOMEs não podem\n"
"     ser alterados por subsequentes atribuições. Se VALOR for fornecido,\n"
"     atribui VALOR antes de marcar como só de leitura.\n"
"    \n"
"     Opções:\n"
"        -a\trefere a variáveis de matriz indexadas\n"
"        -A\trefere a variáveis de matriz associativas\n"
"        -f\trefere a funções de consola\n"
"        -p\tmostra uma lista de todas as variáveis ou funções só de "
"leitura,\n"
"     \t\tdependendo ou não se a opção -f é indicada\n"
"     \n"
"     Um argumento \"--\" desactiva futuro processamento da opção.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que indique uma opção inválida ou NOME seja "
"inválido."

#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Deslocar parâmetros posicionais.\n"
"     \n"
"     Renomear os parâmetros posicionais $N+1,$N+2 ... para $1,$2 ... Se N\n"
"     for omitido, presume-se como 1.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que N seja negativo ou maior que $#."

#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Executa comandos de um ficheiro na consola actual.\n"
"     \n"
"     Lê e execute comandos do NOMEFICH na consola actual. As\n"
"     entradas em $PATH são usadas para encontrar a pasta contendo NOMEFICH.\n"
"     Se nenhum ARGUMENTO for fornecido,tornam-se parâmetros posicionais\n"
"     quando NOMEFICH é executado.\n"
"    \n"
"     Estado de saída:\n"
"     Devolve o estado do último comando executado em NOMEFICH; falha se\n"
"     NOMEFICH não pode ser lido."

#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Suspende a execução da consola.\n"
"     \n"
"     Suspende a execução desta consola até receber um sinal SIGCONT.\n"
"     Se não forem forçadas, as consolas com sessão não podem ser suspensas.\n"
"     \n"
"     Opções:\n"
"        -f\tforçar a suspensão, mesmo que seja uma consola com sessão\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que o controlo de tarefa esteja inactivo ou "
"ocorra um erro."

#: builtins.c:1262
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Avalia a expressão condicional.\n"
"     \n"
"     Sai com estado 0 (verdadeiro) ou 1 (falso) dependendo da\n"
"     avaliação de EXPR. As expressões podem ser unárias ou binárias. "
"Expressões\n"
"     uinárias são frequentemente usadas para examinar o estado de um "
"ficheiro. Há\n"
"     também operadores de cadeias e operadores de comparação numérica.\n"
"     \n"
"     O comportamento do teste depende do número de argumentos. Leia a\n"
"     página do manual do bash para a especificação completa.\n"
"     \n"
"     Operadores de ficheiros:\n"
"     \n"
"        -a FICHEIRO     Verdadeiro se o ficheiro existir.\n"
"        -b FICHEIRO     Verdadeiro se o ficheiro for bloqueio especial.\n"
"        -c FICHEIRO     Verdadeiro se o ficheiro for especial de "
"caracteres.\n"
"        -d FICHEIRO     Verdadeiro se o ficheiro for uma pasta.\n"
"        -e FICHEIRO     Verdadeiro se o ficheiro existir.\n"
"        -f FICHEIRO     Verdadeiro se o ficheiro existe e é um ficheiro "
"normal.\n"
"        -g FICHEIRO     Verdadeiro se o ficheiro for set-group-id.\n"
"        -h FICHEIRO     Verdadeiro se o ficheiro for uma ligação simbólica.\n"
"        -L FICHEIRO     Verdadeiro se o ficheiro for uma ligação simbólica.\n"
"        -k FICHEIRO     Verdadeiro se o ficheiro tiver o bit \"sticky\" "
"definido.\n"
"        -p FICHEIRO     Verdadeiro se o ficheiro for um pipe com nome.\n"
"        -r FICHEIRO     Verdadeiro se o ficheiro for legível.\n"
"        -s FICHEIRO     Verdadeiro se o ficheiro existe e não está vazio.\n"
"        -S FICHEIRO     Verdadeiro se o ficheiro for um socket.\n"
"        -t FD             Verdadeiro se FD for aberto num terminal.\n"
"        -u FICHEIRO     Verdadeiro se o ficheiro for set-user-id.\n"
"        -w FICHEIRO     Verdadeiro se o ficheiro for gravável por si.\n"
"        -x FICHEIRO     Verdadeiro se o ficheiro for executável por si.\n"
"        -O FICHEIRO     Verdadeiro se o ficheiro for efectivamente sua "
"propriedade.\n"
"        -G FICHEIRO     Verdadeiro se o ficheiro for efectivamente "
"propriedade do seu grupo.\n"
"        -N FICHEIRO     Verdadeiro se o ficheiro foi modificado desde a "
"última vez que foi lido.\n"
"     \n"
"         FICHEIRO1 -nt FICHEIRO2 Verdadeiro se o ficheiro1 for mais novo "
"que\n"
"                                         o ficheiro2 (de acordo com a data "
"de modificação).\n"
"     \n"
"         FICHEIRO1 -ot FICHEIRO2 Verdadeiro se ficheiro1 for mais antigo que "
"o ficheiro2.\n"
"     \n"
"         FICHEIRO1 -ef FICHEIRO2 Verdadeiro se ficheiro1 for uma ligação "
"rígida a file2.\n"
"     \n"
"     Operadores de cadeias:\n"
"     \n"
"         -z CADEIA        Verdadeiro se a cadeia estiver vazia.\n"
"     \n"
"         -n CADEIA\n"
"             CADEIA        Verdadeiro se a cadeia não estiver vazia.\n"
"     \n"
"         CADEIA1 = CADEIA2\n"
"                             Verdadeiro se as cadeias são iguais.\n"
"         CADEIA1 != CADEIA2\n"
"                             Verdadeiro se as cadeias não são iguais.\n"
"         CADEIA1 < CADEIA2\n"
"                             Verdadeiro se CADEIA1 ficar antes de CADEIA2 "
"lexicamente.\n"
"         CADEIA1 > CADEIA2\n"
"                             Verdadeiro se CADEIA1 ficar após CADEIA2 "
"lexicamente.\n"
"     \n"
"     Outros operadores:\n"
"     \n"
"        -o OPÇÃO         Verdadeiro se a opção de consola OPÇÃO está "
"activada.\n"
"        -v VAR            Verdadeiro se a variável de consola VAR estiver "
"definida.\n"
"        -R VAR            Verdadeiro se a variável de consola VAR estiver "
"definida e for um nome\n"
"                            referência.\n"
"        ! EXPR            Verdadeiro se EXPR for falso.\n"
"        EXPR1 -a EXPR2 Verdadeiro se EXPR1 e EXPR2 forem verdadeiros.\n"
"        EXPR1 -o EXPR2 Verdadeiro se EXPR1 OU EXPR2 forem verdadeiros.\n"
"     \n"
"        arg1 OP arg2    Testes aritméticos. OP é um de -eq, -ne,\n"
"                           -lt, -le, -gt, ou -ge.\n"
"     \n"
"     Operadores binários aritméticos devolvem verdadeiro se ARG1 for igual, "
"não\n"
"     igual, menor que, menor ou igual que, maior que ou maior ou igual que\n"
"     ARG2.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso se EXPR for avaliada como verdadeiro; falha se EXPR "
"for\n"
"     avaliado como falso ou for indicado um argumento inválido."

#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Avalia uma expressão condicional.\n"
"     \n"
"     Este é um sinónimo para o interno \"test\", mas o último argumento tem\n"
"     de ser um \"]\" literal, para fechar o \"[\" aberto."

#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Mostrar tempos de processo.\n"
"     \n"
"     Imprime os tempos acumulados de utilizador e sistema para a consola e "
"todos\n"
"     os seus processos-filho.\n"
"     \n"
"     Estado de saída:\n"
"     Sempre com sucesso."

#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  "
"If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or "
"a\n"
"    script run by the . or source builtins finishes executing.  A "
"SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause "
"the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""
"Capturar sinais e outros eventos.\n"
"     \n"
"     Define e activa gestores a executar quando a consola recebe sinais ou\n"
"     outras condições.\n"
"     \n"
"     ARG é um comando a ser lido e executado quando a consola recebe o(s)\n"
"     sinal(is) SIGNAL_SPEC. Se ARG estiver ausente (e um único SIGNAL_SPEC\n"
"     for fornecido) ou \"-\", cada sinal especificado é reposto no seu "
"valor\n"
"     original. Se ARG for a cadeia nula, cada SIGNAL_SPEC será ignorado\n"
"     pela consola e pelos comandos que chama.\n"
"     \n"
"     Se um SIGNAL_SPEC for EXIT (0) ARG é executado na saída da consola. Se\n"
"     SIGNAL_SPEC é DEBUG, ARG é executado antes de cada comando simples. Se\n"
"     SIGNAL_SPEC é RETURN, ARG é executado cada vez que uma função de "
"consola\n"
"     ou um script executado pelo . ou os internos terminam a execução. "
"SIGNAL_SPEC\n"
"     de ERR significa executar ARG cada vez que uma falha do comando faça "
"com\n"
"     que a consola sair quando a opção -e está activa.\n"
"     \n"
"     Se nenhum argumento for fornecido, trap imprime a lista de comandos \n"
"     associados a cada sinal.\n"
"     \n"
"     Opções:\n"
"        -l imprime uma lista de nomes de sinais e seus números "
"correspondentes\n"
"        -p mostra os comandos trap associados a cada SIGNAL_SPEC\n"
"     \n"
"     Cada SIGNAL_SPEC é um nome de sinal em <signal.h> ou um número de "
"sinal.\n"
"     Os nomes dos sinais são insensíveis a maiúsculas e o prefixo SIG é "
"opcional.\n"
"     Um sinal pode ser enviado para a consola com \"kill -signal $$\".\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que SIGSPEC seja inválido ou indique uma "
"opção inválida."

#: builtins.c:1401
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""
"Mostra informações sobre o tipo de comando.\n"
"     \n"
"     Para cada NOME, indica como seria interpretado se usado como um\n"
"     nome de comando.\n"
"     \n"
"     Opções:\n"
"        -a\tmostra todos os locais contendo um executável chamado NOME;\n"
"     \t\tinclui aliás, internos e funções, se e só se a opção \"-p\"\n"
"     \t\ttambém não for usada\n"
"        -f\tsuprime a procura da função de consola\n"
"        -P\tforça uma procura em PATH para cada NOME, mesmo que seja um\n"
"     \t\taliás, interno ou função e devolve o nome do ficheiro em disco\n"
"     \t\tque seria executado\n"
"        -p\tdevolve o nome do ficheiro em disco que seria executado,\n"
"     \t\tou nada se \"type -t NOME\" não devolver \"file\"\n"
"        -t\tdevolve uma só palavra de entre \"alias\", \"keyword\", "
"\"function\"\n"
"     \t\t\"builtin\", \"file\" ou \"\", se NOME for um aliás, palavra "
"reservada\n"
"     \t\tda consola, função de consola, interno da consola, ficheiro em\n"
"     \t\tdisco, ou não encontrados, respectivamente\n"
"     \n"
"     Argumentos:\n"
"        Nome do comando NOME a interpretar.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso se todos os NOMEs forem encontrados; falha se algum não "
"for."

#: builtins.c:1432
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modifica os limites de recursos da consola.\n"
"     \n"
"     Fornece controlo sobre os recursos disponíveis para consola e "
"processos\n"
"     que cria, em sistemas que permitem esse controlo.\n"
"     \n"
"     Opções:\n"
"        -S\tusa o limite de recursos \"soft\"\n"
"        -H\tusa o limite de recursos \"hard\"\n"
"        -a\ttodos os limites actuais são relatados\n"
"        -b\to tamanho do buffer de socket\n"
"        -c\to tamanho máximo dos ficheiros núcleo criados\n"
"        -d\to tamanho máximo do segmento de dados de um processo\n"
"        -e\ta prioridade máxima de agendamento (\"nice\")\n"
"        -f\to tamanho máximo dos ficheiros escritos pela consola e seus "
"filhos\n"
"        -i\to número máximo de sinais pendentes\n"
"        -k\to número máximo de kqueues alocados para este processo\n"
"        -l\to tamanho máximo que um processo pode bloquear na memória\n"
"        -m\to tamanho máximo do conjunto residente\n"
"        -n\to número máximo de descritores de ficheiros abertos\n"
"        -p\to tamanho do buffer do pipe\n"
"        -q\to número máximo de bytes nas filas de mensagens POSIX\n"
"        -r\ta prioridade máxima de agendamento em tempo real\n"
"        -s\to tamanho máximo da pilha\n"
"        -t\ta quantidade máxima de tempo de CPU em segundos\n"
"        -u\to número máximo de processos do utilizador\n"
"        -v\to tamanho da memória virtual\n"
"        -x\to número máximo de bloqueios de ficheiros\n"
"        -P\to número máximo de pseudo-terminais\n"
"      -R\to tempo máximo que um processo em tempo real pode executar antes "
"de bloquear\n"
"        -T\to número máximo de threads\n"
"     \n"
"     Nem todas as opções estão disponíveis em todas as plataformas.\n"
"     \n"
"     Se LIMIT for indicada, é o novo valor do recurso especificado; Os\n"
"     valores LIMIT especiais \"soft\", \"hard\" e \"unlimited\" representam\n"
"     o limite flexível actual, o limite rígido actual e nenhum limite, "
"respectivamente.\n"
"     Caso contrário, é imprimido o valor actual do recurso especificado. Se\n"
"     nenhuma opção for indicada, então -f é assumido.\n"
"     \n"
"     Os valores estão em incrementos de 1024 bytes, exceto para -t, que é em "
"segundos,\n"
"     -p, que é em incrementos de 512 bytes e -u, que é um número de "
"processos\n"
"     sem escala.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que seja indicada uma opção inválida ou "
"ocorra um erro."

#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Mostrar ou definir a máscara do modo de ficheiro.\n"
"     \n"
"     Define a máscara do utilizador de criação de ficheiro para MODO. Se "
"MODO\n"
"     for omitido, imprime o valor actual da máscara.\n"
"     \n"
"     Se MODO começa com um dígito, é interpretado como um número octal;\n"
"     caso contrário, é uma cadeia de modo simbólico como a aceite por "
"chmod(1).\n"
"     \n"
"     Opções:\n"
"        -p\tse MODO for omitido, saída de forma a que possa ser reutilizado "
"como entrada\n"
"        -S\ttorna a saída simbólica; caso contrário, a saída é um número "
"octal\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que MODO seja inválido ou indique uma opção "
"inválida."

#: builtins.c:1503
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or "
"a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of "
"IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns "
"its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, "
"before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Aguarda a conclusão da tarefa e devolve o estado de saída.\n"
"     \n"
"     Espera por cada processo identificado por uma ID, que pode ser uma ID "
"de\n"
"     processo ou uma especificação de tarefa e relata o estado final. Se "
"não\n"
"     for dada uma ID, aguarda por todos os processos-filho actualmente "
"activos e o\n"
"     estado de saída é zero. Se ID for uma especificação de tarefa, espera "
"por\n"
"     todos os processos no pipeline da tarefa.\n"
"     \n"
"     Se a opção -n for fornecida, espera por uma tarefa única da lista de "
"IDs ou\n"
"     se não indicar IDs, pela conclusão da tarefa seguinte devolve\n"
"     o seu estado de saída.\n"
"     \n"
"    Se a opção -p for indicada, o identificador de processo ou tarefa da "
"tarefa\n"
"    para a qual foi devolvido o estado de saída é atribuído à variável VAR\n"
"    nomeada pelo argumento da opção. A variável estará indefinida "
"inicialmente,\n"
"    antes de qualquer atribuição. Útil só quando a opção -n é indicada.\n"
"    \n"
"    Se a opção -f for indicada e o controlo de tarefas estiver activo, "
"espera que\n"
"    a ID especificada termine, em vez de esperar por uma alteração de "
"estado.\n"
"    \n"
"     Estado de saída:\n"
"     Devolve o estado da última ID; falha se a ID for inválida ou for "
"indicada\n"
"     uma opção inválida, ou se -n for indicada e a consola não tiver filhos\n"
"     inesperados."

#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination "
"status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an "
"invalid\n"
"    option is given."
msgstr ""
"Aguarda a conclusão do processo e devolve o estado de saída.\n"
"     \n"
"     Espera por cada processo especificado por uma PID e reporta o estado "
"final.\n"
"     Se PID não for dada, aguarda por todos os processos-filho actualmente "
"activos,\n"
"     e o estado devolvido é zero. A PID tem de ser uma ID de processo.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado da última PID; falha se PID for inválido ou for "
"indicada\n"
"     uma opção inválida."

#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executa comandos para cada membro numa lista.\n"
"     \n"
"     O ciclo \"for\" executa uma seqüência de comandos para cada membro "
"numa\n"
"     lista de itens. Se \"in PALAVRAS ...;\" não estiver presente, \" in \"$@"
"\" \" é\n"
"     assumido. Para cada elemento em PALAVRAS, NOME está definido para "
"esseelemento,\n"
"     e os COMANDOS são executados.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado do último comando executado."

#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ciclo for aritmético.\n"
"     \n"
"     Equivalente a\n"
"     \t(( EXP1 ))\n"
"     \twhile (( EXP2 )); do\n"
"     \t\tCOMANDOS\n"
"     \t\t(( EXP3 ))\n"
"     \tdone\n"
"     EXP1, EXP2 e EXP3 são expressões aritméicas. Se alguma delas for "
"omitida\n"
"     comporta-se como se fosse avaliada como 1.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado do último comando executado."

#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Selecciona palavras de uma lista e executa comandos.\n"
"     \n"
"     As PALAVRAS são expandidas, gerando uma lista de palavras. O\n"
"     conjunto de palavras expandidas é imprimido no erro padrão, cada\n"
"     um precedido por um número. Se \"in PALAVRAS\" não estiver presente,\n"
"     \" in \"$@\" \" é assumido. O prompt PS3 é então exibido e é lida uma\n"
"     linha da entrada padrão. Se a linha for constituída pelo número\n"
"     correspondente a uma das palavras mostradas, NOME é definido para\n"
"     essa palavra. Se a linha estiver vazia, PALAVRAS e o prompt são\n"
"     mostrados de novo. Se for lido EOF, o comando é concluído. Qualquer\n"
"     outro valor lido faz com que NOME seja definido como nulo. A linha\n"
"     lida é gravada na variável RESPOSTA. COMANDOS são executados após cada\n"
"     selecção até que um comando de interrupção seja executado.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado do último comando executado."

#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Reporta o tempo consumido pela execução do pipeline.\n"
"     \n"
"     Executa PIPELINE e imprime um resumo do tempo real, tempo de CPU do,\n"
"     utilizador e tempo de CPU do sistema na execução de PIPELINE quando "
"terminar.\n"
"     \n"
"     Opções:\n"
"        -p\timprime o resumo do tempo no formato portátil Posix\n"
"    \n"
"     O valor da variável FORMATOTEMPO é usado como formato de saída.\n"
"    \n"
"     Estado de saída:\n"
"     O estado devolvido é o estado de PIPELINE."

#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executea comandos baseado em comparação de padrões.\n"
"     \n"
"     Executar selectivamente COMANDOS baseado na comparação entre PALAVRA e\n"
"     PADRÃO. \"|\" é usado para separar múltiplos padrões.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado do último comando executado."

#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executa comandos com base em condicional.\n"
"     \n"
"     A lista \"if COMANDOS\" é executada. Se o estado de saída for zero, é\n"
"     executada a lista \"then COMANDOS\". Caso contrário, cada lista \"elif "
"COMANDOS\"\n"
"     é executado por sua vez e se o estado de saída for zero, a "
"correspondente\n"
"     lista \"then COMANDOS\" é executada e o comando if é concluído. De "
"outra forma,\n"
"     a lista \"else COMANDOS\" é executada, se presente. O estado de saída "
"da\n"
"     construção inteira é o estado de saída do último comando executado, ou "
"zero\n"
"     se nenhuma condição for verdadeira.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado do último comando executado."

#: builtins.c:1648
#, fuzzy
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executa comandos enquanto o teste tiver sucesso.\n"
"     \n"
"     Expande e executa COMANDOS enquanto o comando final no ciclo\n"
"     \"while COMANDOS\" tenha um estado de saída zero.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado do último comando executado."

#: builtins.c:1660
#, fuzzy
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Executa comandos enquanto o teste não tiver sucesso.\n"
"     \n"
"     Expande e executa COMANDOS enquanto o comando final no ciclo\n"
"     \"until COMANDOS\" tenha um estado de saída não zero.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado do último comando executado."

#: builtins.c:1672
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Cria um co-processo chamado NOME.\n"
"     \n"
"     Executa COMANDO assincronamente, com a saída e a entrada padrão "
"ligadas\n"
"     via pipe a descritores de ficheiro atribuídos a índices 0 e 1 de uma \n"
"     variável de matriz NOME na consola em execução.\n"
"     O NOME predefinido é \"COPROC\".\n"
"     \n"
"     Estado de saída:\n"
"     O comando coproc devolve um estado de saída 0."

#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Define uma função de consola.\n"
"     \n"
"     Cria uma função de consola chamada NOME. Quando chamado como comando\n"
"     simples, NOME executa COMANDOs no contexto da consola. Quando NOME é\n"
"     invoked, os argumentos são passados à função como $1...$n e o nome da\n"
"     função está em $FUNCNAME.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que NOME seja só de leitura."

#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Agrupa comandos como uma unidade.\n"
"     \n"
"     Executa um conjunto de comandos num grupo. Esta é uma maneira de\n"
"     redireccionar um conjunto completo de comandos.\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado do último comando executado."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Retoma a tarefa em primeiro plano.\n"
"     \n"
"     Equivalente ao argumento JOB_SPEC para o comando \"fg\". Retoma uma\n"
"     tarefa parada ou em 2º plano. JOB_SPEC pode especificar um nome de\n"
"     tarefa ou um número de tarefa. Pôr \"&\" a seguir a JOB_SPEC coloca a\n"
"     tarefa em 2º plano, como se a especificação da tarefa tivesse sido\n"
"     fornecida como um argumento para \"bg\".\n"
"     \n"
"     Estado de saída:\n"
"     Devolve o estado da tarefa retomada."

#: builtins.c:1727
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Avalia uma expressão aritmética.\n"
"     \n"
"     A expressão EXPRESSÃO é avaliada de acordo com as regras\n"
"     de avaliação aritmética. Equivalente a \"let \"EXPRESSÃO\"\"\n"
"     Equivalente a \"let EXPRESSÃO\".\n"
"     \n"
"     Estado de saída:\n"
"     Devolve 1 se EXPRESSÃO avaliar como 0; senão, devolve 0."

#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Executa o comando condicional.\n"
"     \n"
"     Devolve um estado de 0 ou 1, dependendo da avaliação da expressão\n"
"     condicional EXPRESSÃO. As expressões são compostas pelas mesmas "
"primárias\n"
"     usadas pelo interno \"test\" e pode ser combinado com os seguintes "
"operadores:\n"
"     \n"
"        ( EXPRESSÃO )\tDevolve o valor de EXPRESSÃO\n"
"        ! EXPRESSÃO\t\tVerdadeiro se EXPRESSÃO for falsa; senão falso\n"
"        EXPR1 && EXPR2\tVerdadeiro se EXPR1 e EXPR2 forem verdadeiras; senão "
"falso\n"
"        EXPR1 || EXPR2\tVerdadeiro se EXPR1 ou EXPR2 forem verdadeiras; "
"senão falso\n"
"     \n"
"     Quando os operadores \"==\" e \"! =\" são usados, a cadeia à direita do "
"operador\n"
"     é usada como padrão e é feita a comparação de padrões. Quando o "
"operador \"= ~\"\n"
"     é usado, a cadeia à direita do operador é comparada como expressão "
"regular.\n"
"     \n"
"     Os operadores && e || não avaliam EXPR2 se EXPR1 for suficiente para\n"
"     determinar o valor da expressão."

#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nomes e uso comuns de variáveis de consola.\n"
"    \n"
"    BASH_VERSION\tInformações de versão para esta bash.\n"
"    CDPATH\tUma lista de pastas separadas por \":\" para procurar\n"
"    \t\tpor pastas dadas como argumentos a \"cd\".\n"
"    GLOBIGNORE\tUma lista de padrões separada por \":\" que descreve nomes "
"de\n"
"    ficheiro a ignorar pela expansão do nome do caminho.\n"
"    HISTFILE\tNome de ficheiro onde o seu histórico de comandos é "
"armazenado.\n"
"    HISTFILESIZE\tNúmero máximo de linhas que este ficheiro pode conter.\n"
"    HISTSIZE\tNúmero máximo de linhas de histórico a que uma consola em \n"
"    \t\texecução pode aceder.\n"
"    HOME\tNome completo do caminho para a pasta de início de sessão.\n"
"    HOSTNAME\tNome do anfitrião actual.\n"
"    HOSTTYPE\tTipo de CPU em que esta versão do Bash está em execução.\n"
"    IGNOREEOF\tControla a acção da consola ao receber um carácter EOF\n"
"    \t\tcomo única entrada. Se definido, então o seu valor é o\n"
"    \t\tnúmero de caracteres EOF que podem ser vistos numa linha\n"
"    \t\tvazia antes que a consola saia (predefinição 10).\n"
"    \t\tQuando não definido, EOF significa o fim da entrada.\n"
"    MACHTYPE\tDescrição do sistema actual em que a bash está em execução.\n"
"    MAILCHECK\tFrequência, em segundos, com que a bash procura novo "
"correio.\n"
"    MAILPATH\tLista de ficheiros separados por \":\" onde a bash procura\n"
"    \t\tnovas mensagens.\n"
"    OSTYPE\tVersão Unix em que esta versão da bash está em execução.\n"
"    PATH\tLista de pastas separadas por \":\" a procurar quando\n"
"    \t\tprocura comandos.\n"
"    PROMPT_COMMAND\tComando a executar antes da impressão de cada\n"
"    \t\tprompt primário.\n"
"    PS1\t\tCadeia do prompt primário.\n"
"    PS2\t\tCadeia do prompt secundário\n"
"    PWD\t\tCaminho completo da pasta actual.\n"
"    SHELLOPTS\tLista separada por \":\" de opções da consola activadas.\n"
"    TERM\tNome do tipo de terminal actual.\n"
"    TIMEFORMAT\tFormato de saída para estatísticas de tempo mostradas\n"
"    pela palavra reservada \"time\".\n"
"    auto_resume\tNão-nulo significa que uma palavra de comando numa linha\n"
"    \t\tpor si só é procurada primeiro na lista de tarefas actualmente\n"
"    \t\tparadas. Se encontrado, a tarefa passa a primeiro plano. Um\n"
"    \t\tvalor \"exact\" significa que a palavra de comando deve ser\n"
"    \t\texactamente igual a um comando na lista de tarefas paradas.\n"
"    \t\t\"substring\" significa que a palavra de comando deve ser igual\n"
"    \t\ta uma sub-cadeia da tarefa. Qualquer outro valor significa que\n"
"    \t\to comando deve ser um prefixo de uma tarefa interrompida.\n"
"    histchars\tCaracteres que controlam a expansão do histórico e "
"substituições\n"
"    \t\trápidas. O primeiro carácter é o carácter de subtituição do\n"
"    \t\thistórico, normalmente \"!\". O 2º é o de substituição rápida,\n"
"    \t\thabitualmente \"^\". O terceiro é o comentário do histórico,\n"
"    \t\tnormalmente \"#\".\n"
"    HISTIGNORE\tLista de padrões separada por \":\" usados para decidir "
"quais\n"
"    \t\tos comandos que devem ser gravados na lista de histórico.\n"

#: builtins.c:1822
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Adiciona pastas à pilha.\n"
"    \n"
"    Adiciona uma pasta ao topo da pilha de pastas, ou roda a pilha\n"
"    tornando o novo topo da pilha a actual pasta de trabalho.\n"
"    Sem argumentos, troca as duas pastas de topo.\n"
"    \n"
"    Opções:\n"
"      -n\tSuprime a alteração normal de pasta ao adicionar\n"
"    pastas à pilha, para que só a pilha seja manipulada.\n"
"    \n"
"    Argumentos:\n"
"      +N\tRoda a pilha de modo a que a N-ésima pasta (contando\n"
"    \t\tda esquerda da lista mostrada por \"dirs\", começando por\n"
"    \t\tzero) fique no topo.\n"
"    \n"
"      -N\tRoda a pilha de modo a que a N-ésima pasta (contando\n"
"    \t\tda direita da lista mostrada por \"dirs\", começando por\n"
"    \t\tzero) fique no topo.\n"
"    \n"
"      dir\tAdiciona DIR à pilha de pastas no topo, tornando-a a\n"
"    \t\tnova pasta de trabalho actual.\n"
"    \n"
"    O interno \"dirs\" mostra a pilha de pastas.\n"
"    \n"
"    Estado de saída:\n"
"    Devolve sucesso a não ser que indique um argumento inválido ou a\n"
"    troca de pastas falhe."

#: builtins.c:1856
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Remove pastas da pilha.\n"
"    \n"
"    Remove entradas da pilha de pastas. Sem argumentos, remove\n"
"    a pasta do topo da pilha e muda para a nova pasta superior.\n"
"    \n"
"     Opções:\n"
"       -n\tSuprime a alteração normal de pasta ao remover\n"
"     \t\tpastas da pilha, para que só a pilha seja manipulada.\n"
"    \n"
"     Argumentos:\n"
"       +N\tRemove a N-ésima entrada contando da esquerda da lista\n"
"    \t\tmostrada por \"dirs\", começando por zero. E.g.: \"popd +0\"\n"
"    \t\tremove a primeira pasta, \"popd +1\" a segunda.\n"
"    \n"
"       -N\tRemove a N-ésima entrada contando da direita da lista\n"
"    \t\tmostrada por \"dirs\", começando por zero. E.g.: \"popd -0\"\n"
"    \t\tremove a última pasta, \"popd -1\" a penúltima.\n"
"    \n"
"     O interno \"dirs\" mostra a pilha de pastas.\n"
"    \n"
"     Estado de saída:\n"
"     Devolve sucesso a não ser que indique um argumento inválido ou a troca\n"
"     de pastas falhe."

#: builtins.c:1886
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Mostra a pilha de pastas.\n"
"    \n"
"    Mostra a lista de pastas actualmente lembradas. As pastas\n"
"    entram na lista com o comando \"pushd\"; pode recuar na\n"
"    lista com o comando \"popd\".\n"
"    \n"
"    Opções:\n"
"      -c\tlimpa a pilha de pastas eliminando todos os elementos\n"
"      -l\tnão imprime versões prefixadas com til de pastas relativas\n"
"    \t\tà sua pasta inicial\n"
"      -p\timprime a pilha de pastas com uma entrada por linha\n"
"      -v\timprime a pilha de pastas com uma entrada por linha prefixada\n"
"    \t\tcom a sua posição na pilha\n"
"    \n"
"    Argumentos:\n"
"      +N\tMostra a N-ésima entrada contando da esquerda da lista\n"
"    \t\tmostrada por \"dirs\" quando chamado sem opções, começando\n"
"    \t\tpor zero.\n"
"    \n"
"      -N\tMostra a N-ésima entrada contando da direita da lista\n"
"    \t\tmostrada por \"dirs\" quando chamado sem opções, começando\n"
"    \t\tpor zero.\n"
"    \n"
"    Estado de saída:\n"
"    Devolve sucesso a não ser que indique uma opção inválida ou ocorra um "
"erro"

#: builtins.c:1917
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Define e cancela opções de consola.\n"
"    \n"
"    Altera a definição de cada opção de consola OPTNOME. Sem qualquer\n"
"    argumento, lista todas as opções de consola com indicação de definição\n"
"    ou não de estado.\n"
"    \n"
"     Opções:\n"
"       -o\trestringe OPTNOMEs para os definidos para uso com \"set -o\"\n"
"       -p\timprime cada opção de consola com indicação do seu estado\n"
"       -q\tsuprime a saída\n"
"       -s\tactiva (define) cada OPTNOME\n"
"       -u\tdesactiva (limpa) cada OPTNOME\n"
"    \n"
"    Estado de saída:\n"
"    Devolve sucesso se OPTNOME estiver activado; falha se indicar uma opção\n"
"    inválida ou OPTNOME esteja desactivada."

#: builtins.c:1938
#, fuzzy
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in "
"printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a "
"format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as "
"appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"Formata e imprime ARGUMENTOS sob controlo do FORMATO.\n"
"    \n"
"    Opções:\n"
"      -v var\tatribui a saída à variável de consola VAR em vez de\n"
"    \t\tmostrar na saída padrão\n"
"    \n"
"    FORMATO é uma cadeia de caracteres que contém três tipos de objectos: \n"
"    caracteres simples, que são simplesmente copiados para a saída padrão;\n"
"    sequências de escape, que são convertidas e copiadas para a saída "
"padrão; e\n"
"    especificações de formato, cada uma das quais causa a impressão do "
"argumento\n"
"    sucessivo seguinte.\n"
"    \n"
"    Além das especificações de formato padrão descritas em printf (1),\n"
"    printf interpreta:\n"
"    \n"
"      %b\texpande sequências de escape para o argumento correspondente\n"
"      %q\tcita o argumento de forma a ser reutilizado como entrada de "
"consola\n"
"      %(fmt)T\timprime a cadeia de data-hora resultante da utilização do "
"FMT\n"
"    \t\tcomo formato para strftime(3)\n"
"    \n"
"    O formato é reutilizado conforme necessário para consumir todos os "
"argumentos.\n"
"    E se há menos argumentos do que o formato requer, especificações de "
"formato\n"
"    extra comportam-se como um valor zero ou uma cadeia nula, conforme "
"apropriado,\n"
"    tenha sido fornecido.\n"
"    \n"
"    Estado de saída:\n"
"    Devolve sucesso a não ser que indique uma opção inválida ou ocorra um "
"erro de\n"
"    escrita ou atribuição."

#: builtins.c:1974
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are "
"supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -"
"I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Especifica como os argumentos devem ser concluídos por Readline.\n"
"    \n"
"    Para cada NOME, especifica como os argumentos devem ser concluídos. Se "
"não \n"
"    fornecer opções, as especificações de conclusão existentes são "
"imprimidas\n"
"    de forma a permitir que sejam reutilizadas como entrada.\n"
"    \n"
"    Opções:\n"
"      -p\timprime especificações de conclusão existentes em formato "
"reutilizável\n"
"      -r\tremove uma especificação de conclusão para cada NOME, ou, se não\n"
"    \t\tforneceu NOMEs, todas as especificações de conclusão\n"
"      -D\taplica as conclusões e acções como predefinição para comandos\n"
"     \t\tsem qualquer especificação de conclusão definida\n"
"      -E\taplica as conclusões e acções a comandos -- \"vazios\"\n"
"     \t\tconclusão tentada numa linha em branco\n"
"      -I\taplica as conclusões e acções à palavra inicial (normalmente o\n"
"    \t\tcomando)\n"
"    \n"
"    Quando a conclusão é tentada, as acções são aplicadas na ordem em que \n"
"    as opções de letras maiúsculas estão listadas acima. Se forem fornecidas "
"múltiplas\n"
"    opções, a opção -D toma precedência sobre -E e ambas têm precedência "
"sobre -I.\n"
"    \n"
"    Estado da saída:\n"
"devolve sucesso a não ser que seja fornecida uma opção inválida ou ocorra um "
"erro."

#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Mostrar possíveis conclusões, dependendo das opções.\n"
"    \n"
"    Destinado a ser usado de dentro de uma função de consola gerando\n"
"    possíveis conclusões. Se o argumento PALAVRA opcional for fornecido,\n"
"    são geradas comparações com PALAVRA.\n"
"    \n"
"    Estado de saída:\n"
"    Devolve sucesso a não ser que indique uma opção inválida ou ocorra um "
"erro."

#: builtins.c:2019
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Modifica ou mostra as opções de conclusão.\n"
"    \n"
"    Modifica as opções de conclusão para cada NOME, ou, se não fornecer "
"NOME,\n"
"    a conclusão actualmente em execução. Se nenhuma OPÇÃO for fornecida, "
"imprime\n"
"    as opções de conclusão para cada NOME ou a especificação de conclusão "
"actual.\n"
"    \n"
"    Opções:\n"
"    \t-o opção\tDefine opção de conclusão OPÇÃO para cada NOME\n"
"    \t-D\t\tAltera opções para a conclusão do comando \"predefinido\"\n"
"    \t-E\t\tAltera opções para a conclusão do comando \"vazio\"\n"
"    \t-I\t\tAltera opções para a conclusão na palavra inicial\n"
"    \n"
"    Usar \"+ o\" em vez de \"-o\" desliga a opção especificada.\n"
"    \n"
"    Argumentos:\n"
"    \n"
"    Cada NOME refere-se a um comando para o qual uma especificação de "
"conclusão\n"
"    deve ter sido anteriormente definida usando o interno \"complete\". Se "
"não\n"
"    forneceu NOMEs, compopt tem de ser chamado por uma função actualmente a\n"
"    gerar conclusões e as opções para esse gerador de conclusões "
"actualmente\n"
"    em execução são modificadas.\n"
"    \n"
"    Estado de saída:\n"
"    Devolve sucesso a não ser que indique uma opção inválida ou NOME não "
"tenha\n"
"    uma especificação de conclusão definida."

#: builtins.c:2050
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard "
"input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""
"Lê linhas da entrada padrão para uma variável de matriz indexada.\n"
"    \n"
"    Lê linhas da entrada padrão para a variável de matriz indexada MATRIZ, "
"ou\n"
"    do descritor de ficheiro FD se a opção -u for fornecida. A variável "
"MAPFILE\n"
"    é a MATRIZ predefinida.\n"
"    \n"
"    Opções:\n"
"      -d delim\tUsa DELIM para terminar as linhas, em vez de nova linha\n"
"      -n total\tCopia no máximo TOTAL linhas. Se TOTAL for 0, copia todas\n"
"      -O origem\tComeça a atribuir a MATRIZ no índice ORIGEM. A predefinição "
"é 0\n"
"      -s total\tDescarta as primeiras TOTAL linhas lidas\n"
"      -t\tRemove um DELIM inicial de cada linha lida (predefinição é nova "
"linha)\n"
"      -u fd\tLê linhas do descritor de ficheiro FD em vez da entrada padrão\n"
"      -C retorno\tAvalia RETORNO cada vez que QUANTUM linhas são lidas\n"
"      -c quantum\tEspecifica o número de linhas lidas entre cada chamada a\n"
"    \t\t\tRETORNO\n"
"    \n"
"    Argumentos:\n"
"      ARRAY\tNome de variável de matriz a usar para dados de ficheiro\n"
"    \n"
"    Se -C for fornecido sem -c, a quantidade predefinida é 5000. Quando\n"
"    RETORNO é avaliado, é fornecido o índice do elemento seguinte da\n"
"    matriz a ser atribuído e a linha a ser atribuída a esse elemento\n"
"    como argumentos adicionais.\n"
"    \n"
"    Se não for fornecido com uma origem explícita, mapfile limpa MATRIZ "
"antes\n"
"    de lhe fazer atribuições.\n"
"    \n"
"    Estado de saída:\n"
"    Devolve sucesso a não ser que indique uma opção inválida, MATRIZ seja "
"só\n"
"    de leitura ou não seja uma matriz indexada."

#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Lê linhas de um ficheiro para uma variável de matriz.\n"
"     \n"
"     Um sinónimo para \"mapfile\"."

#, c-format
#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: chave de matriz associativa inválida"

#~ msgid ""
#~ "Returns the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns "
#~ msgstr ""
#~ "Devolve o contexto da presente chamada a sub-rotina.\n"
#~ "    \n"
#~ "    Sem EXPR, devolve "

#~ msgid "add_process: process %5ld (%s) in the_pipeline"
#~ msgstr "add_process: processo %5ld (%s) na _pipeline"

#~ msgid "Unknown Signal #"
#~ msgstr "Sinal desconhecido #"
