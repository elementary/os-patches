# qerman language file for GNU Bash 5.0
# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Roland Illig <roland.illig@gmx.de> 2019
# Nils Naumann <nau@gmx.net>, 1996-2021.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 5.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2021-12-29 22:04+0100\n"
"Last-Translator: Nils Naumann <nau@gmx.net>\n"
"Language-Team: German <translation-team-de@lists.sourceforge.net>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "Falscher Feldindex."

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: Entferne das Nameref Attribut."

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr ""
"%s: Das indizierte Array kann in kein assoziatives Array umgewandelt werden."

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: Das Zuweisen auf einen nicht-numerischen Index ist nicht möglich."

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr ""
"%s: %s: Ein Feldindex wird zum Zuweisen eines assoziativen Arrays benötigt."

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: Kann die Datei %s nicht erzeugen."

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""
"bash_execute_unix_command: Kann nicht die Tastenzuordnung für das Kommando "
"finden."

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr " %s: Das erste Zeichen ist nicht `\\'."

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "fehlende schließende `%c' in %s."

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: Fehlender Doppelpunkt."

#: bashline.c:4733
#, fuzzy, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "»%s«: Bindung kann nicht gelöst werden."

#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "Klammererweiterung: Konnte keinen Speicher für %s zuweisen."

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "Klammererweiterung: Konnte keinen Speicher für %u Elemente zuweisen."

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "Klammererweiterung: Konnte keinen Speicher für »%s« zuweisen."

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "»%s«: Ungültiger Aliasname."

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "Zeileneditierung ist nicht aktiviert."

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "»%s«: Ungültiger Tastenzuordnungs-Name."

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: Nicht lesbar: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "%s: Unbekannter Funktionsname."

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s ist keiner Taste zugeordnet.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s kann aufgerufen werden durch "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "»%s«: Bindung kann nicht gelöst werden."

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "Schleifenzähler"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "nur in einer for-, while- oder until-Schleife sinnvoll."

# caller
#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Gibt Informationen zum aktuellen Subroutinenaufruf aus.\n"
"\n"
"    Ohne Argument wird die Zeilennummer und der Dateiname angezeigt. Mit\n"
"    Argument werden Zeilennummer, Subroutinenname und Dateiname ausgegeben.\n"
"    Mit diesen Informationen kann ein Stacktrace erzeugt werden.\n"
"\n"
"    Das Argument gibt die angezeigte Position im Funktionsaufrufstapel an,\n"
"    wobei 0 der aktuelle Funktionsaufruf ist."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "HOME ist nicht zugewiesen."

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "Zu viele Argumente."

#: builtins/cd.def:342
msgid "null directory"
msgstr "NULL Verzeichnis"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "OLDPWD ist nicht zugewiesen."

# Debug Ausgabe
#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "Zeile %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "Warnung: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: Aufruf: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: Die Option erfordert ein Argument."

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: Ein numerischer Parameter ist erforderlich."

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: Nicht gefunden."

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: Ungültige Option."

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: Ungültiger Optionsname."

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "»%s«: Ist kein gültiger Bezeichner."

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "Ungültige Oktalzahl."

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "Ungültige hexadezimale Zahl."

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "Ungültige Zahl."

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: Ungültige Signalbezeichnung."

#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "»%s«: Ist keine gültige Prozess-ID oder Jobbezeichnung."

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: Schreibgeschützte Variable."

#: builtins/common.c:273
#, fuzzy, c-format
msgid "%s: cannot assign"
msgstr "%s: »unset« nicht möglich."

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "Argument"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: Kein solcher Job."

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: Keine Jobsteuerung in dieser Shell."

#: builtins/common.c:301
msgid "no job control"
msgstr "Keine Jobsteuerung in dieser Shell."

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: eingeschränkt"

#: builtins/common.c:313
msgid "restricted"
msgstr "eingeschränkt"

#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: Ist kein eingebautes Shellkommando."

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "Schreibfehler: %s."

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "Fehler beim Setzen der Terminalattribute: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "Fehler beim Ermitteln der Terminalattribute: %s"

#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: Kann das aktuelle Verzeichnis nicht wiederfinden: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: Mehrdeutige Jobbezeichnung."

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "In dieser Version ist keine Hilfe verfügbar."

#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: »unset« nicht möglich: %s ist schreibgeschützt"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: »unset« nicht möglich."

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: Ungültiger Aktionsname."

#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: Keine Komplettierung angegeben."

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "Warnung: Die Option -F könnte unerwartete Ergebnisse liefern."

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "Warnung: Die Option -C könnte unerwartete Ergebnisse liefern."

#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "Gegenwärtig wird keine Komplettierungsfunktion ausgeführt."

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "Kann nur innerhalb einer Funktion benutzt werden."

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "Mit »-f« können keine Funktionen erzeugt werden."

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: Schreibgeschützte Funktion."

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: Referenzvariable darf kein Array sein."

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr ""

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s: Zirkularbezug auf indirekte Variable."

#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "»%s«: Ungültiger Name für indirekte Variablenreferenz."

#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: Kann Feldvariablen nicht auf diese Art löschen."

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr ""
"%s: Konvertieren von assoziativen in indizierte Arrays ist nicht möglich."

#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr ""

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "Dynamisches Laden ist nicht verfügbar."

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "Kann die dynamische Bibliothek nicht laden %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "Kann %s nicht in der dynamischen Bibliothek finden %s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: Ist bereits geladen."

#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr ""
"Die Ladefunktion von %s lieferte einen Fehler (%d), daher nicht geladen."

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: Ist nicht dynamisch geladen."

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: Kann nicht löschen: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: ist ein Verzeichnis."

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: Ist keine normale Datei."

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: Die Datei ist zu groß."

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: Kann die Datei nicht ausführen."

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: Kann nicht ausführen: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "Abgemeldet\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "Keine Loginshell: Mit »exit« abmelden!"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Es gibt noch angehaltene Prozesse.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Es gibt noch laufende Prozesse.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "Kein Kommando gefunden."

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr ""

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: Kann die temporäre Datei nicht öffnen: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "gegenwärtig"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "Job %d wurde ohne Jobsteuerung gestartet."

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: Ungültige Option -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: Diese Option erfordert ein Argument -- %c\n"

#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "Hashing deaktiviert."

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: Die Hashtabelle ist leer.\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "Treffer\tBefehl\n"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00022.html
#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Shellkommando, auf das das Schlüsselwort zutrifft `"
msgstr[1] "Shell Kommandos auf die die Schlüsselwörter zutreffen `"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"Kein passendes Hilfethema für »%s«. Probieren Sie »help help«, »man -k %s« "
"oder »info %s«."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: Kann die Datei nicht öffnen: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Diese Shellkommandos sind intern definiert. Geben Sie »help« ein, um diese\n"
"Liste zu sehen. Geben Sie »help Name« ein, um die Beschreibung der Funktion\n"
"»Name« zu sehen. Geben Sie »info bash« ein, um die vollständige "
"Dokumentation\n"
"zu sehen. Geben Sie »man -k« oder »info« ein, um detaillierte "
"Beschreibungen\n"
"der Shellkommandos zu sehen.\n"
"\n"
"Ein Stern (*) neben dem Namen kennzeichnet deaktivierte Kommandos.\n"
"\n"

#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "Es darf höchstens eine Option aus -anrw angegeben werden."

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "Kommandostapelposition."

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: Ungültiger Zeitstempel."

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: Kommandoersetzung gescheitert."

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib gescheitert."

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "Keine weiteren Optionen mit `-x' erlaubt."

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: Die Argumente müssen Prozess- oder Job-IDs sein."

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Unbekannter Fehler."

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "Ausdruck erwartet."

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: Ist kein indiziertes Array."

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: Ungültige Dateideskriptor-Angabe."

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: Ungültiger Dateideskriptor: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: Ungültige Zeilenanzahlangabe."

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: Ungültiger Arrayanfang."

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr ""

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "Fehlender Name für die Arrayvariable."

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr ""
"Die Unterstützung für Arrayvariablen ist in dieser Shell nicht vorhanden."

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "»%s«: Fehlendes Formatierungszeichen."

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "»%c«: Ungültige Zeitformatangabe."

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "»%c«: Ungültiges Formatierungszeichen."

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "Warnung: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "Formatleseproblem: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "Fehlende hexadezimale Ziffer nach \\x."

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "Fehlende Unicode-Ziffer für \\%c."

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "kein anderes Verzeichnis"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s: Ungültiges Argument."

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<kein aktuelles Verzeichnis>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "Der Verzeichnisstapel ist leer."

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "Verzeichnisstapelindex"

#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Zeigt die Liste der gegenwärtig gespeicherten Verzeichnisse an.  Durch\n"
"    das Kommando »pushd« werden die Verzeichnisse auf den Stapel gelegt\n"
"    und können durch das Kommando »popd« wieder vom Stapel entfernt\n"
"    werden.\n"
"\n"
"    Optionen:\n"
"\t-c\tVerzeichnisstapel durch Löschen aller Einträge bereinigen.\n"
"\t-l\tDas Heimatverzeichnis wird nicht mit vorangestellter Tilde\n"
"\tausgegeben\n"
"\t-p\tDen Verzeichnisstapel zeilenweise ausgeben.\n"
"\t-v\tDen Verzeichnisstapel zeilenweise mit vorangestellter\n"
"\tPositionsnummer auseben.\n"
"\n"
"    Argumente:\n"
"\t+N\tZeigt den N'ten Eintrag von links an, der von »dirs« ausgegeben\n"
"\twird, wenn es ohne Optionen aufgerufen wird, beginnend mit Null.\n"
"\t-N\tZeigt den N'ten Eintrag von rechts an, der von »dirs« ausgegeben\n"
"\twird, wenn es ohne Optionen aufgerufen wird, beginnend mit Null."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Legt einen Verzeichniseintrag auf den Verzeichnisstapel ab oder rotiert\n"
"den Stapel so, dass das aktuelle Verzeichnis oben liegt. Ohne Argumente\n"
"werden die beiden oberen Einträge vertauscht.\n"
"\n"
"    Optionen: \n"
"       -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"\n"
"    Argumente:\n"
"      +N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon links, das von »dirs« angezeigt wird, nach oben kommt. Die Zählung\n"
"\tbeginnt dabei mit Null.\n"
"\n"
"      -N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon rechts, das von »dirs« angezeigt wird, nach oben kommt. Die \n"
"\tZählung beginnt dabei mit Null.\n"
"\n"
"      dir\tLegt DIR auf den Verzeichnisstapel und wechselt in dieses\n"
"      Verzeichnis.\n"
"    \n"
"    Das Kommando »dirs« Kommando zeigt den Verzeichnisstapel an."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Entfernt Einträge vom Stapel.  Ohne Argumente wird der oberste Eintrag\n"
"    gelöscht und anschließend in das das neue oben liegende Verzeichnis\n"
"    gewechselt.\n"
"    \n"
"    Optionen:\n"
"      -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"    \n"
"    Argumente:\n"
"      +N\tEntfernt den N-ten Eintrag von links, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. »popd +0« den ersten und »popd +1« den zweiten\n"
"\tEintrag.\n"
"    \n"
"      -N\tEntfernt den N-ten Eintrag von rechts, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. »popd -0« den letzten und »popd +1« den vorletzten\n"
"\tEintrag.\n"
"    \n"
"    Das Kommando »dirs« zeigt den Verzeichnisstapel an."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: Ungültige Wartezeitangebe."

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "Lesefehler: %d: %s"

#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr ""
"»Return« ist nur aus einer Funktion oder einem mit »source« ausgeführten "
"Skript möglich."

#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr ""
"Gleichzeitiges »unset« einer Funktion und einer Variable ist nicht möglich."

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: Ist keine Feldvariable."

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: Ist keine Funktion."

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: Exportieren nicht möglich."

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "Verschiebeanzahl"

#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "Kann nicht Shelloptionen gleichzeitig aktivieren und deaktivieren."

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: Ungültiger Name für Shelloption."

#: builtins/source.def:128
msgid "filename argument required"
msgstr "Ein Dateiname wird als Argument benötigt."

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: Datei nicht gefunden."

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "Kann die Shell nicht unterbrechen."

# logout
#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "Kann die Loginshell nicht unterbrechen."

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s ist ein Alias von »%s«.\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s Ist ein reserviertes Schlüsselwort der Shell.\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s ist eine Funktion.\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s ist eine spezielle eingebaute Funktion.\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s ist eine von der Shell mitgelieferte Funktion.\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s ist %s\n"

#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s ist gehasht (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: Ungültiges Grenzwertargument."

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "`%c': Falsches Kommando."

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: Kann die nicht Grenze setzen: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "Grenze"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: Kann die Grenze nicht ändern: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "Oktalzahl"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': Ungültiger Operator für den symbolischen Modus."

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': Ungültiges Zeichen im symbolischen Modus."

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " Zeile "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "Letztes Kommando: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Abbruch..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "INFO: "

#: error.c:310
#, fuzzy, c-format
msgid "DEBUG warning: "
msgstr "Warnung: "

#: error.c:488
msgid "unknown command error"
msgstr "Unbekanntes Kommando"

#: error.c:489
msgid "bad command type"
msgstr "Falscher Kommandotyp"

# Programmierfehler
#: error.c:490
msgid "bad connector"
msgstr ""

#: error.c:491
msgid "bad jump"
msgstr "Falscher Sprung"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s ist nicht gesetzt."

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aZu lange keine Eingabe: Automatisch ausgeloggt.\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "Kann nicht die Standardeingabe von /dev/null umleiten: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: »%c«: Ungültiges Formatzeichen."

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr ""

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "Pipe-Fehler"

#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: Maximale Schachtelungstiefe überschritten (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: Maximale Quellcode-Schachtelungstiefe überschritten (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: maximale Schachtelungstiefe für Funktionen überschritten (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: eingeschränkt: `/' ist in Kommandonamen unzulässig."

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: Kommando nicht gefunden."

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, fuzzy, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: Kann die Datei nicht ausführen."

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: Defekter Interpreter"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: Kann die Binärdatei nicht ausführen: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "»%s« ist eine spezielle eingebaute Funktion."

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "Kann fd %d nicht auf fd %d verdoppeln."

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "Zu viele Rekursionen in Ausdruck."

#: expr.c:291
msgid "recursion stack underflow"
msgstr "Rekursionsstapel leer."

#: expr.c:478
msgid "syntax error in expression"
msgstr "Syntaxfehler im Ausdruck."

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "Versuchte Zuweisung zu etwas, das keine Variable ist."

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "Syntaxfehler in der Variablenzuweisung."

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "Division durch 0."

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "Fehler: Falscher Zuweisungsoperator."

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "»:« für ein bedingten Ausdruck erwartet."

#: expr.c:973
msgid "exponent less than 0"
msgstr "Der Exponent ist kleiner als 0."

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr ""
"Nach einem Präinkrement oder Prädekrement wird ein Bezeichner erwartet."

#: expr.c:1057
msgid "missing `)'"
msgstr "Fehlende »)«"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "Syntaxfehler: Operator erwartet."

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "Syntaxfehler: Ungültiger arithmetischer Operator."

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (Fehlerverursachendes Zeichen ist \"%s\")."

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "Ungültige Basis."

#: expr.c:1587
msgid "invalid integer constant"
msgstr "Ungültige Ganzzahlenkonstante."

#: expr.c:1603
msgid "value too great for base"
msgstr "Der Wert ist für die aktuelle Basis zu groß."

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: Fehler im Ausdruck.\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: Kann auf die übergeordneten Verzeichnisse nicht zugreifen."

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "Konnte den No-Delay-Modus für fd %d nicht wiederherstellen."

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "Kann keinen neuen Dateideskriptor für die Eingabe von fd %d zuweisen."

# Debug Ausgabe
#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: Es existiert bereits ein Puffer für den neuen fd %d."

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr ""

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr ""

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "Die geforkte PID %d erscheint im laufenden Prozess %d."

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "Lösche den gestoppten Prozess %d der Prozessgruppe %ld."

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00024.html
#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr ""

# Programmierfehler
#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: Prozessnummer existiert nicht."

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Signal %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Fertig"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Angehalten"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Angehalten(%s)"

#: jobs.c:1881
msgid "Running"
msgstr "Läuft"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Fertig(%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Exit %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Unbekannter Status"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(Speicherabzug geschrieben) "

#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (Verz.: %s)"

# interner Fehler
#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr ""

#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: Prozess %ld wurde nicht von dieser Shell gestartet."

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr ""

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: Der Job %d ist gestoppt."

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: Kein aktueller Job."

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: Der Job ist beendet."

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: Der Job %d läuft bereits im Hintergrund."

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr ""

# Debug Ausgabe
#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: Zeile %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (Speicherabzug geschrieben)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(gegenwärtiges Arbeitsverzeichnis ist: %s)\n"

# interner Fehler
#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp war nicht erfolgreich."

# interner Fehler
#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: Keine Jobsteuerung im Hintergrund."

# interner Fehler
#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: line discipline"

# interner Fehler
#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "Kann die Prozessgruppe des Terminals nicht setzen (%d)."

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "Keine Jobsteuerung in dieser Shell."

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: Zusicherung gescheitert: %s.\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: Zusicherung verpfuscht\\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "Unbekannt"

#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "Malloc: Ein internet Speicherbereich (free list) wurde überschrieben."

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: Wurde für bereits freigegebenen Speicherbereich aufgerufen."

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: Wurde für nicht zugeordneten Speicherbereich aufgerufen."

#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: Underflow erkannt; mh_nbytes außerhalb des Gültigkeitsbereichs."

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: Underflow erkannt; magic8 beschädigt."

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: Beginn und Ende Segmentgrößen sind unterschiedlich."

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: Mit nicht zugewiesenen Argument aufgerufen."

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr ""
"realloc: Underflow erkannt; mh_nbytes außerhalb des Gültigkeitsbereichs."

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: Underflow erkannt; magic8 beschädigt."

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: Beginn und Ende Segmentgrößen sind unterschiedlich.<"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr ""
"register_alloc: Speicherzuordnungstabelle ist mit FIND_ALLOC gefüllt?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr ""
"register_alloc: %p ist bereits in der Speicherzuordnungstabelle als belegt "
"gekennzeichnet?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr ""
"register_free: %p ist bereits in der Speicherzuordnungstabelle als frei "
"gekennzeichnet?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "Ungültige Basis"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: Unbekannter Host."

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: unbekannter Dienst."

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: Fehlerhafte Netzwerkspfadangabe."

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "Der Netzwerkbetrieb ist nicht unterstützt."

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: Kann die Regionseinstellungen nicht ändern (%s)."

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: Kann die Regionseinstellungen nicht ändern (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: Kann die Regionseinstellungen nicht ändern (%s)."

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: Kann die Regionseinstellungen nicht ändern (%s): %s"

# Du oder Sie?
#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Sie haben Post in $_."

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Sie haben neue Post in $_."

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Die Post in %s wurde bereits gelesen.\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "Syntaxfehler: Es wird ein arithmetischer Ausdruck benötigt."

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "Syntax Fehler: unerwartetes `;'."

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "Syntaxfehler: »((%s))«."

# interner Fehler
#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: Falscher Befehlstyp %d."

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""
"Das in der Zeile %d beginnende Here-Dokument geht bis zum Dateiende "
"(erwartet wird »%s«)."

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""

#: parse.y:2428
#, c-format
msgid ""
"shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line "
"truncated"
msgstr ""

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr ""

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "Dateiende beim Suchen nach »%c« erreicht."

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "Dateiende beim Suchen nach »]]« erreicht."

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "Syntaxfehler im bedingten Ausdruck: Unerwartetes Symbol »%s«."

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "Syntaxfehler im bedingten Ausdruck."

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "Unerwartetes Zeichen: »%s« anstatt von »)«"

#: parse.y:4543
msgid "expected `)'"
msgstr "»)« erwartet."

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr ""

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr ""

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr ""

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr ""

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr ""

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr ""

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr ""

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr ""

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr ""

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "Syntaxfehler beim unerwarteten Symbol »%s«"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "Syntaxfehler bei »%s«"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "Syntaxfehler: Unerwartetes Dateiende."

#: parse.y:6151
msgid "syntax error"
msgstr "Syntaxfehler"

# Du oder Sie?
#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Verwenden Sie »%s«, um die Shell zu verlassen.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "Dateiende beim Suchen nach zugehöriger »)« erreicht."

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: Funktion »%s« nicht gefunden."

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr ""

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr ""

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: Falsches Verbindungszeichen »%d«."

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: Ungültiger Dateideskriptor."

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr ""

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr ""

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: »%c«: Ungültiges Formatsymbol."

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "Dateideskriptor außerhalb des gültigen Bereichs."

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: Mehrdeutige Umlenkung."

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: Kann existierende Datei nicht überschreiben."

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: eingeschränkt: Die Ausgabe darf nicht umgeleitet werden."

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "Kann die temporäre Datei für das Hier-Dokument nicht anlegen: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: Kann fd keiner Variable zuweisen."

#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr ""
"Dateinamen der Form /dev/(tcp|udp)/host/port werden ohne Netzwerk nicht "
"unterstützt"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "Umleitungsfehler: Verdoppeln des Dateibezeichners nicht möglich."

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "Konnte das Verzeichnis »/tmp« nicht finden, bitte anlegen."

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "/tmp muss ein Verzeichnis sein."

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "Der hübsche Druckmodus wird in interaktiven Schells ignoriert."

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: Ungültige Option"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "Konnte die UID nicht in %d ändern: Die effektive UID ist %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "Konnte die GID nicht in %d ändern: Die effektive GID ist %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "Kann keinen Debugger starten. Der Debugmodus ist gesperrt."

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s: Ist ein Verzeichnis."

#: shell.c:1907
msgid "I have no name!"
msgstr "Ich habe keinen Benutzernamen!"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, Version %s-(%s)\n"

#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Aufruf:\t%s [Lange GNU-Option] [Option] ...\n"
"\t%s [Lange GNU-Option] [Option] Script-Datei ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "Lange GNU-Optionen:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Shell-Optionen:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD oder -c Kommando oder -O shopt_option\t\t(Nur Aufruf)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s oder Option -o\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Geben Sie »%s -c \"help set\"« ein, um mehr über Shell-Optionen zu "
"erfahren.\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Geben Sie »%s -c help« ein, um mehr über eingebaute Shellkommandos zu "
"erfahren.\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Mit dem Kommando »bashbug« Kommando können Sie Fehler melden.\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Bash-Homepage: <https://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Allgemeine Hilfe für GNU-Software: <https://www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: Ungültige Operation"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Falsches Signal."

#: siglist.c:51
msgid "Hangup"
msgstr "Aufgelegt"

#: siglist.c:55
msgid "Interrupt"
msgstr "Unterbrochen (Interrupt)"

#: siglist.c:59
msgid "Quit"
msgstr "Quit"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Ungültige Anweisung."

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Verfolgen/anhalten abfangen (Trace/breakpoint trap)"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Abbruchkommando"

#: siglist.c:79
msgid "EMT instruction"
msgstr "EMT abfangen (EMT trap)"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Gleitkommafehler"

#: siglist.c:87
msgid "Killed"
msgstr "Abgebrochen (Killed)"

#: siglist.c:91
msgid "Bus error"
msgstr "Bus-Fehler"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Adressierungsfehler"

#: siglist.c:99
msgid "Bad system call"
msgstr "Falscher Systemaufruf"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Unterbrochene Pipe"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Wecker"

#: siglist.c:111
msgid "Terminated"
msgstr "Abgebrochen (Terminated)"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Dringende IO-Bedingung"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Angehalten (Signal)"

#: siglist.c:127
msgid "Continue"
msgstr "Prozessbearbeitung wieder aufgenommen."

#: siglist.c:135
msgid "Child death or stop"
msgstr "Kindprozess abgebrochen oder gestoppt."

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Angehalten (Terminaleingabe)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Angehalten (Terminalausgabe)"

#: siglist.c:147
msgid "I/O ready"
msgstr "E/A fertig"

#: siglist.c:151
msgid "CPU limit"
msgstr "Rechenzeitgrenze"

#: siglist.c:155
msgid "File limit"
msgstr "Grenze für Dateigröße"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarm (Virtuell)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarm (Profil)"

#: siglist.c:167
msgid "Window changed"
msgstr "Fenster geändert"

#: siglist.c:171
msgid "Record lock"
msgstr "Datei blockiert"

#: siglist.c:175
msgid "User signal 1"
msgstr "Nutzersignal 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Nutzersignal 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "HFT Eingabedaten ausstehend"

#: siglist.c:187
msgid "power failure imminent"
msgstr "Spannungsausfall steht bevor"

#: siglist.c:191
msgid "system crash imminent"
msgstr "Systemausfall steht bevor"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "Verlege den Prozess auf einen anderen Prozessor"

#: siglist.c:199
msgid "programming error"
msgstr "Programmierfehler"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "HFT-Monitormodus erlaubt"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "HFT-Monitormodus abgeschaltet"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "HFT-Tonfolge beendet"

#: siglist.c:215
msgid "Information request"
msgstr "Informationsanforderung"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00025.html
#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Unbekanntes Signal Nr.: %d."

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "Falsche Ersetzung: Kein schließendes »%s« in »%s« enthalten."

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: Kann einem Feldelement keine Liste zuweisen."

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "Kann keine Pipe für die Prozessersetzung erzeugen."

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "Kann den Kindsprozess für die Prozessersetzung nicht erzeugen."

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "Kann nicht die benannte Pipe %s zum Lesen öffnen."

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "Kann nicht die benannte Pipe %s zum Schreiben öffnen."

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "Kann die benannte Pipe %s nicht auf fd %d duplizieren."

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "Kommandoersetzung: NULL-Byte in der Eingabe ignoriert."

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "Kann keine Pipes für Kommandoersetzung erzeugen."

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "Kann keinen Unterprozess für die Kommandoersetzung erzeugen."

# interner Fehler
#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: Kann Pipe nicht als Dateideskriptor 1 duplizieren."

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: Ungültiger Variablenname für Namensreferenz."

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: Ungültige indirekte Expansion."

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: Ungültiger Variablenname."

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: Der Parameter ist nicht gesetzt."

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: Parameter ist leer oder nicht gesetzt."

# interner Fehler
#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: Teilstring-Ausdruck < 0."

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: Falsche Substitution."

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: Kann so nicht zuweisen."

#: subst.c:10111
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""
"Zukünftige Versionen dieser Shell werden das Auswerten arithmetischer "
"Ersetzungen erzwingen."

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "Falsche Ersetzung: Kein schließendes »`« in %s."

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "Keine Entsprechung: %s"

#: test.c:147
msgid "argument expected"
msgstr "Argument erwartet."

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: Ganzzahliger Ausdruck erwartet."

#: test.c:265
msgid "`)' expected"
msgstr "»)« erwartet."

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "»)« erwartet, %s gefunden."

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: Zweistelliger (binärer) Operator erwartet."

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: Einstelliger (unärer) Operator erwartet."

#: test.c:896
msgid "missing `]'"
msgstr "Fehlende »]«"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "Syntax Fehler: »%s« unerwartet."

#: trap.c:220
msgid "invalid signal number"
msgstr "Ungültige Signalnummer."

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "Traphandler: Maximale Traphandler-Ebene überschritten (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: Ungültiger Wert in trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""

# Programmierfehler
#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: Falsches Signal %d."

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "Fehler beim Importieren der Funktionsdefinition für »%s«."

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "Der Shell-Level (%d) ist zu hoch und wird auf 1 zurückgesetzt."

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: no function context at current scope"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: Der Variable darf kein Wert zugewiesen werden."

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr ""

# Interner Fehler
#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: assigning integer to name reference"

# Interner Fehler
#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: no function context at current scope"

# Interner Fehler
#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s has null exportstr"

# Interner Fehler
#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "invalid character %d in exportstr for %s"

# Interner Fehler
#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "no `=' in exportstr for %s"

# Interner Fehler
#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: head of shell_variables not a function context"

# Interner Fehler
#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: no global_variables context"

# Interner Fehler
#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: head of shell_variables not a temporary environment scope"

# Interner Fehler
#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: cannot open as FILE"

# Interner Fehler
#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: invalid value for trace file descriptor"

# Interner Fehler
#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: compatibility value out of range"

#: version.c:46 version2.c:46
#, fuzzy
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Copyright (C) 2020 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Lizenz GPLv3+: GNU GPL Version 3 oder jünger <http://gnu.org/licenses/gpl."
"html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, Version %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "Dies ist freie Software. Sie darf verändert und verteilt werden."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Es wird keine Garantie gewährt, soweit das Gesetz es zulässt."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: Konnte keine %lu Bytes reservieren (%lu bytes reserviert)."

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: Konnte keine %lu Bytes reservieren."

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: Konnte keine %lu Bytes reservieren (%lu bytes reserviert)."

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: Konnte keine %lu Bytes reservieren."

#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [Name[=Wert] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] Name [Name ...]"

#: builtins.c:53
msgid ""
"bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpsvPSVX] [-m Tastaturtabelle] [-f Dateiname] [-q Name] [-u Name]\n"
"\t[-r Tastenfolge] [-x Tastenfolge:Shell Kommando]\n"
"\t[Tastenfolge:readline-Funktion oder -Kommando]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [Shellkommando [Argument ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [Ausdruck]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [Verzeichnis]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] Kommando [Argument ...]"

#: builtins.c:78
#, fuzzy
msgid ""
"declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] "
"[name ...]"
msgstr "declare [-aAfFgiIlrntux] [-p] [Name[=Wert] ...]"

#
#: builtins.c:80
#, fuzzy
msgid ""
"typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] "
"[name ...]"
msgstr "typeset [-aAfFgiIlnrtux] [-p] Name[=Wert] ..."

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [Option] Name[=Wert] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [Argument ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [Argument ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f Dateiname] [Name ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [Argument ...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00026.html
#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts Optionen [Argumente ...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00026.html
#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a Name] [Kommando [Argument ...]] [Umleitung ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr ""
"fc [-e Editor] [-lnr] [Anfang] [Ende] oder fc -s [Muster=Ersetzung] "
"[Kommando]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [Jobbezeichnung]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [Jobbezeichnung ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p Pfadname] [-dt] [Name ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [Muster ...]"

#: builtins.c:123
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d Offset] [n] oder history -anrw [Dateiname] oder history -ps "
"Argument [Argument...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [Jobbez. ...] or jobs -x Kommando [Arg]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [Jobbezeichnung ... | pid ...]"

#: builtins.c:134
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s Signalname | -n Signalnummer | -Signalname] pid | jobspec ... oder "
"kill -l [Signalname]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let Argument [Argument ...]"

#: builtins.c:138
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a Feld] [-d Begrenzer] [-i Text] [-n Zeichenanzahl] [-N "
"Zeichenanzahl] [-p Prompt] [-t Zeitlimit] [-u fd] [Name ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
#, fuzzy
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCHP] [-o Option] [--] [Argument ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [NAME ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [Name[=Wert] ...] oder export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [Name[=Wert] ...] oder readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source Dateiname [Argumente]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". Dateiname [Argumente]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [Ausdruck]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ Argument... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[Argument] Signalbezeichnung ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] Name [Name ...]"

#: builtins.c:171
#, fuzzy
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPT] [Grenze]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [Modus]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p Variable] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [pid ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for Name [in Wort ... ] ; do Kommandos; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( Ausdr1; Ausdr2; Ausdr3 )); do Kommandos; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select Name [in Wort ... ;] do Kommandos; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] Pipeline"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case Wort in [Muster [| Muster]...) Kommandos ;;]... esac"

#: builtins.c:194
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if Kommandos; then Kommandos; [ elif Kommandos; then Kommandos; ]... [ else "
"Kommandos; ] fi"

#: builtins.c:196
#, fuzzy
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while Kommandos; do Kommandos; done"

#: builtins.c:198
#, fuzzy
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until Kommandos; do Kommandos; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [Name] Kommando [Umleitungen]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function Name { Kommandos ; } oder Name () { Kommandos ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ Kommandos ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "Jobbezeichnung [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( Ausdruck ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ Ausdruck ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - Namen und Bedeutung einiger Shellvariablen"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | Verzeichnis]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [Optionsname ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] Format [Argumente]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00027.html
#: builtins.c:231
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-"
"W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-DEI] [-o Option] [-A Aktion] [-G "
"Suchmuster] [-W Wortliste]  [-F Funktion] [-C Kommando] [-X Filtermuster] [-"
"P Prefix] [-S Suffix] [Name \n"
"...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00027.html
#: builtins.c:235
msgid ""
"compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-"
"F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o Option] [-A Aktion] [-G Suchmuster] [-W "
"Wortliste] [-F Funktion] [-C Kommando] [-X Filtermuster] [-P Prefix] [-S "
"Suffix] [Wort]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o Option] [-DEI] [Name ...]"

#: builtins.c:242
msgid ""
"mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"mapfile [-d Begrenzer] [-n Anzahl] [-O Quelle] [-s Anzahl] [-t] [-u fd]\n"
"        [-C Callback] [-c Menge] [Feldvariable]"

#: builtins.c:244
msgid ""
"readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
"callback] [-c quantum] [array]"
msgstr ""
"readarray [-d Begrenzer] [-n Anzahl] [-O Quelle] [-s Anzahl] [-t]\n"
"          [-u fd] [-C Callback] [-c Menge] [Feldvariable]"

# alias
#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Definiert Aliase oder zeigt sie an.\n"
"\n"
"    Ohne Argumente wird die Liste der Aliase (Synonyme) in der Form\n"
"    »alias Name=Wert« auf die Standardausgabe ausgegeben.\n"
"\n"
"    Sonst wird ein Alias für jeden angegebenen Namen definiert, wenn\n"
"    für diesen auch ein »Wert« angegeben wurde. Wenn »Wert« mit einem\n"
"    Leerzeichen endet, dann wird auch das nächste Wort auf Aliase\n"
"    überprüft.\n"
"\n"
"    Optionen:\n"
"      -p\tGibt alle definierten Aliase aus.\n"
"\n"
"    Rückgabewert:\n"
"    Meldet Erfolg, außer wenn ein »Name« angegeben worden ist, für den\n"
"    kein Alias definiert wurde."

# unalias
#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Entfernt jeden angegebenen Namen von der Aliasliste.\n"
"\n"
"    Optionen:\n"
"      -a\tEnfernt alle Alias-Definitionen.\n"
"\n"
"    Gibt immer Erfolg zurück, außer wenn der Alias nicht existiert."

# bind
#: builtins.c:291
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated "
"commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Bestimmt Readline Tastenzuordnungen und Variablen.\n"
"    \n"
"    Weist eine Tastensequenz einer Readlinefunktion oder -makro zu\n"
"    oder setzt eine Readlinevariable.  Die Argumentsyntax ist zu\n"
"    den Einträgen in ~/.inputrc äquivalent, aber sie müssen als\n"
"    einzelnes Argument übergeben werden.  Z.B: bind '\"\\C-x\\C-r\":\n"
"    re-read-init-file'.\n"
"    \n"
"    Optionen:\n"
"      -m  Keymap         Benutzt KEYMAP as Tastaturbelegung für die "
"Laufzeit\n"
"                         dieses Kommandos.  Gültige Keymapnamen sind: "
"emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command und vi-insert.\n"
"      -l                 Listet Funktionsnamen auf.\n"
"      -P                 Listet Funktionsnamen und Tastenzuordnungen auf.\n"
"      -p                 Listet Funktionsnamen und Tastenzuordnungen so "
"auf,\n"
"                         dass sie direkt als Eingabe verwendet werden "
"können.\n"
"      -S                 Listet Tastenfolgen und deren Werte auf, die "
"Makros \n"
"                         aufrufen.\n"
"      -s                 Listet Tastenfolgen und deren Werte auf, die "
"Makros \n"
"                         aufrufen, dass sie als Eingabe wiederverwendet "
"werden\n"
"                         können.\n"
"      -V                 Listet Variablennamen und Werte auf.\n"
"      -v                 Listet Variablennamen und Werte so auf, dass sie "
"als\n"
"                         Eingabe verwendet werden können.\n"
"      -q  Funktionsname  Sucht die Tastenfolgen, welche die angegebene\n"
"                         Funktion aufrufen.\n"
"      -u  Funktionsname  Entfernt alle der Funktion zugeordneten "
"Tastenfolgen.\n"
"      -r  Tastenfolge    Entfernt die Zuweisungen der angegebeben "
"Tastenfolge.\n"
"      -f  Dateiname      Liest die Tastenzuordnungen aus der angegebenen "
"Datei.\n"
"      -x  Tastenfolge:Shellkommando\tWeist der Tastenfolge das "
"Shellkommando\n"
"    \t\t\t\t\tzu.\n"
"      -X                                Listet mit -x erzeugte\n"
"                                        Tastenfolgen und deren Werte\n"
"                                        auf, die Makros aufrufen, dass\n"
"                                        sie als Eingabe wiederverwendet "
"werden\n"
"                                        können.\n"
"    \n"
"    Rückgabewert: \n"
"    Bind gibt 0 zurück, wenn keine unerkannte Option angegeben wurde\n"
"    oder ein Fehler eintrat."

# break
#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Verlässt for-, while- oder until-Schleifen.\n"
"\n"
"    Break beendet eine »for«-, »while«- oder »until«- Schleife. Wenn »n«\n"
"    angegeben ist, werden entsprechend viele geschachtelte Schleifen "
"beendet.\n"
"\n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, außer »n« ist nicht größer oder gleich 1."

# continue
#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Springt zum Schleifenanfang von for, while, oder until Schleifen.\n"
"\n"
"    Springt zum Schleifenanfang der aktuellen »for«, »while« oder »until«\n"
"    Schleife. Wenn »n« angegeben ist, wird zum Beginn der »n«-ten\n"
"    übergeordneten Schleife gesprungen.\n"
"\n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, außer wenn »n« nicht größer oder gleich 1 ist."

# builtin
#: builtins.c:354
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Führt ein in der Shell definiertes Kommando aus.\n"
"\n"
"    Führt ein in der Shell definiertes Kommando ohne vorherige\n"
"    Befehlssuche aus. Dies ist dann nützlich, wenn das Kommando als\n"
"    Shell-Funktion reimplementiert werden soll, aber das Kommando\n"
"    innerhalb der neuen Funktion aufgerufen wird.\n"
"\n"
"    Rückgabewert: \n"
"    Der Rückgabewert des aufgerufenen Kommandos oder »falsch«, wenn\n"
"    dieses nicht existiert."

# caller
#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Gibt Informationen zum aktuellen Subroutinenaufruf aus.\n"
"\n"
"    Ohne Argument wird die Zeilennummer und der Dateiname angezeigt. Mit\n"
"    Argument werden Zeilennummer, Subroutinenname und Dateiname ausgegeben.\n"
"    Mit diesen Informationen kann ein Stacktrace erzeugt werden.\n"
"\n"
"    Das Argument gibt die angezeigte Position im Funktionsaufrufstapel an,\n"
"    wobei 0 der aktuelle Funktionsaufruf ist.\n"
"\n"
"    Rückgabewert:\n"
"    Ist ungleich 0 wenn keine Shellfunktion ausgeführt wird oder das "
"Argument\n"
"    ungültig ist, sonst 0."

# cd
#: builtins.c:387
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname "
"component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully "
"when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Wechselt das Arbeitsverzeichnis.\n"
"\n"
"    Wechselt in das angegebene Arbeitsverzeichnis. Ohne Angabe eines\n"
"    Verzeichnisses wird in das in der Variable HOME definierte\n"
"    Verzeichnis gewechselt.\n"
"\n"
"    Die Variable CDPATH definiert den Suchpfad, in dem nach dem\n"
"    angegebenen Verzeichnisnamen gesucht wird. Mehrere Pfade werden\n"
"    durch Doppelpunkte »:« getrennt. Ein leerer Pfadname entspricht\n"
"    dem aktuellen Verzeichnis. Mit einem vollständigen Pfadnamen wird\n"
"    CDPATH nicht benutzt.\n"
"\n"
"    Wird kein entsprechendes Verzeichnis gefunden und die Shelloption\n"
"    »cdable_vars« ist gesetzt, dann wird der `Wert' als Variable\n"
"    interpretiert. Dessen Inhalt wird dann als Verzeichnisname\n"
"    verwendet.\n"
"\n"
"    Optionen:\n"
"      -L        Erzwingt, dass symbolischen Links gefolgt wird.\n"
"                Symbolische Links im aktuellen Verzeichnis werden nach\n"
"                dem übergeordneten Verzeichnis aufgelöst.\n"
"      -P        Symbolische Links werden ignoriert. Symbolische\n"
"                Links im aktuellen Verzeichnis werden vor dem\n"
"                übergeordneten Verzeichnis aufgelöst.\n"
"      -e        Wenn mit der Option »-P« das aktuelle Arbeitsverzeichnis\n"
"                nicht ermittelt werden kann, wird mit einem Rückgabewert\n"
"                ungleich 0 abgebrochen.\n"
"      -@        Wenn es das System unterstützt, wird eine Datei mit\n"
"                erweiterten Attributen als ein Verzeichnis angezeigt,\n"
"                welches die erweiterten Attribute enthält.\n"
"\n"
"    Standardmäßig wird symbolischen Links gefolgt (Option -L).\n"
"    Das übergeordnete Verzeichnis wird ermittelt, indem der\n"
"    Dateiname am letzten Schrägstrich gekürzt wird, oder es wird der\n"
"    Anfang von DIR verwendet.\n"
"\n"
"    Rückgabewert:\n"
"    Der Rückgabewert ist 0, wenn das Verzeichnis erfolgreich\n"
"    gewechselt wurde, oder wenn die Option -P angegeben und $PWD\n"
"    erfolgreich gesetzt werden konnte. Sonst ist er ungleich 0."

# pwd
#: builtins.c:425
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Gibt den Namen des aktuellen Arbeitsverzeichnisses aus.\n"
"\n"
"    Optionen:\n"
"      -L        Gibt den Inhalt der Variable $PWD aus, wenn sie das "
"aktuelle\n"
"                Arbeitsverzeichnis enthält.\n"
"      -P        Gibt den physischen Verzeichnispfad aus, ohne symbolische\n"
"                Links.\n"
"\n"
"    Standardmäßig wird immer die Option »-L« gesetzt.\n"
"\n"
"    Rückgabewert:\n"
"    Ist 0, außer wenn eine ungültige Option angegeben oder das aktuelle\n"
"    Verzeichnis nicht lesbar ist."

# colon
#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Leeranweisung.\n"
"\n"
"    Leeranweisung; das Kommando hat keine Wirkung.\n"
"\n"
"    Rückgabewert:\n"
"    Das Kommando ist immer »wahr«."

# true
#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Gibt »wahr« zurück.\n"
"    \n"
"    Rückgabewert:\n"
"    Immer »wahr«."

#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Gibt »falsch« zurück.\n"
"    \n"
"    Rückgabewert:\n"
"    Immer »falsch«."

# command
#: builtins.c:471
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Führt ein einfaches Kommando aus oder zeigt Informationen über Kommandos "
"an.\n"
"\n"
"    Führt das Kommando mit den angegebenen Argumenten aus, ohne\n"
"    Shell-Funktion nachzuschlagen oder zeigt Informationen über die\n"
"    Kommandos an. Dadurch können auch dann Kommandos ausgeführt\n"
"    werden, wenn eine Shell-Funktion gleichen Namens existiert.\n"
"\n"
"    Optionen:\n"
"      -p        Es wird ein Standardwert für PATH verwendet, der "
"garantiert,\n"
"                dass alle Standard-Dienstprogramme gefunden werden.\n"
"      -v        Beschreibung des Kommandos ausgeben.\n"
"                Ähnlich dem eingebauten Kommando »type«.\n"
"      -V        Eine ausführlichere Beschreibung jedes Kommandos ausgeben.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt den Rückgabewert des Kommandos zurück, oder eine Fehlermeldung, "
"wenn\n"
"    das Kommando nicht gefunden wird."

# declare
#: builtins.c:490
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Setzt Variablenwerte und deren Attribute.\n"
"\n"
"    Deklariert Variablen und weist ihnen Attribute zu. Wenn keine Namen\n"
"    angegeben sind, werden die Attribute und Werte aller Variablen "
"ausgegeben.\n"
"    \n"
"    Optionen:\n"
"      -f        Schränkt Aktionen oder Anzeigen auf Funktionsnamen\n"
"                und Definitionen ein.\n"
"      -F        Zeigt nur Funktionsnamen an (inklusive Zeilennummer\n"
"                und Quelldatei beim Debuggen).\n"
"      -g        Deklariert globale Varieblen innerhalb einer\n"
"                Shellfunktion; wird ansonsten ignoriert.\n"
"      -I        Eine neue lokale Variable erhält die Attribute und Werte "
"der\n"
"                Variable mit gleichen Namen im vorherigen "
"Gültigkeitsbereich. \n"
"      -p        Zeigt die Attribute und Werte jeder angegebenen\n"
"                Variable an.\n"
"\n"
"    Attribute setzen:\n"
"      -a\tDeklariert ein indiziertes Feld (wenn unterstützt).\n"
"      -A\tDeklariert ein assoziatives Feld (wenn unterstützt).\n"
"      -i\tDeklariert eine ganzzahlige Variable.\n"
"      -l\tKonvertiert die übergebenen Werte zu Kleinbuchstaben.\n"
"      -n\tDer Name wird als Variable interpretiert. \n"
"      -r\tDeklariert nur lesbare Variablen.\n"
"      -t\tWeist das Attribut »trace« zu.\n"
"      -u\tKonvertiert die übergebenen Werte in Großbuchstaben.\n"
"      -x\tExportiert die Variablen.\n"
"\n"
"    Das Voranstellen von »+« anstelle von »-« schaltet die angegebenen\n"
"    Attribute ab.\n"
"\n"
"    Für ganzzahlige Variablen werden bei der Zuweisung arithmetische\n"
"    Berechnungen durchgeführt (siehe »help let«).\n"
"\n"
"    Innerhalb einer Funktion werden lokale Variablen erzeugt. Die\n"
"    Option »-g« unterdrückt dieses Verhalten.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer eine ungültige Option wurde angegeben,\n"
"    oder ein Fehler trat auf."

#: builtins.c:532
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Setzt Variablen Werte und Eigenschaften\n"
"\n"
"    Synonym für »declare«. Siehe »help declare«."

#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Definiert lokale Variablen.\n"
"\n"
"    Erzeugt eine lokale Variable Name und weist ihr den Wert Wert zu.\n"
"    Option kann eine beliebige von »declare« akzeptierte Option sein.\n"
"\n"
"    Lokale Variablen können nur innerhalb einer Funktion benutzt\n"
"    werden. Sie sind nur in der sie erzeugenden Funktion und ihren\n"
"    Kindern sichtbar.\n"
"\n"
"    Rückgabewert: \n"
"    Liefert 0 außer bei Angabe einer ungültigen Option, einer\n"
"    fehlerhaften Variablenzuweisung oder dem Aufruf außerhalb einer\n"
"    Funktion."

# echo
#: builtins.c:557
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by "
"a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value "
"HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal "
"value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Ausgabe der Argumente auf die Standardausgabe.\n"
"\n"
"    Zeigt die Argumente auf der Standardausgabe gefolgt von einem\n"
"    Zeilenumbruch an.\n"
"\n"
"    Optionen:\n"
"      -n\tKeinen Zeilenumbruch anfügen\n"
"      -e\tInterpretation der folgenden Escape-Sequenzen zulassen\n"
"      -E\tKeine Interpretation der Escape-Sequenzen.\n"
"\n"
"    »echo« interpretiert die folgenden Escape-Sequenzen:\n"
"      \a\tAlarm (Glocke)\n"
"      \\b\tRücktaste (Backspace)\n"
"      \\c\tweitere Ausgabe unterdrücken\n"
"      \\e\tEscape-Zeichen\n"
"      \\E\tEscape-Zeichen\n"
"      \\f\tSeitenvorschub\n"
"      \\n\tZeilenvorschub\n"
"      \\r\tWagenrücklauf\n"
"      \\t\tHorizontaler Tabulator\n"
"      \\v\tVertikaler Tabulator\n"
"      \\\\tumgekehrter Schrägstrich (Backslash)\n"
"      \\0nnn\tZeichen mit dem ASCII-Code »NNN« (oktal). »NNN« kann null\n"
"    \t\tbis drei oktale Ziffern haben.\n"
"      \\xHH\tAcht-Bit-Zeichen mit dem Wert »HH« (hexadezimal). »HH«\n"
"    \t\tkann eine oder zwei hexadezimale Ziffern haben.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer ein Ausgabefehler tritt auf."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Ausgabe der Argumente auf die Standardausgabe.\n"
"\n"
"    Zeigt die Argumente auf der Standardausgabe an, gefolgt von einem\n"
"    Zeilenumbruch.\n"
"\n"
"    Option:\n"
"      -n\tkeinen Zeilenumbruch anfügen.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer nach einem Schreibfehler."

# enable
#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Eingebaute Shell-Kommandos aktivieren und deaktivieren.\n"
"\n"
"    Aktiviert und deaktiviert eingebaute Shell-Kommandos. Die Deaktivierung\n"
"    erlaubt Ihnen, eigene Kommandos mit demselben Namen wie die eingebauten\n"
"    Kommandos zu nutzen, ohne den kompletten Pfad angeben zu müssen.\n"
"\n"
"    Optionen:\n"
"      -a\tGibt eine Liste der eingebauten Kommandos aus inklusive der\n"
"        \tInformation, ob sie aktiv sind oder nicht.\n"
"\n"
"      -n\tdeaktiviert jedes angegebene Kommando oder gibt eine\n"
"        \tListe der deaktivierten eingebauten Kommandos aus.\n"
"      -p\tGibt eine Liste der eingebauten Kommandos in einem\n"
"        \twiederverwendbaren Format aus.\n"
"      -s\tGibt nur die Namen der »speziellen« in POSIX eingebauten\n"
"        \tKommandos aus.\n"
"\n"
"    Optionen zum Beeinflussen des dynamischen Ladens:\n"
"      -f\tLädt ein eingebautes Kommando aus der angegebenen Datei.\n"
"      -d\tEntfernt ein mit »-f« geladenes Kommando.\n"
"\n"
"    Ohne Optionen wird jedes angegebene Kommando aktiviert.\n"
"\n"
"    Um das unter $PATH liegende Kommando »test« anstelle der eingebauten\n"
"    Version zu nutzen, geben Sie »enable -n test« ein.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer Name ist kein eingebautes Kommando\n"
"    oder ein Fehler tritt auf."

#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Führt die Argumente als Shellkommando aus.\n"
"\n"
"    Fügt die Argumente zu einer Zeichenkette zusammen und verwendet\n"
"    das Ergebnis als Eingebe in eine Shell, welche die enthaltenen\n"
"    Kommandos ausführt.\n"
"\n"
"    Rückgabewert:\n"
"    Der Status des Kommandos oder Erfolg, wenn das Kommando leer war."

# getopts
#: builtins.c:652
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Verarbeitet Optionsargumente.\n"
"\n"
"    Getopts wird von Shellprozeduren verwendet, um die\n"
"    Kommandozeilenoptionen auszuwerten.\n"
"\n"
"    \"Optionen\" enthält die auszuwertenden Buchstaben. Ein Doppelpunkt\n"
"    nach dem Buchstaben zeigt an, dass ein Argument erwartet wird,\n"
"    welches durch ein Leerzeichen von der Option getrennt ist.\n"
"\n"
"    Bei jedem Aufruf von »getopts« wird die nächste Option der\n"
"    $Variable zugewiesen. Diese wird angelegt, falls sie noch\n"
"    nicht existiert. Weiterhin wird der Index des nächsten zu\n"
"    verarbeitenden Arguments der Shell-Variablen OPTIND\n"
"    zugewiesen. OPTIND wird bei jedem Aufruf einer Shell oder eines\n"
"    Shell-Skripts mit 1 initialisiert. Wenn eine Option ein Argument\n"
"    benötigt, wird dieses OPTARG zugewiesen.\n"
"\n"
"    Für Fehlermeldungen gibt es zwei Varianten. Wenn das erste\n"
"    Zeichen des Optionsstrings ein Doppelpunkt ist, wird der stille\n"
"    Fehlermodus von »getopts« verwendet. In diesem Modus wird keine\n"
"    Fehlermeldung ausgegeben. Wenn eine ungültige Option erkannt wird,\n"
"    wird das gefundene Optionenzeichen OPTARG zugewiesen. Wenn ein\n"
"    benötigtes Argument fehlt, wird ein »:« der Variable zugewiesen\n"
"    und OPTARG auf das gefundene Optionenzeichen gesetzt. Im anderen\n"
"    Fehlermodus wird ein »?« der Variable zugewiesen, OPTARG geleert\n"
"    und eine Fehlermeldung ausgegeben.\n"
"\n"
"    Wenn die Shell-Variable OPTERR den Wert »0« hat, werden durch getopts\n"
"    keine Fehlermeldungen ausgegeben, auch wenn das erste Zeichen\n"
"    von OPTSTRING kein Doppelpunkt ist. OPTERR hat den Vorgabewert »1«.\n"
"\n"
"    Wenn im Aufruf von »getops« die »Argumente« angegeben sind, werden "
"diese\n"
"    verarbeitet. Ansonsten werden die von der Position abhängigen\n"
"    Parameter ($1, $2, etc.) verarbeitet.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück wenn eine Option gefunden wird und\n"
"    »gescheitert«, wenn das Ende der Optionen erreicht oder ein Fehler\n"
"    aufgetreten ist."

# exec
#: builtins.c:694
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Ersetzt die Shell durch das angegebene Kommando.\n"
"\n"
"    Führt das angegebene Kommando einschließlich dessen Optionen an\n"
"    Stelle der Shell aus. Wenn kein Kommando angegeben ist, wirken\n"
"    alle Weiterleitungen für die aktuellen Shell.\n"
"\n"
"    Optionen:\n"
"      -a Name\tSetzt den Namen als nulltes Argument für das Kommando.\n"
"      -c\tFührt das Kommando in einer leeren Umgebung aus.\n"
"      -l\tSetzt einen Strich in das nullte Argument für das Kommando.\n"
"\n"
"    Wenn das Kommando nicht ausgeführt werden kann, wird eine nicht\n"
"    interaktive Shell beendet, außer die Shell-Option »execfail« ist\n"
"    gesetzt.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt »Erfolg« zurück, außer das Kommando wurde nicht gefunden oder\n"
"    ein Weiterleitungsfehler trat auf."

# exit
#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Beendet die aktuelle Shell.\n"
"\n"
"    Beendet die aktuelle Shell mit dem Rückgabewert N. Wenn N nicht "
"angegeben\n"
"    ist, wird der Rückgabewert des letzten ausgeführten Kommandos übernommen."

# logout
#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"Beendet eine Login-Shell.\n"
"\n"
"    Beendet eine Login-Shell mit dem Rückgabewert »n«. Wenn logout\n"
"    nicht von einer Login-Shell aus ausgeführt wurde, wird ein Fehler\n"
"    zurückgegeben."

# fc
#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"Anzeigen oder Ausführen von Befehlen aus der History-Liste.\n"
"    \n"
"    fc wird verwendet, um Befehle aus der History-Liste aufzulisten,\n"
"    zu bearbeiten und erneut auszuführen.  FIRST und LAST können\n"
"    Zahlen sein, die den Bereich angeben, oder FIRST kann eine\n"
"    Zeichenkette sein, was bedeutet, dass der jüngste Befehl mit\n"
"    dieser Zeichenfolge beginnt.\n"
"    \n"
"    Optionen:\n"
"      -e ENAME Auswahl des zu verwendenden Editors.  Standard sind FCEDIT,\n"
"         dann EDITOR, dann vi.\n"
"      -l Zeilen auflisten statt bearbeiten.\n"
"      -n Zeilennummern beim Auflisten weglassen.\n"
"      -r kehrt die Reihenfolge der Zeilen um (die neuesten Zeilen zuerst).\n"
"    \n"
"    Mit `fc -s [pat=rep ...] [command]' wird COMMAND erneut\n"
"    ausgeführt, nachdem die Ersetzung OLD=NEW durchgeführt wurde.\n"
"    \n"
"    Ein nützlicher Alias ist r='fc -s', so dass die Eingabe von `r cc'\n"
"    den letzten Befehl ausführt, der mit \"cc\" beginnt, und die Eingabe\n"
"    von \"r\" den letzten Befehl erneut ausführt.\n"
"    \n"
"    Exit-Status:\n"
"    Gibt den Erfolg oder den Status des ausgeführten Befehls zurück;\n"
"    ungleich Null, wenn ein Fehler auftritt."

#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Bringt einen Job in den Vordergrund.\n"
"\n"
"    Bringt den mit JOB_SPEC bezeichneten Prozess als aktuellen Job in den\n"
"    Vordergrund. Wenn JOB_SPEC nicht angegeben ist, wird der zuletzt\n"
"    angehaltene Job verwendet.\n"
"\n"
"    Rückgabewert:\n"
"    Status des in den Vordergrund geholten Jobs oder Fehler."

#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Bringt einen Job in den Hintergrund.\n"
"\n"
"    Bringt den mit JOB_SPEC bezeichneten Job in den Hintergrund,\n"
"    als ob er mit »&« gestartet wurde.\n"
"\n"
"    Rückgabewert:\n"
"    Immer Erfolg, außer wenn die Jobsteuerung nicht verfügbar ist\n"
"    oder ein Fehler auftritt."

# hash
#: builtins.c:793
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Programpfade merken oder anzeigen.\n"
"    \n"
"    Ermittelt und speichert den vollständigen Pfadnamen jedes\n"
"    Kommandos NAME.  Wenn keine Argumente angegeben werden, werden\n"
"    Informationen über gespeicherte Kommandod angezeigt.\n"
"    \n"
"    Optionen:\n"
"      -d Vergessen des Speicherortes für jeden NAME\n"
"      -l Anzeige in einem Format, das als Eingabe wiederverwendet werden "
"kann\n"
"      -p Pfadname verwendet PATHNAME als den vollständigen Pfadnamen von "
"NAME\n"
"      -r vergisst alle gespeicherten Pfade\n"
"      \n"
"      -t gibt den Speicherort jedes NAMENS aus, wobei jedem\n"
"         Speicherort der entsprechende NAME vorangestellt wird,\n"
"         wenn mehrere NAMEs angegeben sind\n"
"                \n"
"    Argumente:\n"
"        NAME    Jeder NAME wird in $PATH gesucht und in die Liste\n"
"        der gespeicherten Befehle hinzugefügt.\n"
"    \n"
"    Exit-Status:\n"
"    Gibt Erfolg zurück, es sei denn, NAME wird nicht gefunden oder es\n"
"    wird eine ungültige Option angegeben."

# help
#: builtins.c:818
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"Informationen zu eingebauten Kommandos.\n"
"\n"
"    Zeigt kurze Informationen zu eingebauten Kommandos an. Wenn ein\n"
"    Muster angegeben ist, dann wird eine ausführliche Anleitung zu\n"
"    allen Kommandos mit zutreffendem Muster angezeigt. Sonst wird die\n"
"    Liste der Hilfethemen ausgegeben.\n"
"\n"
"    Optionen:\n"
"      -d\tKurzbeschreibung für jedes Thema\n"
"      -m\tAnzeige im Manpage-Format.\n"
"      -s\tGibt eine kurze Zusammenfassung für jedes angegebene\n"
"        \tangegebene Thema aus\n"
"\n"
"    Argumente:\n"
"      Muster\tDas gesuchte Hilfetheme\n"
"\n"
"    Rückgabestatus:\n"
"    Erfolg, außer wenn das Muster nicht gefunden oder eine ungültige Option\n"
"    angegeben wurde."

# history
#: builtins.c:842
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Zeigt die Verlaufsliste an oder bearbeitet sie.\n"
"    \n"
"    Zeigt die Verlaufsliste mit Zeilennummern an und stellt jedem\n"
"    geänderten Eintrag ein `*' vorangestellt.  Ein Argument von N\n"
"    listet nur die letzten N Einträge auf.\n"
"    \n"
"    Optionen:\n"
"      -c Löscht die Verlaufsliste, indem alle Einträge gelöscht werden.\n"
"      -d offset löscht den Verlaufseintrag an der Position\n"
"         OFFSET. Negative Offsets zählen vom Verlaufslistenende\n"
"         zurück.\n"
"      -a Anhängen vom Verlauf dieser Sitzung an die Verlaufsdatei.\n"
"      -n alle nicht bereits aus der Verlaufsdatei gelesenen.\n"
"         Verlaufszeilen lesen und an die Verlaufsliste anhängen.\n"
"      -r liest die Verlaufsdatei und hängt den Inhalt an die\n"
"         Verlaufsliste an.\n"
"      -w schreibt den aktuellen Verlauf in die Verlaufsdatei.\n"
"      -p führt eine Verlaufserweiterung für jedes ARG durch und zeigt\n"
"         das Ergebnis an, ohne es in der Verlaufslise einzutragen.\n"
"      -s die ARGs als einen einzigen Eintrag an die History-Liste anhängen.\n"
"    \n"
"    Wenn FILENAME angegeben ist, wird dieser als History-Datei verwendet.\n"
"    Andernfalls, wenn HISTFILE einen Wert hat, wird dieser verwendet,\n"
"    sonst ~/.bash_history.\n"
"    \n"
"    Wenn die Variable HISTTIMEFORMAT gesetzt und nicht null ist, wird\n"
"    ihr Wert verwendet als Formatierungszeichenfolge für strftime(3)\n"
"    verwendet, um den Zeitstempel zu Zeitstempel für jeden angezeigten\n"
"    History-Eintrag zu drucken.  Andernfalls werden keine Zeitstempel\n"
"    gedruckt.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt einen Erfolg zurück, es sei denn, es wurde eine ungültige\n"
"    Option angegeben oder es ist ein Fehler aufgetreten."

# jobs
#: builtins.c:879
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Auftragstatus anzeigen.\n"
"    \n"
"    Listet die aktiven Aufträge auf.  JOBSPEC schränkt die Ausgabe auf\n"
"    diesen Auftrag ein.  Ohne Optionen werden die Status der aktiven\n"
"    Aufträge angezeigt.\n"
"    \n"
"    Optionen:\n"
"      -l zeigt zusätzlich auch die Prozessnummern an.\n"
"      -n zeigt nur die Prozesse an, deren Status sich seit der letzten\n"
"         Benachrichtigung geändert haben.\n"
"      -p zeigt nur Prozessnummern an.\n"
"      -r zeigt nur laufende Aufträge an.\n"
"      -s zeigt nur gestoppte Aufträge an\n"
"    \n"
"    Mit der Option -x wird COMMAND ausgeführt, nachdem alle in ARGS\n"
"    enthaltenen Auftragsspezifikationen durch die zugehörigen\n"
"    Prozesnummern ersetzt worden sind.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt einen Erfolg zurück, es sei denn, es wurde eine ungültige\n"
"    Option angegeben oder es ist ein Fehler aufgetreten.  Wenn -x\n"
"    verwendet wird, wird der Rückgebewert von COMMAND zurückgegeben."

# disown
#: builtins.c:906
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Entfernt Aufträge aus der aktuellen Shell.\n"
"    \n"
"    Entfernt jedes JOBSPEC-Argument aus der Tabelle der aktiven\n"
"    Aufträge. Ohne JOBSPECs verwendet die Shell ihre Vorstellung vom\n"
"    aktuellen Auftrag.\n"
"    \n"
"    Optionen:\n"
"      -a entfernt alle Aufträge, wenn JOBSPEC nicht angegeben wird.\n"
"      -h JOBSPEC maskieren, so dass der Auftrag kein SIGHUP erhält,\n"
"         wenn die Shell ein SIGHUP empfängt.\n"
"      -r entfernt nur laufende Aufträge.\n"
"    \n"
"    Beenden Status:\n"
"    Gibt Erfolg zurück, außer wenn eine ungültige Option oder\n"
"    JOBSPEC angegeben wurde."

# kill
#: builtins.c:925
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Sendet ein Signal an einen Auftrag.\n"
"    \n"
"    Sendet den durch PID oder JOBSPEC identifizierten Prozessen das\n"
"    mit SIGSPEC oder SIGNUM anggebene Signal. Wenn weder SIGSPEC\n"
"    noch SIGNUM angegeben sind, dann wird wird SIGTERM gesendet.\n"
"    \n"
"    Optionen:\n"
"      -s sig SIG ist ein Signalname.\n"
"      -n sig SIG ist eine Signalnummer.\n"
"      -l listet die Signalnamen auf. Wenn Argumente auf `-l' folgen,\n"
"         werden für diese Signalnummern die Namen aufgelistet.\n"
"      -L Synonym für -l.\n"
"    \n"
"    Kill ist ein in die Shell eingebaute Funktion, da diese erlaubt,\n"
"    Auftrags- statt Prozessnummern anzugeben. Weierhin kann Kill\n"
"    Prozesse auch dann beenden, wenn die maximal erlaubte\n"
"    Prozessanzahl erreicht ist.\n"
"    \n"
"    Exit-Status:\n"
"    Gibt Erfolg zurück, es sei denn, es wurde eine ungültige Option\n"
"    angegeben oder es ist ein Fehler aufgetreten."

#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Auswerten arithmetischer Ausdrücke.\n"
"    \n"
"    Jedes ARG wird als arithmetischer Ausdruck ausgewertet.  Die\n"
"    Auswertung erfolgt in Ganzzahlen mit fester Breite ohne\n"
"    Überprüfung auf Überlauf. Division durch 0 wird abgefangen und als\n"
"    Fehler gekennzeichnet.  Die folgende Liste von Operatoren ist in\n"
"    abnehmender Präferenz nach gleichrangigen Operatoren gruppiert.\n"
"    \n"
"    \tid++, id-- Variable post-increment, post-decrement\n"
"    \t++id, --id Variable pre-increment, pre-decrement\n"
"    \t-, + unäres Minus, Plus\n"
"    \t!, ~ logische und bitweise Negation\n"
"    \t** Potenzierung\n"
"    \t*, /, % Multiplikation, Division, Rest\n"
"    \t+, - Addition, Subtraktion\n"
"    \t<<, >> bitweise Links- und Rechtsverschiebung\n"
"    \t<=, >=, <, > Vergleich\n"
"    \t==, != Gleichheit, Ungleichheit\n"
"    \t& bitweises UND\n"
"    \t^ bitweises XOR\n"
"    \t| bitweises ODER\n"
"    \t&& logisches UND\n"
"    \t|| logisches OR\n"
"    \texpr ? expr : expr\n"
"               Bedingte Ausführung\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |= Zuweisung\n"
"    \n"
"    Shell-Variablen sind als Operanden zulässig. Der Variablenname\n"
"    wird innerhalb eines Ausdrucks durch seinen Wert (der in eine\n"
"    Ganzzahl mit fester Breite umgewandelt wird) ersetzt.  Das\n"
"    Integer-Attribut der Variablen muss nicht eingeschaltet sein, um\n"
"    in einem Ausdruck verwendet zu werden.\n"
"    \n"
"    Die Operatoren werden in der Reihenfolge ihres Vorrangs\n"
"    ausgewertet. Unterausdrücke in Klammern werden zuerst ausgewertet\n"
"    und können die obigen Rangfolge Regeln außer Kraft setzen.\n"
"    \n"
"    Rückgabewert:\n"
"    Wenn der letzte ARG 0 ergibt, gibt let 1 zurück; andernfalls gibt let 0 "
"zurück."

# read
#: builtins.c:994
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters. By default, the backslash character escapes delimiter "
"characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out\n"
"    (in which case it's greater than 128), a variable assignment error "
"occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Liest eine Zeile von der Standardeingabe und teilt sie in Felder auf.\n"
"    \n"
"    Liest eine einzelne Zeile aus der Standardeingabe oder vom\n"
"    Dateideskriptor FD wenn die Option -u angegeben ist.  Die Zeile\n"
"    wird wie bei der Wortaufteilung in Felder aufgeteilt aufgeteilt,\n"
"    und das erste Wort wird dem ersten NAME zugewiesen, das zweite\n"
"    NAME zugewiesen, das zweite Wort dem zweiten NAME usw., wobei alle\n"
"    verbleibenden Wörter dem dem letzten NAME zugeordnet werden. Die\n"
"    in $IFS enthaltenen Zeichen werden als Worttrennzeichen verwendet.\n"
"    \n"
"    Wenn keine NAMEn angegeben werden, wird die gelesene Zeile in der\n"
"    REPLY-Variablen gespeichert.\n"
"    \n"
"    Optionen:\n"
"      -a array weist die gelesenen Wörter den aufeinanderfolgenden\n"
"               Indizes der Array Variable ARRAY, beginnend bei Null.\n"
"      -d delim fortfahren, bis das erste Zeichen von DELIM gelesen\n"
"               wird, anstelle von statt Newline.\n"
"      -e Readline verwenden, um die Zeile zu lesen.\n"
"      -i text TEXT als Anfangstext für Readline verwenden.\n"
"      -n nchars Liest maximal NCHARS Zeichen, ohne ein Zeilenumbruch\n"
"    \t\tzu suchen. Worttrennzeichen werden ausgewertet.\n"
"      -N nchars Liest genau NCHARS Zeichen, bis EOF oder einer\n"
"    \t\tZeitüberschreitung. Worttrennzeichen werden ignoriert.\n"
"      -p prompt Gibt vor dem Lesen die Zeichenkette PROMPT ohne einen\n"
"    \t\tabschließenden Zeilenumbruch aus.\n"
"      -r        lässt keine Backslashes als Escape-Zeichen zu\n"
"      -s        keine Echo-Eingabe von einem Terminal\n"
"      -t timeout\n"
"                Zeitüberschreitung und Rückgabe eines Fehlers, wenn\n"
"    \t\teine vollständige Eingabezeile nicht innerhalb von\n"
"    \t\tTIMEOUT Sekunden gelesen wird. Die TMOUT Variable\n"
"    \t\tenthält das Standard-Timeout.  TIMEOUT kann als\n"
"    \t\tBruchteil angegeben werden.  Wenn TIMEOUT gleich 0\n"
"    \t\tist, werden keine daten geleden und gibt Erfolg\n"
"    \t\tzurück, wenn Daten dem angegebenen Dateideskriptor\n"
"    \t\tverfügbar sind.  Der Rückgabewert ist größer als 128,\n"
"    \t\twenn die Zeitüberschreitung abgelaufen ist.\n"
"      -u fd Lesen von Dateideskriptor FD statt von der Standardeingabe\n"
"    \n"
"    Rückgabewert: \n"
"    Der Rückgabewert ist Null. Es sei denn, das Dateiende wurde\n"
"    erreicht, die Lesezeit überschritten (in diesem Fall ist er größer\n"
"    als 128), ein Variablenzuweisungsfehler tritt auf oder ein\n"
"    ungültiger Dateideskriptor wurde als Argument von -u übergeben."

#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Rückkehr aus einer Shell-Funktion.\n"
"    \n"
"    Bewirkt, dass eine Funktion oder ein geladenes Skript mit dem\n"
"    durch N angegebenen Rückgabewert beendet wird.  Wenn N weggelassen\n"
"    wird, wird als Rückgabewert der des zuletzt ausgeführten Befehls\n"
"    verwendet.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt N zurück, oder einen Fehler, wenn return außerhalb einer Funktion\n"
"    oder Skript aufgerufen wird."

# set
#: builtins.c:1055
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell "
"functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Setzen oder Aufheben von Shell-Optionen und Positionsparametern.\n"
"    \n"
"    Den Wert von Shell-Attributen und Positionsparametern ändern, oder\n"
"    die Namen und Werte von Shell-Variablen anzeigen.\n"
"    \n"
"    Optionen:\n"
"      -a Markieren von Variablen die geändert oder erstellt wurden, für den "
"Export.\n"
"      -b Sofortige Benachrichtigung über das Auftragsende.\n"
"      -e Sofortiger Abbruch, wenn ein Befehl mit einem Status ungleich Null "
"beendet wird.\n"
"      -f Deaktiviert das Generieren von Dateinamen (globbing).\n"
"      -h Merkt sich den Speicherort von Befehlen, wenn sie nachgeschlagen "
"werden.\n"
"      -k Alle Zuweisungsargumente werden in die Umgebung für einen\n"
"         Befehl in die Umgebung aufgenommen, nicht nur diejenigen,\n"
"         die dem Befehl vorangestellt sind.\n"
"      -m Die Auftragskontrolle ist aktiviert.\n"
"      -n Befehle lesen, aber nicht ausführen.\n"
"      -o Optionsname\n"
"          Setzt die Variable, die dem Optionsname entspricht:\n"
"              allexport wie -a\n"
"              braceexpand wie -B\n"
"              emacs verwendet eine emacsähnliche Schnittstelle zur "
"Zeilenbearbeitung\n"
"              errexit gleich wie -e\n"
"              errtrace dasselbe wie -E\n"
"              functrace dasselbe wie -T\n"
"              hashall dasselbe wie -h\n"
"              histexpand gleich wie -H\n"
"              history Befehlshistorie aktivieren\n"
"              ignoreeof die Shell wird beim Lesen von EOF nicht beendet\n"
"              interaktive-Kommentare\n"
"                           erlaubt das Erscheinen von Kommentaren in "
"interaktiven Befehlen\n"
"              keyword dasselbe wie -k\n"
"              monitor gleich wie -m\n"
"              noclobber dasselbe wie -C\n"
"              noexec gleich wie -n\n"
"              noglob gleich wie -f\n"
"              nolog wird derzeit akzeptiert, aber ignoriert\n"
"              notify gleich wie -b\n"
"              nounset dasselbe wie -u\n"
"              onecmd dasselbe wie -t\n"
"              physical wie -P\n"
"              pipefail der Rückgabewert einer Pipeline ist der Status\n"
"                       des des letzten Befehls, der mit einem Status\n"
"                       ungleich Null beendet wurde, oder Null, wenn\n"
"                       kein Befehl mit einem Status ungleich Null\n"
"                       beendet wurde.\n"
"             posix     Ändert das Verhalten von bash, wo die Standard\n"
"                       Operation vom Posix-Standard abweicht, um mit\n"
"                       dem Standard übereinstimmen.\n"
"              privilegiert gleich wie -p\n"
"              verbose dasselbe wie -v\n"
"              vi eine vi-ähnliche Schnittstelle zur Zeilenbearbeitung "
"verwenden\n"
"              xtrace dasselbe wie -x\n"
"      -p Wird eingeschaltet, wenn die realen und effektiven\n"
"         Benutzerkennungen nicht übereinstimmen.  Deaktiviert die\n"
"         Verarbeitung der $ENV-Datei und das Importieren von Shell\n"
"         Funktionen.  Wenn diese Option ausgeschalten ist, werden die\n"
"         effektive uid und gid auf die reale uid und gid gesetzt. \n"
"      -t Beenden nach dem Lesen und Ausführen eines Befehls.\n"
"      -u Nicht gesetzte Variablen beim Substituieren als Fehler behandeln.\n"
"      -v Shell-Eingabezeilen ausgeben, wenn sie gelesen werden.\n"
"      -x Befehle und ihre Argumente ausgeben, wenn sie ausgeführt werden.\n"
"      -B Die Shell führt eine Klammererweiterung durch\n"
"      -C Dateien werden bei Ausgabeumleitung nicht überschrieben.\n"
"      -E Wenn gesetzt, wird die Fehlerfalle (trap) an Shell-Funktionen "
"vererbt.\n"
"      -H Aktiviert die !-Stil Verlaufsersetzung.  Diese Option ist\n"
"         bei einer interaktiven Shell standardmäßig aktiviert.\n"
"      -P Symbolische Links werden nicht aufgelöst, wenn Befehle wie\n"
"         z.B. cd, das aktuelle Verzeichnis ändern.\n"
"      -T DEBUG und RETURN Fallen (trap) werden an Shellfunktionen vererbt.\n"
"      -- Weist alle verbleibenden Argumente den Positionsparametern\n"
"         zu.  Sind keine Argumente verblieben, werden die\n"
"         Positionsparameter nicht gesetzt.\n"
"      - Weist alle verbleibenden Argumente den Positionsparametern zu.\n"
"        Die Optionen -x und -v sind ausgeschaltet.\n"
"    \n"
"    Durch Verwenden von + anstelle von - werden Option ausgeschaltet.\n"
"    Die Optionen können auch beim Shellaufruf verwendet werden.  Die\n"
"    aktuelle aktiven Optionen sind in $- gespeichert.  Die restlichen\n"
"    n ARGs sind positionale Parameter und werden der Reihe nach $1,\n"
"    $2, ... $n zugewiesen.  Wenn keine ARGs angegeben werden, werden\n"
"    alle Shell-Variablen ausgegeben.\n"
"    \n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, es sei denn, eine ungültige Option wurde angegeben."

#: builtins.c:1140
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""

#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""

#: builtins.c:1181
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""

#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""

#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""

#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""

#: builtins.c:1262
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""

# [
#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Wertet einen bedingten Ausdruck aus.\n"
"\n"
"    Dieses Kommando entspricht dem Kommando »test«. Jedoch muss das\n"
"    letzte Argument ein »]« sein, welches die öffnende Klammer »[«\n"
"    schließt."

# times
#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Zeigt den Zeitverbrauch an.\n"
"\n"
"    Gibt den kumulierte Nutzer- und Systemzeitverbrauch der Shell und\n"
"    aller von ihr gestarteten Prozesse aus.\n"
"\n"
"    Rückgabewert:\n"
"    Immer 0."

#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  "
"If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or "
"a\n"
"    script run by the . or source builtins finishes executing.  A "
"SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause "
"the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""

#: builtins.c:1401
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""

#: builtins.c:1432
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""

#: builtins.c:1503
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or "
"a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of "
"IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns "
"its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, "
"before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""

#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination "
"status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an "
"invalid\n"
"    option is given."
msgstr ""

#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""

#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1648
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1660
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS "
"has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1672
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""

#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""

#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""

# (( ))
#: builtins.c:1727
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Wertet arithmetische Ausdrücke aus.\n"
"\n"
"    Der Ausdruck wird nach den Regeln für arithmetische Berechnungen\n"
"    ausgewertet. Diese Schreibweise entspricht »let Ausdruck«.\n"
"\n"
"    Rückgabewert:\n"
"    Ist »1«, wenn der arithmetische Ausdruck 0 ergibt, sonst »0«."

# [[
#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Erweiterte Vergleiche.\n"
"    \n"
"    Der Status 0 oder 1 wird abhängig vom Vergleichsergebnis zurückgegeben.\n"
"    Es werden die gleichen Ausdrücke wie in der »test« Funktion "
"unterstützt,\n"
"    die mit folgenden Operatoren verbunden werden können:\n"
"    \n"
"      ( AUSDRUCK )\tErgibt den Wert des AUSDRUCKs\n"
"      ! Ausdruck\t\tNegiert den AUSDRUCK\n"
"      AUSDR1 && AUSDR2\tUnd Verknüpfung der Ausdrücke\n"
"      AUSDR1 || AUSDR2\tOder Verknüpfung der Ausdrücke\n"
"    \n"
"    Die `==' und `!=' Operatoren ermöglichen einen Mustervergleich mit dem\n"
"    rechten Ausdruck als Muster.\n"
"    Der `=~' Operator führt einen Vergleich mit dem regulären Ausdruck\n"
"    in der rechten Seite aus.\n"
"    \n"
"    Die && und || Operatoren werten AUSDR2 nur aus, wenn nicht bereits\n"
"    AUSDR1 das gesamte Ergebnis bestimt.\n"
"    \n"
"    Rückgabewert:\n"
"    0 oder 1 abhängig vom Wert des AUSDRUCKs."

# variable_help
#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"    BASH_VERSION\tVersionsnummer der Bash.\n"
"    CDPATH\tEine durch Doppelpunkte getrennte Liste von\n"
"                Verzeichnissen, die durchsucht werden, wenn das\n"
"                Argument von »cd« nicht im aktuellen Verzeichnis\n"
"                gefunden wird.\n"
"    GLOBIGNORE  Eine durch Doppelpunkte getrennte Liste von\n"
"                Dateinamenmustern, die für die Dateinamensergänzung\n"
"                ignoriert werden.\n"
"    HISTFILE\tDatei, die den Kommandozeilenspeicher enthält.\n"
"    HISTFILESIZE\tMaximale Zeilenanzahl dieser Datei.\n"
"    HISTSIZE\tMaximale Anzahl von Zeilen, auf die der\n"
"                Historymechanismus der Shell zurückgreifen kann.\n"
"    HOME\tHeimatverzeichnis des aktuellen Benutzers.\n"
"    HOSTNAME    Der aktuelle Rechnername.\n"
"    HOSTTYPE\tCPU-Typ des aktuellen Rechners.\n"
"    IGNOREEOF\tLegt die Reaktion der Shell auf ein EOF-Zeichen fest.\n"
"                Wenn die Variable eine ganze Zahl enthält, wird diese\n"
"                Anzahl EOF Zeichen (Ctrl-D) abgewartet, bis die Shell\n"
"                verlassen wird. Der Vorgabewert ist 10. Ist IGNOREEOF\n"
"                nicht gesetzt, signalisiert EOF das Ende der Eingabe.\n"
"    MACHTYPE    Eine Zeichenkette die das aktuell laufende System "
"beschreibt.\n"
"    MAILCHECK\tZeit in Sekunden, nach der nach E-Mails gesehen wird.\n"
"    MAILPATH\tEine durch Doppelpunkt getrennte Liste von Dateinamen,\n"
"                die nach E-Mail durchsucht werden.\n"
"    OSTYPE\tUnix Version, auf der die Bash gegenwärtig läuft.\n"
"    PATH\tDurch Doppelpunkt getrennte Liste von Verzeichnissen,\n"
"                die nach Kommandos durchsucht werden.\n"
"    PROMPT_COMMAND\tKommando, das vor der Anzeige einer primären\n"
"                        Eingabeaufforderung (PS1) ausgeführt wird.\n"
"    PS1                 Zeichenkette, die die primäre\n"
"                        Eingabeaufforderung enthält.\n"
"    PS2                 Zeichenkette, die die sekundäre\n"
"                        Eingabeaufforderung enthält.\n"
"    PWD                 Der vollständige aktuelle Verzeichnisname.\n"
"    SHELLOPTS           Durch Doppelpunkt getrennte Liste der aktiven\n"
"                        Shell-Optionen.\n"
"    TERM\tName des aktuellen Terminaltyps.\n"
"    auto_resume Ein Wert ungleich Null bewirkt, dass ein einzelnes\n"
"                Kommando auf einer Zeile zunächst in der Liste\n"
"                gegenwärtig gestoppter Jobs gesucht und dieser in den\n"
"                Vordergrund geholt wird. »exact« bewirkt, dass das\n"
"                Kommando genau dem Kommando in der Liste der\n"
"                gestoppten Jobs entsprechen muss. Wenn die Variable den\n"
"                Wert »substring« enthält, muss das Kommando einem\n"
"                Substring der Jobbezeichnung entsprechen. Bei einem\n"
"                anderen Wert müssen die ersten Zeichen übereinstimmen.\n"
"    histchars   Zeichen, die die Befehlswiederholung und die\n"
"                Schnellersetzung steuern. An erster Stelle steht\n"
"                das Befehlswiederholungszeichen (normalerweise\n"
"                `!'); an zweiter das `Schnell-Ersetzen-Zeichen'\n"
"                (normalerweise `^'). Das dritte Zeichen ist das\n"
"                `Kommentarzeichen' (normalerweise `#').\n"
"    HISTIGNORE  Eine durch Doppelpunkt getrennte Liste von\n"
"                Mustern, welche die in der\n"
"                Befehlswiederholungsliste zu speichernden\n"
"                Kommandos angibt.\n"

# pushd
#: builtins.c:1822
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Fügt ein Verzeichnis dem Stapel hinzu.\n"
"\n"
"    Legt einen Verzeichnisnamen auf den Verzeichnisstapel oder rotiert\n"
"    diesen so, dass das aktuelle Arbeitsverzeichnis oben liegt. Ohne\n"
"    Argumente werden die obersten zwei Verzeichnisse auf dem Stapel\n"
"    vertauscht.\n"
"\n"
"    Optionen: -n Es wird nur das angebene Verzeichnis dem Stapel\n"
"    \thinzugefügt, aber nicht in das Verzeichnis gewechselt.\n"
"\n"
"    Argumente:    \n"
"    +N\tRotiert den Stapel so, dass das N'te Verzeichnis (angezeigt\n"
"        von `dirs', gezählt von links) oben auf dem Stapels liegt.\n"
"\n"
"    -N\tRotiert den Stapel so, dass das N'te Verzeichnis (angezeigt\n"
"        von `dirs', gezählt von rechts) sich an der Spitze des Stapels\n"
"    \tbefindet.\n"
"\n"
"    Der Verzeichnisstapel kann mit dem Kommando `dirs' angezeigt\n"
"    werden.\n"
"\n"
"    Rückgabewert: \n"
"    Gibt Erfolg zurück, außer wenn ein ungültiges Argument angegeben\n"
"    wurde oder der Verzeichniswechsel nicht erfolgreich war."

# popd
#: builtins.c:1856
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Entfernt Einträge vom Verzeichnisstapel.\n"
"\n"
"    Entfernt Einträge vom Verzeichnisstapel. Ohne Argumente wird der\n"
"    oberste Eintrag entfernt und in das neue oberste Verzeichnis\n"
"    gewechselt.\n"
"\n"
"    Optionen:\n"
"    -n\tEntfernt nur den Verzeichniseintrag und wechselt nicht\n"
"       \tdas Verzeichnis.\n"
"          \n"
"    Argumente:\n"
"    +N\tEntfernt den N-ten Eintrag von links, gezählt von\n"
"        Null, aus der von »dirs« anzeigten Liste. Beispielsweise\n"
"        entfernen »popd +0« den ersten und »popd +1« den zweiten\n"
"        Verzeichniseintrag.\n"
"\n"
"    -N\tEntfernt den N-ten Eintrag von rechts, gezählt von Null,\n"
"      \taus der von »dirs« angeigten Liste. Beispielsweise entfernen\n"
"        »popd -0« den letzten und »popd -1« den vorletzten\n"
"        Verzeichniseintrag.\n"
"\n"
"        Mit »dirs« kann der Verzeichnisstapel angezeigt werden.\n"
"\n"
"        Rückgabewert:\n"
"        Gibt 0 zurück, außer wenn ein ungültiges Argument angegeben\n"
"        wurde oder der Verzeichniswechsel nicht erfolgreich war."

# dirs
#: builtins.c:1886
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Zeigt den Verzeichnisstapel an.\n"
"\n"
"    Zeigt die Liste der gegenwärtig gespeicherten Verzeichnisse.\n"
"    Diese werden mit dem `pushd' Kommando eingetragen und mit dem\n"
"    `popd' Kommando ausgelesen.\n"
"\n"
"    Optionen:\n"
"      -c        Löscht den Verzeichnisstapel.\n"
"      -l        Keine Abkürzung für das Heimatverzeichnis durch die\n"
"                Tilde (~).\n"
"      -p        Ausgabe von einem Eintrag pro Zeile.\n"
"      -v        Ausgabe von einem Eintrag pro Zeile mit Angabe der\n"
"                Position im Stapel<\n"
"\n"
"    Argumente:\n"
"      +N        Gibt das N'te Element von links der Liste aus, die\n"
"                ohne Argumente ausgegeben wird.  Die Zählung beginnt\n"
"                bei 0.\n"
"      -N        Gibt das N'te Element von rechts der Liste aus, die\n"
"                ohne Argumente ausgegeben wird.  Die Zählung beginnt\n"
"                bei 0.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, außer bei einer ungültigen Option oder wenn\n"
"    ein Fehler auftritt."

#: builtins.c:1917
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Setzt oder löscht Shell-Optionen.\n"
"\n"
"    Ändert die in »Optionsnamen« genannten Shell-Optionen. Ohne\n"
"    Argumente wird eine Liste der Shell-Optionen und deren Status\n"
"    ausgegeben.\n"
"\n"
"    Optionen:\n"
"      -o        Beschränkt die Optionsmanen auf die, welche mit \n"
"                »set -o« definiert werden müssen.\n"
"      -p        Gibt alle Shelloptionen und deren Status aus.\n"
"      -q        Unterdrückt Ausgaben.\n"
"      -s        Setzt jede Option in »Optionsname.«\n"
"      -u        Deaktiviert jede Option in »Optionsname«.\n"
"\n"
"    Rückgabewert:\n"
"    Gibt Erfolg zurück, wenn eine Option gesetzt worden ist. Wenn\n"
"    eine ungültige Option angegeben wurde oder eine Option deaktiviert\n"
"    worden ist, wird ein Fehler zurückgegeben."

# printf
#: builtins.c:1938
#, fuzzy
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in "
"printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a "
"format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as "
"appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"Formatierte Ausgabe der ARGUMENTE.\n"
"\n"
"    Optionen:\n"
"      -v var\tDie formatierte Ausgabe ver Variable var zuweisen statt\n"
"        \tsie an die Standardausgebe zu senden.\n"
"\n"
"    Die FORMAT-Zeichenkette kann einfache Zeichen enthalten, die "
"unverändert\n"
"    an die Standardausgabe geschickt werden. Escape-Sequenzen werden "
"umgewandelt\n"
"    und an die Standardausgabe geschickt sowie Formatanweisungen, welche "
"das \n"
"    nachfolgende ARGUMENT auswerten und ausgeben.\n"
"\n"
"    Gegenüber der in printf(1) beschriebenen Standardverion werden "
"zusätzliche\n"
"    Formatanweisungen ausgewertet:\n"
"\n"
"      %b\tWertet Escape-Sequenzen des zugehörigen Arguments aus.\n"
"      %q\tBettet das Argument so ein, dass es als Shelleingabe\n"
"                verwendet werden kann.\n"
"      %(fmt)T\tAusgabe der aus FMT entstehende Datum-Zeit Zeichenkette, "
"dass\n"
"                sie als Zeichenkette für strftime(3) verwendet werden kann.\n"
"\n"
"    Die Formatangabe wird wiederverwendet, bis alle Argumente ausgewertet\n"
"    sind. Wenn weniger Argumente als Formatangaben vorhanden sind, werden "
"für\n"
"    die Argumente Nullwerte bzw. leere Zeichenketten eingesetzt.\n"
"\n"
"    Rücgabewert:\n"
"    Gibt Erfolg zurück, außer es wird eine ungültige Option angegeben oder "
"ein\n"
"    Aus- bzw. Zuweisungsfehler auftritt."

#: builtins.c:1974
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are "
"supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -"
"I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""

# compgen
#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Zeigt mögliche Komplettierungen.\n"
"\n"
"    Wird in Shellfunktionen benutzt, um mögliche Komplettierungen "
"anzuzeigen.\n"
"    Wenn das optionale Wort-Argument angegeben ist, werden Komplettierungen\n"
"    für dieses Wort erzeugt.\n"
"    \n"
"    Rückgabewert:\n"
"    Falsche Optionen oder Fehler führen zu Rückgabewerten ungleich Null."

#: builtins.c:2019
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""

#: builtins.c:2050
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard "
"input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""

# readarray
#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Liest Zeilen einer Datei in eine Array-Variable.\n"
"\n"
"    Ist ein Synonym für »mapfile«."

#, c-format
#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: Ungültiger Schlüssel für das assoziative Array."

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00025.html
#~ msgid "Unknown Signal #"
#~ msgstr "Unbekannte Signalnummer"
