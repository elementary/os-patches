# Mesajele în limba română pentru pachetul bash.
# Copyright (C) 2003 - 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
#
# Eugen Hoanca <eugenh@urban-grafx.ro>, 2003.
# Daniel Șerbănescu <daniel@serbanescu.dk>, 2019.
# Remus-Gabriel Chelu <remusgabriel.chelu@disroot.org>, 2022.
#
# Cronologia traducerii fișierului „bash”:
# Traducerea inițială, făcută de EH, pentru versiunea bash 3.2 (19% - tradus).
# Actualizare a traducerii pentru versiunea 4.0, făcută de EH (24% - tradus).
# Actualizare a traducerii pentru versiunea 5.0, făcută de DȘ (29% - tradus).
# Actualizare a traducerii pentru versiunea 5.1, făcută de R-GC (100% - tradus).
# Actualizare a traducerii pentru versiunea 5.2-rc1, făcută de R-GC.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 5.2-rc1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-11 14:50-0500\n"
"PO-Revision-Date: 2022-06-18 01:02+0200\n"
"Last-Translator: Remus-Gabriel Chelu <remusgabriel.chelu@disroot.org>\n"
"Language-Team: Romanian <translation-team-ro@lists.sourceforge.net>\n"
"Language: ro\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : (n==0 || ((n%100) > 0 && (n%100) < 20)) ? 1 : 2);\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"X-Generator: Poedit 2.3.1\n"
"X-Poedit-SourceCharset: UTF-8\n"

#: arrayfunc.c:66
msgid "bad array subscript"
msgstr "indice de matrice greșit"

#: arrayfunc.c:471 builtins/declare.def:709 variables.c:2242 variables.c:2268
#: variables.c:3101
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: se elimină atributul nameref"

#: arrayfunc.c:496 builtins/declare.def:868
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: nu se poate converti matricea indexată în asociativă"

#: arrayfunc.c:777
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: nu se poate atribui la index ne-numeric"

#: arrayfunc.c:822
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: trebuie să fie folosit un indice atunci când se atribuie unei matrice asociative"

#: bashhist.c:455
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: nu s-a putut crea: %s"

#: bashline.c:4479
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: nu se poate găsi combinația de taste pentru comandă"

#: bashline.c:4637
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: primul caracter care nu este spațiu în alb nu este «\"» (ghilimele duble)"

#: bashline.c:4666
#, c-format
msgid "no closing `%c' in %s"
msgstr "nu se închide „%c” în %s"

#: bashline.c:4697
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: lipsește separatorul două puncte (:)"

#: bashline.c:4733
#, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "„%s”: nu se poate înlătura combinația de taste atribuită la comandă"

# Aici, trebuie folosit forma de plural, așa cum am făcut-o, sau cea de singular:
# extindere (de) acoladă?
#: braces.c:327
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "expansiunea de acolade: nu se poate aloca memorie pentru %s"

#: braces.c:406
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "expansiunea de acolade: a eșuat alocarea memoriei pentru %u elemente"

#: braces.c:451
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "expansiunea de acolade: a eșuat alocarea memoriei pentru „%s”"

#: builtins/alias.def:131 variables.c:1817
#, c-format
msgid "`%s': invalid alias name"
msgstr "„%s”: nume alias nevalid"

#: builtins/bind.def:122 builtins/bind.def:125
msgid "line editing not enabled"
msgstr "editarea liniilor nu este activată"

#: builtins/bind.def:212
#, c-format
msgid "`%s': invalid keymap name"
msgstr "`%s': nume de combinație de taste nevalid"

#: builtins/bind.def:252
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: nu s-a putut citii: %s"

#: builtins/bind.def:328 builtins/bind.def:358
#, c-format
msgid "`%s': unknown function name"
msgstr "„%s”: nume de funcție necunoscut"

#: builtins/bind.def:336
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s nu este asociat niciunei taste.\n"

#: builtins/bind.def:340
#, c-format
msgid "%s can be invoked via "
msgstr "%s poate fi invocat via "

#: builtins/bind.def:378 builtins/bind.def:395
#, c-format
msgid "`%s': cannot unbind"
msgstr "„%s”: atribuirea nu poate fi ștearsă"

#: builtins/break.def:77 builtins/break.def:119
msgid "loop count"
msgstr "contor buclă"

#: builtins/break.def:139
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "are sens numai într-o buclă „for”, „while” sau „until”"

#: builtins/caller.def:136
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Returnează contextul apelului subrutinei curente.\n"
"    \n"
"    Fără EXPR, returnează „$linie $nume_fișier”.  Cu EXPR, returnează\n"
"    „$linie $subrutină $nume_fișier”; aceste informații suplimentare pot să fie\n"
"    folosite pentru a furniza o urmărire a stivei.\n"
"    \n"
"    Valoarea EXPR indică cîte cadre de apel trebuie să se întoarcă înaintea celui\n"
"    curent; cadrul superior este cadrul 0."

#: builtins/cd.def:327
msgid "HOME not set"
msgstr "variabila $HOME nu este definită"

#: builtins/cd.def:335 builtins/common.c:161 test.c:916
msgid "too many arguments"
msgstr "prea mulți parametri"

#: builtins/cd.def:342
msgid "null directory"
msgstr "director nul"

#: builtins/cd.def:353
msgid "OLDPWD not set"
msgstr "variabila $OLDPWD nu este definită"

#: builtins/common.c:96
#, c-format
msgid "line %d: "
msgstr "linia %d: "

#: builtins/common.c:134 error.c:264
#, c-format
msgid "warning: "
msgstr "avertizare: "

#: builtins/common.c:148
#, c-format
msgid "%s: usage: "
msgstr "%s: utilizare: "

#: builtins/common.c:193 shell.c:524 shell.c:866
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: opțiunea necesită un argument"

#: builtins/common.c:200
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: argument numeric necesar"

#: builtins/common.c:207
#, c-format
msgid "%s: not found"
msgstr "%s: nu s-a găsit"

#: builtins/common.c:216 shell.c:879
#, c-format
msgid "%s: invalid option"
msgstr "%s: opțiune nevalidă"

#: builtins/common.c:223
#, c-format
msgid "%s: invalid option name"
msgstr "%s: nume de opțiune nevalid"

#: builtins/common.c:230 execute_cmd.c:2402 general.c:368 general.c:373
#, c-format
msgid "`%s': not a valid identifier"
msgstr "„%s” nu este un identificator valid"

#: builtins/common.c:240
msgid "invalid octal number"
msgstr "număr octal nevalid"

#: builtins/common.c:242
msgid "invalid hex number"
msgstr "număr hexazecimal nevalid"

#: builtins/common.c:244 expr.c:1574
msgid "invalid number"
msgstr "număr nevalid"

#: builtins/common.c:252
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: specificație de semnal nevalidă"

# spec = specificare
# sau
# spec = specificație
# ???
# de rezolvat
# ------------------------------------
# Opinii/Idei?
# ***
# după revizarea fișierului, DȘ, spune:
# 1. „→ și eu aș păstra specificație aici și în restul fișierului”
# ===
# Ok, rămînem cu «spec, specification = specificație»
# .
# 2. → iar job spec l-aș traduce cu „specificația serviciului” (fiind vorba de un proces care rulează pe computer)
# ===
# am tradus «job spec» ca specificație de lucru,
# datorită faptului că «job-urile», nu sunt
# întotdeauna niște servicii, și mai ales datorită
# faptului că adesea sunt o pleiadă de procese,
# grupate (cel mai adesea un proces părinte
# cu fii săi), alteori un grup de procese
# interacționate.
#: builtins/common.c:259
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "„%s”: nu este un pid sau o specificație validă de lucru"

#: builtins/common.c:266 error.c:536
#, c-format
msgid "%s: readonly variable"
msgstr "%s: variabilă protejată la scriere"

#: builtins/common.c:273
#, c-format
msgid "%s: cannot assign"
msgstr "%s: nu se poate atribui"

#: builtins/common.c:281
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s în afara intervalului"

#: builtins/common.c:281 builtins/common.c:283
msgid "argument"
msgstr "argument"

#: builtins/common.c:283
#, c-format
msgid "%s out of range"
msgstr "%s în afara intervalului"

# R-GC, scrie:
# după revizarea fișierului, DȘ, spune:
# «→ la fel și aici, și la următoarele apariții ale lui job, → „nu există asemenea serviciu”»
# ===
# am tradus «job» ca lucrare, datorită faptului
# că «job-urile», nu sunt întotdeauna niște
# servicii, și mai ales datorită faptului că
# adesea sunt o pleiadă de procese, grupate
# (cel mai adesea un proces părinte cu fii săi),
# alteori un grup de procese interacționate.
#: builtins/common.c:291
#, c-format
msgid "%s: no such job"
msgstr "%s: nu există această lucrare"

#: builtins/common.c:299
#, c-format
msgid "%s: no job control"
msgstr "%s: nu există un control de lucrări"

#: builtins/common.c:301
msgid "no job control"
msgstr "nu există un control de lucrări"

#: builtins/common.c:311
#, c-format
msgid "%s: restricted"
msgstr "%s: restricționat"

#: builtins/common.c:313
msgid "restricted"
msgstr "restricționat"

# R-GC, întreabă:
# Ce facem cu „Shell”?
# Cum îl traducem?
# ***
# după revizarea fișierului, DȘ, spune:
# „→ mă trem că „shell” ar trebui să rămână tot „shell”: https://ro.wikipedia.org/wiki/Shell_(informatic%C4%83)”
# ===
# Mda, un răspuns la care mă așteptam; ca un
# fapt divers: nici alte echipe de traducători,
# n-au reușit să „translate” «shell» în altceva
# decît în «shell», au fost încercări (traduceri
# reale) → scoică, cochilie, carapace sau
# ambalaj; cu toate că unele dintre ele, au
# avut oarecare succes, niciuna n-a rezistat
# cu trecerea timpului.
#: builtins/common.c:321
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: nu este o comandă internă"

#: builtins/common.c:330
#, c-format
msgid "write error: %s"
msgstr "eroare de scriere: %s"

#: builtins/common.c:338
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "eroare la configurarea atributelor terminalului: %s"

#: builtins/common.c:340
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "eroare la obținerea atributelor terminalului: %s"

# - Eroare la preluarea...
# - Eroare la obținerea...
# - Eroare la recuperarea...
# Am ales prima variantă, dar este cea mai bună,
# în contextul dat?
#: builtins/common.c:642
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: eroare la preluarea directorului curent: %s: %s\n"

#: builtins/common.c:708 builtins/common.c:710
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: specificație de lucrare, ambiguă"

#: builtins/common.c:971
msgid "help not available in this version"
msgstr "ajutorul nu este disponibil în această versiune"

# R-GC, scrie:
# după revizarea fișierului, DȘ, spune:
# „→ ce zici de „readonly” = „protejat la scriere” (cam lung dar parcă este mai sugestiv)”
# ===
# nu cred c-ar fi o problemă asta, odată ce face
# ca mesajul să fie mai clar, mai sugestiv; dar
# cred că introduce o întrebare:
# de cine/contra cui este protejat?
# ***
# cel puțin de moment, dacă nu definitiv, voi
# aplica sugestia făcută, asupra acestui mesaj
# și aaltora asemănătoare...
#: builtins/common.c:1038 builtins/set.def:953 variables.c:3825
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: nu se poate deconfigura: %s este protejat la scriere"

#: builtins/common.c:1043 builtins/set.def:932 variables.c:3830
#, c-format
msgid "%s: cannot unset"
msgstr "%s: nu se poate deconfigura"

#: builtins/complete.def:287
#, c-format
msgid "%s: invalid action name"
msgstr "%s: nume de acțiune nevalid"

# Întrebare:
# nicio...
# 	sau
# nu există (o)...
#: builtins/complete.def:486 builtins/complete.def:642
#: builtins/complete.def:873
#, c-format
msgid "%s: no completion specification"
msgstr "%s: nicio specificație de completare"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "avertisment: este posibil ca opțiunea „-F” să nu funcționeze așa cum vă așteptați"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "avertisment: este posibil ca opțiunea „-C” să nu funcționeze așa cum vă așteptați"

# Întrebare:
# - În prezent ...
# - În acest moment ...
# - În momentul actual ...
# este formula adecvată contextului?
#: builtins/complete.def:846
msgid "not currently executing completion function"
msgstr "în prezent funcția de completare nu rulează"

#: builtins/declare.def:137
msgid "can only be used in a function"
msgstr "poate fi folosit doar într-o funcție"

#: builtins/declare.def:437
msgid "cannot use `-f' to make functions"
msgstr "nu se poate utiliza „-f” pentru a face funcții"

#: builtins/declare.def:464 execute_cmd.c:6132
#, c-format
msgid "%s: readonly function"
msgstr "%s: funcție protejată la scriere"

#: builtins/declare.def:521 builtins/declare.def:804
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: variabila de referință nu poate fi o matrice"

#: builtins/declare.def:532 variables.c:3359
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr "%s: nu sunt permise auto-referințele la variabile nameref"

#: builtins/declare.def:537 variables.c:2072 variables.c:3278 variables.c:3286
#: variables.c:3356
#, c-format
msgid "%s: circular name reference"
msgstr "%s: referință de nume circulară"

# R-GC, scrie:
# după revizarea fișierului, DȘ, spune:
# „→ cred că s-ar putea pune ghilimele românești”
# ===
# corecție aplicată
#: builtins/declare.def:541 builtins/declare.def:811 builtins/declare.def:820
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "„%s”: nume de variabilă nevalid pentru referință la nume"

# Problemă:
#  in this way = în acest fel
#  in this way = în acest mod
#  in this way = de această formă
# Mă refer la această intrare, care dintre cele
# 3 opțiuni, este cea mai bună?
#: builtins/declare.def:856
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: nu se pot distruge variabilele matrice în acest fel"

#: builtins/declare.def:862 builtins/read.def:887
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: nu se poate converti o matrice asociativă într-o matrice indexată"

# Întrebare:
# - se poate formula mai bine, de exp.:
# alocarea matricei compuse, între ghilimele; este perimată-învechită
#: builtins/declare.def:891
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr "%s: alocarea de matrice compusă între ghilimele este perimată"

#: builtins/enable.def:145 builtins/enable.def:153
msgid "dynamic loading not available"
msgstr "încărcarea dinamică nu este disponibilă"

#: builtins/enable.def:376
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "nu poate deschide obiectul partajat %s: %s"

#: builtins/enable.def:405
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "nu se poate găsi %s în obiectul partajat %s: %s"

#: builtins/enable.def:422
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: comanda internă dinamică a «bash», este deja încărcată"

# De revizat...
#: builtins/enable.def:426
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr "funcția de încărcare pentru %s returnează eroarea (%d): încărcarea a eșuat"

#: builtins/enable.def:551
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: nu este încărcat dinamic"

#: builtins/enable.def:577
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: nu se poate șterge: %s"

#: builtins/evalfile.c:138 builtins/hash.def:185 execute_cmd.c:5959
#, c-format
msgid "%s: is a directory"
msgstr "%s: este un director"

#: builtins/evalfile.c:144
#, c-format
msgid "%s: not a regular file"
msgstr "%s: nu este un fișier normal"

#: builtins/evalfile.c:153
#, c-format
msgid "%s: file is too large"
msgstr "%s: fișierul este prea mare"

#: builtins/evalfile.c:188 builtins/evalfile.c:206 shell.c:1673
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: nu se poate executa fișierul binar"

#: builtins/exec.def:158 builtins/exec.def:160 builtins/exec.def:246
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: nu se poate executa: %s"

#: builtins/exit.def:64
#, c-format
msgid "logout\n"
msgstr "deautentificare\n"

#: builtins/exit.def:89
msgid "not login shell: use `exit'"
msgstr "nu este un shell de autentificare: utilizați „exit”"

#: builtins/exit.def:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Sunt(există) lucrări oprite.\n"

#: builtins/exit.def:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Sunt(există) lucrări în execuție.\n"

#: builtins/fc.def:275 builtins/fc.def:373 builtins/fc.def:417
msgid "no command found"
msgstr "nu s-a găsit nici-o comandă"

#: builtins/fc.def:363 builtins/fc.def:368 builtins/fc.def:407
#: builtins/fc.def:412
msgid "history specification"
msgstr "specificație de istoric"

#: builtins/fc.def:444
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: nu se poate deschide fișierul temporal: %s"

#: builtins/fg_bg.def:152 builtins/jobs.def:284
msgid "current"
msgstr "actual"

#: builtins/fg_bg.def:161
#, c-format
msgid "job %d started without job control"
msgstr "lucrarea %d a început fără controlul lucrării"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opțiune ilegală -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: opțiunea necesită un parametru: -- %c\n"

# NOTĂ:
# cred că aceasta este cea mai bună traducere posibilă!
# Am frunzărit traducerile celorlalte echipe de traducere latine (nu mi-a scăpat niciuna, în afară de cea galiciană, care obligă la descărcarea fișierului pentru al vedea)
# În cea a echipei spaniole, a tradus mesajul ca:
# asociación desactivada
# ce mi s-a părut cea mai apropiată contextului în care apare mesajul:
# #: builtins/hash.def:91
#: builtins/hash.def:91
msgid "hashing disabled"
msgstr "asocierea este desactivată"

#: builtins/hash.def:139
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabelul de asociere este gol\n"

#: builtins/hash.def:267
#, c-format
msgid "hits\tcommand\n"
msgstr "potriviri\tcomandă\n"

#: builtins/help.def:133
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Comenzile Shell care se potrivesc cu cuvântul cheie „"
msgstr[1] "Comenzile Shell care se potrivesc cu cuvintele cheie „"
msgstr[2] "Comenzile Shell care se potrivesc cu cuvintele cheie „"

#: builtins/help.def:135
msgid ""
"'\n"
"\n"
msgstr ""
"”\n"
"\n"

#: builtins/help.def:185
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "niciun subiect de ajutor nu se potrivește cu „%s”.  Încercați «help help» sau «man -k %s» sau «info %s»."

#: builtins/help.def:223
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: nu se poate deschide: %s"

#: builtins/help.def:523
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Aceste comenzi shell, sunt definite intern.  Tastează «help», pentru a vedea\n"
"această listă.\n"
"Tastează «help nume_funcție» pentru a afla mai multe despre funcția „nume_funcție”.\n"
"Utilizați «info bash» pentru a afla mai multe despre shell în general.\n"
"Utilizați «man -k» sau «info» pentru a afla mai multe despre comenzile care nu\n"
"sunt în această listă.\n"
"\n"
"O stea (*) în dreptul unui nume înseamnă că acea comandă este dezactivată.\n"
"\n"

# Propunere:
# Mă gîndesc dacă n-ar suna mai bine fraza, dacă
# înlocuiesc „unul” cu „un argument”, așa:
# nu se poate folosi mai mult de un argument dintre -anrw
#: builtins/history.def:159
msgid "cannot use more than one of -anrw"
msgstr "nu se poate folosi mai mult de o opțiune dintre „-a, -n, -r sau -w”"

#: builtins/history.def:192 builtins/history.def:204 builtins/history.def:215
#: builtins/history.def:228 builtins/history.def:240 builtins/history.def:247
msgid "history position"
msgstr "poziție în registrul istoric al comenzilor"

#: builtins/history.def:338
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: marcaj de timp nevalid"

#: builtins/history.def:449
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: a eșuat expansiunea istoriei"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: a eșuat inlib"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "nu sunt permise alte opțiuni cu „-x”"

#: builtins/kill.def:211
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: argumentele trebuie să fie ID-uri de proces sau de lucrări"

#: builtins/kill.def:274
msgid "Unknown error"
msgstr "Eroare necunoscută"

#: builtins/let.def:97 builtins/let.def:122 expr.c:640 expr.c:658
msgid "expression expected"
msgstr "se așteaptă expresie"

#: builtins/mapfile.def:180
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: nu este o matrice indexată"

#: builtins/mapfile.def:276 builtins/read.def:336
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: specificație de descriptor de fișier nevalidă"

#: builtins/mapfile.def:284 builtins/read.def:343
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: descriptor de fișier nevalid: %s"

#: builtins/mapfile.def:293 builtins/mapfile.def:331
#, c-format
msgid "%s: invalid line count"
msgstr "%s: contorizare de linii nevalidă"

#: builtins/mapfile.def:304
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: origine matrice nevalid"

#: builtins/mapfile.def:321
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: cuantum de apel invers nevalid"

#: builtins/mapfile.def:354
msgid "empty array variable name"
msgstr "nume de variabilă matrice gol"

#: builtins/mapfile.def:375
msgid "array variable support required"
msgstr "este necesar suport pentru variabilă matrice"

#: builtins/printf.def:430
#, c-format
msgid "`%s': missing format character"
msgstr "„%s”: lipsește caracterul de format"

#: builtins/printf.def:485
#, c-format
msgid "`%c': invalid time format specification"
msgstr "„%c”: specificație a formatului de timp nevalidă"

#: builtins/printf.def:708
#, c-format
msgid "`%c': invalid format character"
msgstr "„%c”: caracter de format nevalid"

#: builtins/printf.def:734
#, c-format
msgid "warning: %s: %s"
msgstr "avertizare: %s: %s"

#: builtins/printf.def:822
#, c-format
msgid "format parsing problem: %s"
msgstr "problemă cu analizarea formatului: %s"

#: builtins/printf.def:919
msgid "missing hex digit for \\x"
msgstr "lipsește o cifră hexazecimală pentru \\x"

#: builtins/printf.def:934
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "lipsește o cifră unicode pentru \\%c"

#: builtins/pushd.def:199
msgid "no other directory"
msgstr "niciun alt director"

#: builtins/pushd.def:360
#, c-format
msgid "%s: invalid argument"
msgstr "%s argument nevalid"

#: builtins/pushd.def:480
msgid "<no current directory>"
msgstr "<niciun director curent>"

#: builtins/pushd.def:524
msgid "directory stack empty"
msgstr "stiva de directoare este goală"

#: builtins/pushd.def:526
msgid "directory stack index"
msgstr "indexul stivei de directoare"

# R-GC, scrie:
# după revizarea fișierului, DȘ, spune:
# «→ aș pune „directorul personal” în loc de „acasă”»
# ===
# nu-mi prea place să amestec numele lucurilor,
# cu definiția lor, în acest caz:
# „directorul acasă → directorul personal al utilizatorului”
# voi face aceasă schimbare, în cazul în care,
# autorul numește home folder, în loc de
# home directory
#: builtins/pushd.def:701
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Afișează lista curentă a directoarelor memorate.  Directoarele\n"
"    sunt adăugate la această listă cu comanda «pushd» și sunt eliminate din\n"
"    ea, cu comanda «popd».\n"
"    \n"
"    Opțiuni:\n"
"      -c\tgolește stiva de directoare prin ștergerea tuturor elementelor\n"
"      -l\tnu afișează versiuni scurtate (cu ~) ale directoarelor în raport cu\n"
"    \tdirectorul dumneavoastră «acasă»\n"
"      -p\timprimă stiva de directoare cu o intrare pe linie\n"
"      -v\timprimă stiva de directoare cu o intrare pe linie, prefixată cu poziția\n"
"    \tsa în stivă\n"
"    \n"
"    Argumente:\n"
"      +N\tAfișează a N-a intrare numărând din stânga listei afișate de «dirs»,\n"
"    \tatunci când este invocată fără opțiuni, începând cu zero.\n"
"    \n"
"      -N\tAfișează a N-a intrare numărând din dreapta listei afișate de «dirs»,\n"
"\tatunci când este invocată fără opțiuni, începând cu zero."

#: builtins/pushd.def:723
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Adaugă un director în partea de sus a stivei de directoare sau rotește\n"
"   stiva, făcând din noul director din partea de sus a stivei, directorul de\n"
"    lucru curent. Fără argumente, interschimbă primele două directoare.\n"
"    \n"
"    Opțiuni:\n"
"      -n\tSuprimă schimbarea normală a directorului atunci când se\n"
"    \tadaugă directoare la stivă, astfel încât numai stiva este manipulată.\n"
"    \n"
"    Argumente:\n"
"      +N\tRotește stiva astfel încât al N-lea director (numărând din\n"
"    \tstânga listei afișate de «dirs», începând cu zero) să fie în\n"
"    \tpartea de sus.\n"
"    \n"
"      -N\tRotește stiva astfel încât al N-lea director (numărând din\n"
"    \tdreapta listei afișate de «dirs», începând cu zero) să fie în\n"
"    \tpartea de sus.\n"
"    \n"
"      dir\tAdaugă DIR la stiva de directoare din partea de sus,\n"
"    \tfăcându-l noul director de lucru curent.\n"
"    \n"
"    Comanda internă «dirs» arată stiva curentă de directoare."

#: builtins/pushd.def:748
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Elimină intrările din stiva de directoare.  Fără argumente, elimină directorul\n"
"    din partea de sus a stivei, și trece la cel cea devenit noul director de sus\n"
"    a stivei.\n"
"    \n"
"    Opțiuni:\n"
"      -n\tSuprimă schimbarea normală a directorului atunci când se elimină\n"
"    \tdirectoare din stivă, astfel încât numai stiva este manipulată.\n"
"    \n"
"    Argumente:\n"
"      +N\tElimină intrarea a N-a numărând din stânga listei afișate de «dirs»,\n"
"    \tîncepând cu zero.  De exemplu: «popd +0» elimină primul director,\n"
"    \t«popd +1» al doilea director, șamd.\n"
"    \n"
"      -N\tElimină intrarea a N-a numărând din dreapta listei afișate de «dirs»,\n"
"    \tîncepând cu zero.  De exemplu: «popd -0» elimină ultimul director,\n"
"    \t„popd -1” penultimul director, șamd.\n"
"    \n"
"    Comanda internă «dirs» arată stiva curentă de directoare."

#: builtins/read.def:308
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: specificație a timpului de expirare nevalidă"

#: builtins/read.def:827
#, c-format
msgid "read error: %d: %s"
msgstr "eroare de citire: %d: %s"

# Comentariu:
# Eram un pic indecis asupra formei finale a traducerii,
# așa că am început să trag cu ochiul la traducerile
# celorlalți latini, așa am descoperit la brazilieni,
# francezi și spanioli(în ordine alfabetică), formula
# magică  pentru această traducere:
# 1.
# msgstr "possível retornar (`return') apenas de uma função ou script carregado (com `source')"
# 2.
# msgstr "« return » n'est possible que depuis une fonction ou depuis un script exécuté par « source »"
# 3.
# msgstr "sólo se puede usar `return' desde una función o un script leído con `source'"
#: builtins/return.def:68
msgid "can only `return' from a function or sourced script"
msgstr "„return”, se poate utiliza doar de la o funcție sau script executat(ă) de la „source”"

# R-GC, scrie:
# după revizarea fișierului, DȘ, spune:
# „→ nu se pot anula...”
# ===
# Ok, corecție aplicată
#: builtins/set.def:869
msgid "cannot simultaneously unset a function and a variable"
msgstr "nu se pot anula simultan o funcție și o variabilă"

#: builtins/set.def:969
#, c-format
msgid "%s: not an array variable"
msgstr "%s: nu este o variabilă matrice"

#: builtins/setattr.def:189
#, c-format
msgid "%s: not a function"
msgstr "%s: nu este o funcție"

#: builtins/setattr.def:194
#, c-format
msgid "%s: cannot export"
msgstr "%s: nu se poate exporta"

#: builtins/shift.def:72 builtins/shift.def:79
msgid "shift count"
msgstr "contor deplasare(shift)"

# R-GC, scrie:
# după revizarea fișierului, DȘ, spune:
# «→ similar și aici: „nu se pot activa ... ”»
# ===
# Ok, corecție aplicată
#: builtins/shopt.def:323
msgid "cannot set and unset shell options simultaneously"
msgstr "nu se pot activa și dezactiva simultan opțiunile de shell"

#: builtins/shopt.def:444
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: nume nevalid al opțiunii shell"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "este necesar argumentul nume_de_fișier"

#: builtins/source.def:154
#, c-format
msgid "%s: file not found"
msgstr "%s: nu s-a găsit fișierul"

#: builtins/suspend.def:102
msgid "cannot suspend"
msgstr "nu se poate suspenda"

#: builtins/suspend.def:112
msgid "cannot suspend a login shell"
msgstr "nu se poate suspenda un shell de autentificare"

#: builtins/type.def:235
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s este un alias pentru „%s”\n"

#: builtins/type.def:256
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s este un cuvânt cheie shell\n"

#: builtins/type.def:275
#, c-format
msgid "%s is a function\n"
msgstr "%s este o funcție\n"

#: builtins/type.def:299
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s este o comandă internă specială a shell\n"

#: builtins/type.def:301
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s este o comandă internă a shell\n"

#: builtins/type.def:323 builtins/type.def:408
#, c-format
msgid "%s is %s\n"
msgstr "%s este %s\n"

# sau: este mărunțit/fragmentat ?
#: builtins/type.def:343
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s este asociat(hashed) (%s)\n"

#: builtins/ulimit.def:400
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: limită de argument nevalidă"

#: builtins/ulimit.def:426
#, c-format
msgid "`%c': bad command"
msgstr "„%c”: comandă incorectă"

#: builtins/ulimit.def:464
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: nu se poate obține limita: %s"

#: builtins/ulimit.def:490
msgid "limit"
msgstr "limită"

#: builtins/ulimit.def:502 builtins/ulimit.def:802
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: nu se poate modifica limita: %s"

#: builtins/umask.def:115
msgid "octal number"
msgstr "număr octal"

#: builtins/umask.def:232
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "„%c”: operator de mod simbolic nevalid"

#: builtins/umask.def:287
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "„%c”: caracter de mod simbolic nevalid"

#: error.c:89 error.c:373 error.c:375 error.c:377
msgid " line "
msgstr " linie "

#: error.c:164
#, c-format
msgid "last command: %s\n"
msgstr "ultima comandă: %s\n"

#: error.c:172
#, c-format
msgid "Aborting..."
msgstr "Se abandonează..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.c:287
#, c-format
msgid "INFORM: "
msgstr "RAPORT: "

#: error.c:310
#, c-format
msgid "DEBUG warning: "
msgstr "Avertisment de DEPANARE: "

#: error.c:488
msgid "unknown command error"
msgstr "eroare de comandă necunoscută"

#: error.c:489
msgid "bad command type"
msgstr "tip de comandă greșit"

#: error.c:490
msgid "bad connector"
msgstr "conector greșit"

#: error.c:491
msgid "bad jump"
msgstr "salt eronat"

#: error.c:529
#, c-format
msgid "%s: unbound variable"
msgstr "%s: variabilă neasociată"

#: eval.c:243
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\atimed expirat așteptând introducerea datelor: auto-logout\n"

#: execute_cmd.c:555
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "nu se poate redirecționa intrarea standard de la /dev/null: %s"

#: execute_cmd.c:1317
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: „%c”: caracter de format nevalid"

#: execute_cmd.c:2391
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr "execute_coproc: coproc [%d:%s] încă există"

#: execute_cmd.c:2524
msgid "pipe error"
msgstr "eroare de linie de conectare"

# Opinie/Motivație:
# am ales să traduc nesting = suprapunere
# și nu
# nesting = imbricare
# pentru că consider că este vorba de efectul procesului (evaluările, ce vin una după alta,suprapunîndu-se) și nu de-a numi procesul în sine
# În plus, mi se pare că sună mult mai normal la ureche
#: execute_cmd.c:4923
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: s-a depășit nivelul maxim de suprapunere de «eval» (%d)"

#: execute_cmd.c:4935
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: s-a depășit nivelul maxim de suprapunere de citiri cu «source» (%d)"

#: execute_cmd.c:5043
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: s-a depășit nivelul maxim de suprapunere de funcții (%d)"

#: execute_cmd.c:5598
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: limitat: nu se poate specifica „/” în numele comenzilor"

#: execute_cmd.c:5715
#, c-format
msgid "%s: command not found"
msgstr "%s: comandă negăsită"

#: execute_cmd.c:5957
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.c:5975
#, c-format
msgid "%s: cannot execute: required file not found"
msgstr "%s: nu se poate executa: fișierul necesar nu a fost găsit"

#: execute_cmd.c:6000
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: interpret greșit"

#: execute_cmd.c:6037
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: nu se poate executa fișierul binar: %s"

#: execute_cmd.c:6123
#, c-format
msgid "`%s': is a special builtin"
msgstr "„%s”: este o comandă internă specială"

#: execute_cmd.c:6175
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "nu se poate duplica descriptorul de fișier %d în descriptorul de fișier %d"

#: expr.c:263
msgid "expression recursion level exceeded"
msgstr "nivel de recursivitate al expresiei depășit"

#: expr.c:291
msgid "recursion stack underflow"
msgstr "stivă recursivă sub nivelul de depășire"

#: expr.c:478
msgid "syntax error in expression"
msgstr "eroare de sintaxă în expresie"

#: expr.c:522
msgid "attempted assignment to non-variable"
msgstr "s-a încercat asignare către non-variabilă"

#: expr.c:531
msgid "syntax error in variable assignment"
msgstr "eroare de sintaxă în atribuirea variabilei"

#: expr.c:545 expr.c:912
msgid "division by 0"
msgstr "împărțire la 0"

#: expr.c:593
msgid "bug: bad expassign token"
msgstr "eroare: simbol de atribuire al expresiei greșit"

#: expr.c:647
msgid "`:' expected for conditional expression"
msgstr "se aștepta „:” după expresia condițională"

#: expr.c:973
msgid "exponent less than 0"
msgstr "exponent mai mic de 0"

#: expr.c:1030
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "se aștepta un identificator după pre-increment sau pre-decrement"

#: expr.c:1057
msgid "missing `)'"
msgstr "„)” lipsește"

#: expr.c:1108 expr.c:1492
msgid "syntax error: operand expected"
msgstr "eroare de sintaxă: se aștepta un operand"

#: expr.c:1494
msgid "syntax error: invalid arithmetic operator"
msgstr "eroare de sintaxă: operator aritmetic nevalid"

#: expr.c:1518
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (identificatorul erorii este „%s”)"

#: expr.c:1578
msgid "invalid arithmetic base"
msgstr "bază aritmetică nevalidă"

# R-GC, scrie:
# cum „constantă întreagă nevalidă”, nu mă
# atrăgea prea mult, am adaptat traducerea
# la ce se vede
# ***
# după revizarea fișierului, DȘ, spune:
# «→ un mic typo la „întreg”»
# ===
# Ok, corecție aplicată; graba... e de vină
#: expr.c:1587
msgid "invalid integer constant"
msgstr "constantă de număr întreg nevalidă"

#: expr.c:1603
msgid "value too great for base"
msgstr "valoare prea mare pentru bază"

#: expr.c:1652
#, c-format
msgid "%s: expression error\n"
msgstr "%s: eroare în expresie\n"

#: general.c:70
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: nu s-au putut accesa directoarele părinte"

#: input.c:99 subst.c:6208
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "nu se poate redefini modul „nodelay” pentru descriptorul de fișier %d"

#: input.c:266
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "nu se poate aloca un nou descriptor de fișier pentru intrarea bash din fd %d"

#: input.c:274
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: memorie tampon deja existentă pentru noul descriptor de fișier %d"

#: jobs.c:543
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: linie de conectare pgrp"

#: jobs.c:907
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_delete: BUCLĂ: psi (%d) == storage[psi].bucket_next"

#: jobs.c:960
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr "bgp_search: BUCLĂ: psi (%d) == storage[psi].bucket_next"

#: jobs.c:1279
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "pid-ul bifurcat %d apare în lucrarea în execuție %d"

#: jobs.c:1397
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "se șterge lucrarea oprită %d cu grupul de procese %ld"

#: jobs.c:1502
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) marcat ca încă în viață"

#: jobs.c:1839
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: nu există un asemenea pid"

#: jobs.c:1854
#, c-format
msgid "Signal %d"
msgstr "Semnal %d"

#: jobs.c:1868 jobs.c:1894
msgid "Done"
msgstr "Finalizat"

#: jobs.c:1873 siglist.c:123
msgid "Stopped"
msgstr "Oprit"

#: jobs.c:1877
#, c-format
msgid "Stopped(%s)"
msgstr "Oprit(%s)"

#: jobs.c:1881
msgid "Running"
msgstr "În rulare"

#: jobs.c:1898
#, c-format
msgid "Done(%d)"
msgstr "Finalizat(%d)"

#: jobs.c:1900
#, c-format
msgid "Exit %d"
msgstr "Ieșire %d"

#: jobs.c:1903
msgid "Unknown status"
msgstr "Stare necunoscută"

#: jobs.c:1990
#, c-format
msgid "(core dumped) "
msgstr "(core dumped) "

# NOTĂ: de aflat ce înseamnă:
# wd =
# =====================================
# NOTA_BENE:
# pe viitor „istețule” uită-te în fișierul de traducere,
# deschis ca text, și vei avea mari șanse să afli
# răspunsul; fără a «gonglear» ca bezmeticul în Internet
#: jobs.c:2009
#, c-format
msgid "  (wd: %s)"
msgstr "  (dir.lucru: %s)"

#: jobs.c:2250
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "setpgid proces-copil (de la %ld la %ld)"

# NOTĂ:
# «wait», nu se traduce; aici, și în mesajele următoare,
# face parte din categoria cuvintelor ce nu se traduc.
# Datorită contextului în care se află.
#: jobs.c:2608 nojobs.c:666
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: pid %ld nu este un proces-copil al acestui shell"

#: jobs.c:2884
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Nu există nicio înregistrare a procesului %ld"

#: jobs.c:3223
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: lucrarea %d este oprită"

#: jobs.c:3551
#, c-format
msgid "%s: no current jobs"
msgstr "%s: nu există lucrări actuale"

#: jobs.c:3558
#, c-format
msgid "%s: job has terminated"
msgstr "%s: lucrarea a fost terminată"

#: jobs.c:3567
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: lucrarea %d se află deja în fundal"

#: jobs.c:3793
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr "waitchld: se activează WNOHANG pentru a evita blocarea pe termen nedefinit"

#: jobs.c:4307
#, c-format
msgid "%s: line %d: "
msgstr "%s: linie %d: "

#: jobs.c:4321 nojobs.c:921
#, c-format
msgid " (core dumped)"
msgstr " (core dumped)"

#: jobs.c:4333 jobs.c:4346
#, c-format
msgid "(wd now: %s)\n"
msgstr "(dir.lucru actual: %s)\n"

#: jobs.c:4378
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp a eșuat"

#: jobs.c:4434
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: nu există control de lucrări în fundal"

#: jobs.c:4450
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: disciplină linie"

#: jobs.c:4460
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.c:4481 jobs.c:4490
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "nu se poate configura grupul de procese din terminal (%d)"

#: jobs.c:4495
msgid "no job control in this shell"
msgstr "nu există niciun control de lucrări în acest shell"

#: lib/malloc/malloc.c:367
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: a eșuat aserțiunea: %s\n"

#: lib/malloc/malloc.c:383
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: aserțiune greșită\r\n"

#: lib/malloc/malloc.c:384 lib/malloc/malloc.c:941
msgid "unknown"
msgstr "necunoscut"

# Altă formulă de traducere al mesajului, este:
# „malloc: bloc șters din lista disponibilă ”
# Notă, pentru a decide care dintre aceste traduceri,
# rămîne, e nevoie de colaborarea(opinii, sugestii,
# comentarii, etc) ale utilizatorilor de «bash»...
#: lib/malloc/malloc.c:892
msgid "malloc: block on free list clobbered"
msgstr "malloc: bloc suprascris pe lista liberă"

#: lib/malloc/malloc.c:980
msgid "free: called with already freed block argument"
msgstr "free: apelat cu un argument bloc deja eliberat"

#: lib/malloc/malloc.c:983
msgid "free: called with unallocated block argument"
msgstr "free: apelat cu un argument de bloc nealocat"

# Am tradus inițial mesajul, ca:
# „free: depășire insuficientă detectată; mh_nbytes în afara intervalului”
# formulă actuală mi se pare mai adecvată. contextului, precum și a mesajului din engleză
#: lib/malloc/malloc.c:1001
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: s-a detectat o depășire insuficientă; mh_nbytes în afara intervalului"

#: lib/malloc/malloc.c:1007
msgid "free: underflow detected; magic8 corrupted"
msgstr "free: s-a detectat o depășire insuficientă; magic8 corupt"

#: lib/malloc/malloc.c:1014
msgid "free: start and end chunk sizes differ"
msgstr "free: dimensiunile bucăților de început și de sfârșit sunt diferite"

#: lib/malloc/malloc.c:1176
msgid "realloc: called with unallocated block argument"
msgstr "realloc: apelat cu un argument de bloc nealocat"

#: lib/malloc/malloc.c:1191
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: s-a detectat o depășire insuficientă; mh_nbytes țn afara intervalului"

#: lib/malloc/malloc.c:1197
msgid "realloc: underflow detected; magic8 corrupted"
msgstr "realloc: s-a detectat o depășire insuficientă; magic8 corupt"

#: lib/malloc/malloc.c:1205
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: dimensiunile bucăților de început și de sfârșit, diferă"

#: lib/malloc/table.c:191
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: tabelul de alocare este plin cu FIND_ALLOC?\n"

#: lib/malloc/table.c:200
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p deja în tabel ca fiind alocat?\n"

#: lib/malloc/table.c:253
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_alloc: %p deja în tabel ca liber?\n"

#: lib/sh/fmtulong.c:102
msgid "invalid base"
msgstr "bază nevalidă"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: gazdă necunoscută"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: serviciu nevalid"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: specificație incorectă pentru ruta rețelei"

#: lib/sh/netopen.c:347
msgid "network operations not supported"
msgstr "operațiunile de rețea nu sunt acceptate"

#: locale.c:219
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: nu se poate schimba parametrul de limbă (%s)"

#: locale.c:221
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: nu se poate schimba parametrul de limbă (%s): %s"

#: locale.c:294
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: nu se poate schimba parametrul de limbă (%s)"

#: locale.c:296
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: nu se poate schimba parametrul de limbă (%s): %s"

#: mailcheck.c:439
msgid "You have mail in $_"
msgstr "Aveți mail în $_"

#: mailcheck.c:464
msgid "You have new mail in $_"
msgstr "Aveți mail nou în $_"

#: mailcheck.c:480
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Mailul din %s a fost citit\n"

#: make_cmd.c:314
msgid "syntax error: arithmetic expression required"
msgstr "eroare de sintaxă: expresie aritmetică necesară"

#: make_cmd.c:316
msgid "syntax error: `;' unexpected"
msgstr "eroare de sintaxă: „;” neașteptat"

#: make_cmd.c:317
#, c-format
msgid "syntax error: `((%s))'"
msgstr "eroare de sintaxă: „((%s))”"

#: make_cmd.c:569
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: tip de instrucțiune greșit %d"

#: make_cmd.c:668
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "«here-document» la linia %d delimitat de sfârșitul fișierului (se aștepta „%s”)"

#: make_cmd.c:769
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: instrucțiunea de redirecționare „%d” este în afara intervalului"

#: parse.y:2428
#, c-format
msgid "shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"
msgstr "shell_getc: shell_input_line_size (%zu) depășește SIZE_MAX (%lu): linie trunchiată"

#: parse.y:2921
msgid "maximum here-document count exceeded"
msgstr "numărul maxim de «here-document» a fost depășit"

#: parse.y:3684 parse.y:4244 parse.y:6148
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "sfârșit neașteptat al fișierului(EOF) în timp ce se căuta coincidența pentru „%c”"

#: parse.y:4452
msgid "unexpected EOF while looking for `]]'"
msgstr "sfârșit neașteptat al fișierului(EOF) în timp ce se căuta „]]”"

#: parse.y:4457
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "eroare de sintaxă în expresia condițională: simbol neașteptat „%s”"

#: parse.y:4461
msgid "syntax error in conditional expression"
msgstr "eroare de sintaxă în expresia condițională"

#: parse.y:4539
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "simbol neașteptat „%s”, așteptat „)”"

#: parse.y:4543
msgid "expected `)'"
msgstr "se aștepta „)”"

#: parse.y:4571
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "argument neașteptat „%s” pentru operatorul unar condițional"

#: parse.y:4575
msgid "unexpected argument to conditional unary operator"
msgstr "argument neașteptat pentru operatorul unar condițional"

#: parse.y:4621
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "identificator neașteptat „%s”, se aștepta operator binar condițional"

#: parse.y:4625
msgid "conditional binary operator expected"
msgstr "se aștepta operator binar condițional"

#: parse.y:4647
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "argument neașteptat „%s” pentru operatorul binar condițional"

#: parse.y:4651
msgid "unexpected argument to conditional binary operator"
msgstr "argument neașteptat pentru operatorul binar condițional"

#: parse.y:4662
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "identificator neașteptat „%c” în comanda condițională"

#: parse.y:4665
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "identificator neașteptat „%s” în comanda condițională"

#: parse.y:4669
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "identificator neașteptat %d în comanda condițională"

#: parse.y:6118
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "eroare de sintaxă neașteptată lângă „%s”"

#: parse.y:6137
#, c-format
msgid "syntax error near `%s'"
msgstr "eroare de sintaxă neașteptată lângă „%s”"

#: parse.y:6151
msgid "syntax error: unexpected end of file"
msgstr "eroare de sintaxă: sfârșit de fișier neașteptat"

#: parse.y:6151
msgid "syntax error"
msgstr "eroare de sintaxă"

#: parse.y:6216
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Utilizați „%s” pentru a părăsi shell-ul.\n"

#: parse.y:6394
msgid "unexpected EOF while looking for matching `)'"
msgstr "sfârșit neașteptat al fișierului în timp ce se căuta după perechea lui „)”"

#: pcomplete.c:1132
#, c-format
msgid "completion: function `%s' not found"
msgstr "completare: funcția „%s” nu a fost găsită"

#: pcomplete.c:1722
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr "programable_completion: %s: posibilă buclă de reîncercare"

#: pcomplib.c:182
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: COMPSPEC null"

#: print_cmd.c:302
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: conector greșit „%d”"

#: print_cmd.c:375
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: descriptor de fișier nevalid"

#: print_cmd.c:380
msgid "xtrace_set: NULL file pointer"
msgstr "xtrace_set: indicatorul pentru fișier este NULL"

#: print_cmd.c:384
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr "xtrace fd (%d) != nrfișier xtrace fp (%d)"

#: print_cmd.c:1545
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: „%c”: caracter de format nevalid"

#: redir.c:150 redir.c:198
msgid "file descriptor out of range"
msgstr "descriptor de fișier în afara intervalului"

#: redir.c:205
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: redirectare ambiguă"

#: redir.c:209
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: nu se poate suprascrie fișierul existent"

#: redir.c:214
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: restricționat: nu se poate redirecționa ieșirea"

#: redir.c:219
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "nu se poate crea un fișier temporar pentru «here-document»: %s"

#: redir.c:223
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: nu se poate atribui descriptorul de fișier variabilei"

# Întrebare: este mai bine/corect
# „..... fără o conexiune de rețea”
# sau,
# ”fără a avea o conexiune la rețea”?
# ***
# după revizarea fișierului, DȘ, spune:
# «→conexiunea trebuie să fie LA rețea în ambele cazuri, „conexiune de rețea” este doar un tip de conexiune (fizică sau virtuală), iar „conexiunea la rețea” reprezintă accesul calculatorului la o rețea anume. (aici se subînțelege o rețea de alte calulatoare fie ea LAN sau WAN)»
# ===
# Ok, corecție aplicată
#: redir.c:650
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "nu se admite «/dev/(tcp|udp)/host/port» fără a avea o conexiune la rețea"

#: redir.c:945 redir.c:1065 redir.c:1130 redir.c:1303
msgid "redirection error: cannot duplicate fd"
msgstr "eroare de redirectare: nu se poate duplica descriptorul de fișier"

#: shell.c:353
msgid "could not find /tmp, please create!"
msgstr "nu s-a putut găsi «/tmp», vă rugăm să-l creați!"

#: shell.c:357
msgid "/tmp must be a valid directory name"
msgstr "«/tmp» trebuie să fie un nume de director valid"

#: shell.c:826
msgid "pretty-printing mode ignored in interactive shells"
msgstr "modul de imprimare „drăguț” este ignorat în shell-urile interactive"

#: shell.c:972
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: opțiune nevalidă"

#: shell.c:1343
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "nu se poate stabili uid la %d: uid efectiv %d"

#: shell.c:1354
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "nu se poate stabili gid la %d: gid efectiv %d"

#: shell.c:1544
msgid "cannot start debugger; debugging mode disabled"
msgstr "nu se poate porni depanatorul; modul de depanare a fost dezactivat"

#: shell.c:1658
#, c-format
msgid "%s: Is a directory"
msgstr "%s: Este un director"

#: shell.c:1907
msgid "I have no name!"
msgstr "Nu am nici un nume!"

#: shell.c:2061
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, versiunea %s-(%s)\n"

# R-GC, scrie:
# acest mesaj, și următoarele, pot să fie
# vizualizate, rulînd comanda:
# «bash --help».
#: shell.c:2062
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Utilizare:\t%s [GNU opțiune lungă] [opțiune] ...\n"
"\t%s [GNU opțiune lungă] [opțiune] fișier-script ...\n"

#: shell.c:2064
msgid "GNU long options:\n"
msgstr "Opțiuni lungi GNU:\n"

#: shell.c:2068
msgid "Shell options:\n"
msgstr "Opțiuni ale shell-ului:\n"

#: shell.c:2069
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD sau -c comandă sau -O shopt_option\t\t(doar invocare)\n"

#: shell.c:2088
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s sau -o opțiune\n"

#: shell.c:2094
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Tastați «%s -c \"help set\"» pentru mai multe informații despre opțiunile shell-ului.\n"

#: shell.c:2095
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Tastați «%s -c help» pentru mai multe informații despre comenzile interne ale shell-ului.\n"

#: shell.c:2096
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Utilizați comanda «bashbug» pentru a raporta erori.\n"

#: shell.c:2098
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Pagina principală a lui „bash”: <http://www.gnu.org/software/bash>\n"

#: shell.c:2099
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Ajutor general pentru utilizarea software-ului GNU: <http://www.gnu.org/gethelp/>\n"

#: sig.c:765
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: operație nevalidă"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Semnal fals"

#: siglist.c:51
msgid "Hangup"
msgstr "Deconectare/Terminare anormală(Hangup)"

#: siglist.c:55
msgid "Interrupt"
msgstr "Întrerupere"

#: siglist.c:59
msgid "Quit"
msgstr "Părăsire"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Instrucțiune ilegală"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Punct de întrerupere de urmărire/capturare"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "Instrucțiune ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "Instrucțiune EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Excepție de virgulă mobilă"

#: siglist.c:87
msgid "Killed"
msgstr "Omorât"

#: siglist.c:91
msgid "Bus error"
msgstr "Eroare de magistrală de date(bus)"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Eroare de segmentare"

#: siglist.c:99
msgid "Bad system call"
msgstr "Apel de sistem incorect"

#: siglist.c:103
msgid "Broken pipe"
msgstr "Linie de conectare întreruptă"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Ceas cu alarmă"

#: siglist.c:111
msgid "Terminated"
msgstr "Terminat"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Condiție In/Ieș urgentă"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Oprit (semnal)"

#: siglist.c:127
msgid "Continue"
msgstr "Continuare"

#: siglist.c:135
msgid "Child death or stop"
msgstr "Proces-copil mort sau oprit"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Oprit (tty input)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Oprit (tty output)"

# Se referă la: dispozitiv(de intrare/de ieșire)
#: siglist.c:147
msgid "I/O ready"
msgstr "In/Ieș pregătită"

#: siglist.c:151
msgid "CPU limit"
msgstr "Limită CPU"

#: siglist.c:155
msgid "File limit"
msgstr "Limită fișier"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarmă (virtual)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarmă (profil)"

#: siglist.c:167
msgid "Window changed"
msgstr "Fereastră schimbată"

# De moment rămîne traducerea veche:
# „Reținere (lock) înregistrare”
# Dar, cred că:
# Blocare înregistrare, este formula corectă...
# ***
# l-am modificat la revizare
#: siglist.c:171
msgid "Record lock"
msgstr "Blocare înregistrare"

#: siglist.c:175
msgid "User signal 1"
msgstr "Semnal utilizator 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Semnal utilizator 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "Date de intrare HFT în curs de rezolvare"

#: siglist.c:187
msgid "power failure imminent"
msgstr "probleme electrice iminente"

#: siglist.c:191
msgid "system crash imminent"
msgstr "cădere iminentă a sistemului"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "migrare proces spre alt CPU"

#: siglist.c:199
msgid "programming error"
msgstr "eroare de programare"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "Modul de monitor HFT a fost acordat"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "Modul de monitor HFT a fost retras"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "Secvența de sunet HFT a fost completată"

#: siglist.c:215
msgid "Information request"
msgstr "Solicitare de informație"

#: siglist.c:223 siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Semnal necunoscut #%d"

#: subst.c:1480 subst.c:1670
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "înlocuire greșită: nu se închide „%s” în %s"

#: subst.c:3307
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: nu se poate atribui o listă unui membru al matricei"

#: subst.c:6048 subst.c:6064
msgid "cannot make pipe for process substitution"
msgstr "nu se poate crea linia de conectare pentru substituția procesului"

#: subst.c:6124
msgid "cannot make child for process substitution"
msgstr "nu se poate crea un proces-copil pentru substituirea procesului: %s"

#: subst.c:6198
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "nu se poate deschide linia de conectare numită %s pentru citire"

#: subst.c:6200
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "nu se poate deschide linia de conectare numită %s pentru scriere"

#: subst.c:6223
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "nu se poate duplica linia de conectare numită %s ca fd %d"

#: subst.c:6370
msgid "command substitution: ignored null byte in input"
msgstr "substituție de comandă: octetul null din intrare este ignorat"

#: subst.c:6533
msgid "cannot make pipe for command substitution"
msgstr "nu se poate crea linia de conectare pentru substituția de comandă"

#: subst.c:6580
msgid "cannot make child for command substitution"
msgstr "nu se poate crea un proces-copil pentru substituția de comandă"

#: subst.c:6613
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: nu se poate duplica linia de conectare ca descriptor de fișier 1(fd 1)"

#: subst.c:7082 subst.c:10252
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: nume de variabilă nevalid pentru referința numelui"

#: subst.c:7178 subst.c:7196 subst.c:7369
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: extindere indirectă nevalidă"

#: subst.c:7212 subst.c:7377
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: nume de variabilă nevalid"

#: subst.c:7478
#, c-format
msgid "%s: parameter not set"
msgstr "%s: parametru nedefinit"

#: subst.c:7480
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parametru nul sau nedefinit"

#: subst.c:7727 subst.c:7742
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: expresie subșir < 0"

#: subst.c:9560 subst.c:9587
#, c-format
msgid "%s: bad substitution"
msgstr "%s: substituție nevalidă"

#: subst.c:9678
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: nu se poate asigna în acest mod"

#: subst.c:10111
msgid "future versions of the shell will force evaluation as an arithmetic substitution"
msgstr "versiunile viitoare ale shell-ului vor forța evaluarea ca o substituție aritmetică"

#: subst.c:10795
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "înlocuire greșită: fără „`” de închidere în %s"

#: subst.c:11874
#, c-format
msgid "no match: %s"
msgstr "nicio potrivire: %s"

#: test.c:147
msgid "argument expected"
msgstr "se aștepta un parametru"

#: test.c:156
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: se aștepta o expresie întreagă (integer)"

#: test.c:265
msgid "`)' expected"
msgstr "se aștepta „)'”"

#: test.c:267
#, c-format
msgid "`)' expected, found %s"
msgstr "se aștepta „)”, s-a găsit %s"

#: test.c:469 test.c:814
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: se așteaptă operator binar"

#: test.c:771 test.c:774
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: se așteaptă operator unar"

#: test.c:896
msgid "missing `]'"
msgstr "lipsește „]”"

#: test.c:914
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "eroare de sintaxă: „%s” neașteptat"

#: trap.c:220
msgid "invalid signal number"
msgstr "număr de semnal nevalid"

#: trap.c:323
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "gestionarul de capturare: nivelul maxim de gestionări de capturare a fost depășit (%d)"

#: trap.c:412
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: valoare greșită în trap_list[%d]: %p"

#: trap.c:416
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: gestionarul de semnal este SIG_DFL, se retrimite %d (%s) către mine"

#: trap.c:509
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: semnal nevalid %d"

#: variables.c:424
#, c-format
msgid "error importing function definition for `%s'"
msgstr "eroare în importarea definiției funcției pentru „%s”"

#: variables.c:838
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "nivelul shell-ului (%d) prea mare, se reinițializează la 1"

#: variables.c:2642
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: nu există context de funcție în domeniul actual"

#: variables.c:2661
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: nu este posibil ca variabilei să i se atribuie o valoare"

#: variables.c:2818 variables.c:2874
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr "%s: nu se poate moșteni valoarea de la un tip incompatibil"

#: variables.c:3459
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: se atribuie un număr întreg referinței de nume"

#: variables.c:4390
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: nu există context de funcție în domeniul actual"

#: variables.c:4757
#, c-format
msgid "%s has null exportstr"
msgstr "%s are exportstr nul"

#: variables.c:4762 variables.c:4771
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "caracter nevalid %d în exportstr pentru %s"

#: variables.c:4777
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "nu există „=” în exportstr pentru %s"

#: variables.c:5317
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: partea de sus din shell_variables nu este un context de funcție"

#: variables.c:5330
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: nu există un context global_variables"

#: variables.c:5410
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: partea de sus din shell_variables nu este un domeniu de mediu temporar"

#: variables.c:6400
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: nu se poate deschide ca FIȘIER"

#: variables.c:6405
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: valoare nevalidă pentru descriptorul fișierului de urmărire"

#: variables.c:6450
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: valoarea de compatibilitate în afara intervalului"

#: version.c:46 version2.c:46
msgid "Copyright (C) 2022 Free Software Foundation, Inc."
msgstr "Drepturi de autor © 2022 Free Software Foundation, Inc."

#: version.c:47 version2.c:47
msgid "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
msgstr "Licență GPLv3+: GNU GPL versiunea 3 sau ulterioară <http://gnu.org/licenses/gpl.html>\n"

#: version.c:86 version2.c:86
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, versiunea %s (%s)\n"

#: version.c:91 version2.c:91
msgid "This is free software; you are free to change and redistribute it."
msgstr "Acesta este un software liber; sunteți liber să îl modificați și să îl redistribuiți."

#: version.c:92 version2.c:92
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "NU EXISTĂ NICIO GARANȚIE, în măsura permisă de lege."

#: xmalloc.c:93
#, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: nu se pot aloca %lu octeți (%lu octeți alocați)"

#: xmalloc.c:95
#, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "%s: nu se pot aloca %lu octeți"

#: xmalloc.c:165
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "%s: %s:%d: nu se pot aloca %lu octeți (%lu octeți alocați)"

#: xmalloc.c:167
#, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "%s: %s:%d: nu se pot aloca %lu octeți"

# R-GC, scrie:
# acest mesaj, și următoarele, pot să fie
# vizualizate, rulînd comanda:
# «bash -c help», dintr-un shell diferit de «bash»;
# «help», dintr-un shell «bash».
#: builtins.c:45
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [nume[=valoare] ... ]"

#: builtins.c:49
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] nume [nume ...]"

#: builtins.c:53
msgid "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr "bind [-lpsvPSVX] [-m comb_taste] [-f nume_fișier] [-q nume] [-u nume] [-r secv_taste] [-x secv_taste:comandă_shell] [secv_taste:funcție-readline sau comandă-readline]"

#: builtins.c:56
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:58
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:60
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [comandă_internă-shell [arg ...]]"

#: builtins.c:63
msgid "caller [expr]"
msgstr "caller [expr]"

#: builtins.c:66
msgid "cd [-L|[-P [-e]] [-@]] [dir]"
msgstr "cd [-L|[-P [-e]] [-@]] [dir]"

#: builtins.c:68
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:76
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] comandă [arg ...]"

#: builtins.c:78
msgid "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]"
msgstr "declare [-aAfFgiIlnrtux] [nume[=valoare] ...] sau declare -p [-aAfFilnrtux] [nume ...]"

#: builtins.c:80
msgid "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]"
msgstr "typeset [-aAfFgiIlnrtux] nume[=valoare] ... sau typeset -p [-aAfFilnrtux] [nume ...]"

#: builtins.c:82
msgid "local [option] name[=value] ..."
msgstr "local [opțiune] nume[=valoare] ..."

#: builtins.c:85
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:89
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:92
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f nume_fișier]] [nume ...]"

#: builtins.c:94
msgid "eval [arg ...]"
msgstr "eval [arg ...]"

#: builtins.c:96
msgid "getopts optstring name [arg ...]"
msgstr "getopts șir_opțiuni nume [arg ...]"

#: builtins.c:98
msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
msgstr "exec [-cl] [-a nume] [comandă [argument ...]] [redirectare ...]"

#: builtins.c:100
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:102
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:105
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e enume] [-lnr] [prim] [ultim] sau fc -s [pat=rep] [comandă]"

#: builtins.c:109
msgid "fg [job_spec]"
msgstr "fg [id_lucrare]"

#: builtins.c:113
msgid "bg [job_spec ...]"
msgstr "bg [id_lucrare ...]"

#: builtins.c:116
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p nume_rută [-dt] [nume ...]"

#: builtins.c:119
msgid "help [-dms] [pattern ...]"
msgstr "help [-dms] [tipar ...]"

#: builtins.c:123
msgid "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]"
msgstr "history [-c] [-d decalaj] [n] sau history -anrw [nume_fișier] sau history -ps arg [arg...]"

#: builtins.c:127
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [id_lucrare ...] sau jobs -x comandă [args]"

#: builtins.c:131
msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
msgstr "disown [-h] [-ar] [id_lucrare ... | pid ...]"

#: builtins.c:134
msgid "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]"
msgstr "kill [-s id_semnal | -n num_semnal | -id_semnal] pid | id_lucrare ... sau kill -l [id_semnal]"

#: builtins.c:136
msgid "let arg [arg ...]"
msgstr "let arg [arg ...]"

#: builtins.c:138
msgid "read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]"
msgstr "read [-ers] [-a matrice] [-d delim] [-i text] [-n nr_carac] [-N nr_carac [-p prompt] [-t timp] [-u fd] [nume ...]"

#: builtins.c:140
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:142
msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
msgstr "set [-abefhkmnptuvxBCEHPT] [-o nume-opțiune] [--] [-] [arg ...]"

#: builtins.c:144
msgid "unset [-f] [-v] [-n] [name ...]"
msgstr "unset [-f] [-v] [-n] [nume ...]"

#: builtins.c:146
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [nume[=valoare] ...] sau export -p"

#: builtins.c:148
msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [nume[=valoare] ...] sau readonly -p"

#: builtins.c:150
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:152
msgid "source filename [arguments]"
msgstr "source nume_fișier [argumente]"

#: builtins.c:154
msgid ". filename [arguments]"
msgstr ". nume_fișier [argumente]"

#: builtins.c:157
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:160
msgid "test [expr]"
msgstr "test [expr]"

#: builtins.c:162
msgid "[ arg... ]"
msgstr "[ arg... ]"

#: builtins.c:166
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[arg] id_semnal ...]"

#: builtins.c:168
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] nume [nume ...]"

#: builtins.c:171
msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
msgstr "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limită]"

#: builtins.c:174
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [mod]"

#: builtins.c:177
msgid "wait [-fn] [-p var] [id ...]"
msgstr "wait [-fn] [-p var] [id ...]"

#: builtins.c:181
msgid "wait [pid ...]"
msgstr "wait [pid ...]"

#: builtins.c:184
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NUME [in CUVINTE ... ] ; do COMENZI; done"

#: builtins.c:186
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( exp1; exp2; exp3 )); do COMENZI; done"

#: builtins.c:188
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NUME [in CUVINTE ... ;] do COMENZI; done"

#: builtins.c:190
msgid "time [-p] pipeline"
msgstr "time [-p] secvența_de_comenzi(pipeline)"

#: builtins.c:192
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case CUVÂNT in [MODEL[[MODEL]..) COMENZI ;;]... esac"

#: builtins.c:194
msgid "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi"
msgstr "if COMENZI; then COMENZI; [elif COMENZI; then COMENZI; ]... [ else COMENZI; ] fi"

#: builtins.c:196
msgid "while COMMANDS; do COMMANDS-2; done"
msgstr "while COMENZI; do COMENZI-2; done"

#: builtins.c:198
msgid "until COMMANDS; do COMMANDS-2; done"
msgstr "until COMENZI; do COMENZI-2; done"

#: builtins.c:200
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NUME] comanda [redirecționări]"

#: builtins.c:202
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function nume { COMENZI ; } sau nume () { COMENZI ; }"

#: builtins.c:204
msgid "{ COMMANDS ; }"
msgstr "{ COMENZI ; }"

#: builtins.c:206
msgid "job_spec [&]"
msgstr "id_lucrare [&]"

#: builtins.c:208
msgid "(( expression ))"
msgstr "(( expresie ))"

#: builtins.c:210
msgid "[[ expression ]]"
msgstr "[[ expresie ]]"

#: builtins.c:212
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - Numele și semnificațiile unor variabile din shell"

#: builtins.c:215
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | dir]"

#: builtins.c:219
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:223
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:226
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [nume_opțiune ...]"

#: builtins.c:228
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] format [argumente]"

#: builtins.c:231
msgid "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]"
msgstr "complete [-abcdefgjksuv] [-pr] [-DEI] [-o opțiune] [-A acțiune] [-G tipar_glob] [-W listă_cuvinte] [-F funcție] [-C comandă] [-X tipar_filtru [- P prefix] [-S sufix] [nume ...]"

#: builtins.c:235
msgid "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr "compgen [-abcdefgjksuv] [-o opțiune] [-A acțiune] [-G tipar_glob] [-W listă_cuvinte] [-F funcție] [-C comandă] [-X tipar_filtru] [-P prefix] [-S sufix] [cuvânt]"

#: builtins.c:239
msgid "compopt [-o|+o option] [-DEI] [name ...]"
msgstr "compopt [-o|+o opțiune] [-DEI] [nume ...]"

#: builtins.c:242
msgid "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "mapfile [-d delim] [-n cont] [-O origin] [-s cont] [-t] [-u fd] [-C apelare] [-c cantitate] [matrice]"

#: builtins.c:244
msgid "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]"
msgstr "readarray [-d delim] [-n cantitate] [-O origine] [-s cantitate] [-t] [-u fd] [-C apelare] [-c sumă_de] [matrice]"

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help alias», din «bash»;
# «bash -c "help alias"», din «bash», sau dintr-un
# shell, diferit de «bash».
#: builtins.c:256
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tprint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has been\n"
"    defined."
msgstr ""
"Definește sau afișează alias.\n"
"    \n"
"    Fără argumente, «alias» imprimă lista de alias în forma reutilizabilă\n"
"    „alias NUME=VALOARE” la ieșirea standard (pe ecran).\n"
"    \n"
"    În caz contrar, un alias este definit pentru fiecare NUME a cărui VALOARE\n"
"    este dată.  Un spațiu final în VALOARE, face ca următorul cuvânt să fie\n"
"    verificat pentru înlocuirea aliasului atunci când aliasul este extins.\n"
"    \n"
"    Opțiuni:\n"
"      -p\timprimă toate alias definite într-un format reutilizabil\n"
"    \n"
"    Starea de ieșire:\n"
"    «alias» returnează adevărat, cu excepția cazului în care este furnizat\n"
"    un NUME pentru care nu a fost definit niciun alias."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help unalias», din «bash»;
# «bash -c "help unalias"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:278
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Elimină fiecare NUME din lista de aliasuri definite.\n"
"    \n"
"    Opțiuni:\n"
"      -a\telimină toate definițiile de alias\n"
"    \n"
"    Returnează succes, cu excepția cazului în care un NUME nu este un alias existent."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help bind», din «bash»;
# «bash -c "help bind"», din «bash», sau dintr-un
# shell, diferit de «bash».
#: builtins.c:291
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -X                 List key sequences bound with -x and associated commands\n"
"                         in a form that can be reused as input.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Configurează legăturile de taste și variabilele Readline.\n"
"    \n"
"    Asociază o secvență de taste cu o funcție Readline sau cu o macrocomandă\n"
"    sau configurează o variabilă Readline.  Sintaxa argumentului fără opțiune \n"
"    este echivalentă cu cea găsită în ~/.inputrc, dar trebuie transmisă ca un\n"
"    singur argument; de exp.: bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Opțiuni:\n"
"      -m  keymap         Utilizează KEYMAP ca hartă de taste pe durata acestei\n"
"                         comenzi.  Numele valabile pentru hărți de taste sunt emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, și vi-insert.\n"
"      -l                 Enumeră numele funcțiilor.\n"
"      -P                 Enumeră numele și asocierile funcțiilor.\n"
"      -p                 Enumeră funcțiile și asocierile într-o formă care poate fi\n"
"                         reutilizată ca intrare.\n"
"      -S                 Enumeră secvențele de chei care invocă macrocomenzi și\n"
"                         valorile acestora\n"
"      -s                 Enumeră secvențele de chei care invocă macrocomenzi și\n"
"                         valorile acestora într-o formă care poate fi reutilizată ca intrare.\n"
"      -V                 Enumeră numele și valorile variabilelor\n"
"      -v                 Enumeră numele și valorile variabilelor într-o formă care\n"
"                         poate fi reutilizată ca intrare.\n"
"      -q  nume-funcție   Se utilizează pentru a afla care taste invocă funcția numită.\n"
"      -u  nume-funcție   Dezasociază toate tastele care sunt asociate cu funcția numită.\n"
"      -r  sec-taste      Elimină asocierea pentru sec-taste numită.\n"
"      -f  nume-fișier    Citește asocierile de taste din fișierul al cărui nume a fost dat.\n"
"      -x  sec-taste:comandă-shell\tDetermină executarea comandă-shell când este\n"
"    \t\t\t\tintrodusă sec-taste.\n"
"      -X                 Enumeră secvențele de taste asociate cu -x și comenzile asociate într-o\n"
"                         formă care poate fi reutilizată ca intrare.\n"
"    \n"
"    Starea de ieșire:\n"
"    «bind» returnează 0, cu excepția cazului în care este dată o opțiune nerecunoscută, sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help break», din «bash»;
# «bash -c "help break"», din «bash», sau dintr-un
# shell, diferit de «bash».
#: builtins.c:330
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Termină buclele for, while, sau until.\n"
"    \n"
"    Termină o buclă FOR, WHILE sau UNTIL.  Dacă se specifică N, termină\n"
"    numărul de bucle specificat.\n"
"    \n"
"    Starea de ieșire:\n"
"    Starea de ieșire este 0, cu excepția cazului în care N nu este mai mare sau egal cu 1."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help continue», din «bash»;
# «bash -c "help continue"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:342
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Reia buclele for, while, sau until.\n"
"    \n"
"    Reia următoarea iterație a buclei curente FOR, WHILE sau UNTIL.\n"
"    Dacă se specifică N, reia bucla și continuă pentru N niveluri în continuare.\n"
"    \n"
"    Starea de ieșire:\n"
"    Starea de ieșire este 0, cu excepția cazului în care N nu este mai mare sau egal cu 1."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help builtin», din «bash»;
# «bash -c "help builtin"», din «bash», sau dintr-un
# shell, diferit de «bash».
#: builtins.c:354
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin."
msgstr ""
"Execută comenzile interne de shell.\n"
"    \n"
"    Execută SHELL-BUILTIN cu argumentele ARG fără a efectua căutarea comenzilor.\n"
"    Acest lucru este util atunci când doriți să reimplementați o comandă internă de shell\n"
"    ca o funcție shell, dar trebuie să executați comanda internă în cadrul funcției.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea de ieșire a lui SHELL-BUILTIN sau false dacă SHELL-BUILTIN nu\n"
"    este o comandă internă de shell."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help caller», din «bash»;
# «bash -c "help caller"», din «bash», sau dintr-un
# shell, diferit de «bash».
#: builtins.c:369
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Returnează contextul apelului subrutinei curente.\n"
"    \n"
"    Fără EXPR, returnează „$line $filename”. Cu EXPR, returnează\n"
"    „$line $subroutine $filename”; aceste informații suplimentare pot fi\n"
"    utilizate pentru a furniza o urmărire a stivei.\n"
"    \n"
"    Valoarea EXPR indică câte cadre de apel trebuie să se întoarcă înaintea\n"
"    celui curent; cadrul superior este cadrul 0.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează 0, cu excepția cazului în care shell-ul nu execută o funcție shell\n"
"    sau EXPR nu este validă."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help cd», din «bash»;
# «bash -c "help cd"», din «bash», sau dintr-un
# shell, diferit de «bash».
#: builtins.c:387
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n"
"    A null directory name is the same as the current directory.  If DIR begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is set,\n"
"    the word is assumed to be  a variable name.  If that variable has a value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"      -L\tforce symbolic links to be followed: resolve symbolic\n"
"    \t\tlinks in DIR after processing instances of `..'\n"
"      -P\tuse the physical directory structure without following\n"
"    \t\tsymbolic links: resolve symbolic links in DIR before\n"
"    \t\tprocessing instances of `..'\n"
"      -e\tif the -P option is supplied, and the current working\n"
"    \t\tdirectory cannot be determined successfully, exit with\n"
"    \t\ta non-zero status\n"
"      -@\ton systems that support it, present a file with extended\n"
"    \t\tattributes as a directory containing the file attributes\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    `..' is processed by removing the immediately previous pathname component\n"
"    back to a slash or the beginning of DIR.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed, and if $PWD is set successfully when\n"
"    -P is used; non-zero otherwise."
msgstr ""
"Schimbă directorul de lucru al shell-ului.\n"
"    \n"
"    Schimbă directorul actual cu DIR.  DIR implicit este valoarea variabilei de \n"
"    shell HOME.\n"
"    \n"
"    Variabila CDPATH definește calea de căutare pentru directorul care conține\n"
"    DIR.  Numele alternative ale directoarelor din CDPATH sunt separate prin\n"
"    două puncte (:).  Numele unui director nul este același cu directorul curent.\n"
"    Dacă DIR începe cu o bară oblică (/), atunci CDPATH nu este utilizat.\n"
"    \n"
"    Dacă directorul nu este găsit și opțiunea de shell „cdable_vars” este setată,\n"
"    cuvântul se presupune a fi un nume de variabilă.  Dacă acea variabilă are o\n"
"    valoare, valoarea ei este utilizată pentru DIR.\n"
"    \n"
"    Opțiuni:\n"
"      -L\tforțează ca legăturile simbolice să fie urmate: rezolvă \n"
"    \t\tlegăturile simbolice din DIR după procesarea instanțelor de „..”\n"
"      -P\tutilizează structura fizică a directorului fără a urma legăturile\n"
"    \t\tsimbolice: rezolvă legăturile simbolice din DIR înainte de a\n"
"    \t\tprocesa instanțe de „..”\n"
"      -e\tdacă este furnizată opțiunea „-P” și directorul de lucru curent\n"
"    \t\tnu poate fi determinat cu succes, iese cu o stare diferită de\n"
"    \t\tzero\n"
"      -@\tpe sistemele care acceptă acest lucru, prezintă un fișier cu\n"
"    \t\tatribute extinse, ca un director care conține atributele fișierului\n"
"    \n"
"    Modul implicit este să urmeze legături simbolice, ca și cum ar fi fost specificat „-L”.\n"
"    „..” este procesat prin eliminarea componentei de cale imediat anterioară până\n"
"   la o bară oblică sau la începutul DIR.\n"
"    \n"
"   Starea de ieșire:\n"
"    Returnează 0 dacă directorul este schimbat și dacă $PWD este stabilit cu succes atunci\n"
"    când este utilizat „-P”; diferit de zero, în caz contrar."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help pwd», din «bash»;
# «bash -c "help pwd"», din «bash», sau dintr-un
# shell, diferit de «bash».
#: builtins.c:425
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \t\tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Imprimă numele directorului de lucru curent.\n"
"    \n"
"    Opțiuni:\n"
"      -L\timprimă valoarea lui $PWD dacă aceasta numește directorul de\n"
"    \t\tlucru curent\n"
"      -P\timprimă directorul fizic, fără nicio legătură simbolică\n"
"    \n"
"    În mod implicit, „pwd” se comportă ca și cum „-L” ar fi fost specificat.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează 0, cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau directorul curent nu poate fi citit."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help :», din «bash»;
# «bash -c "help :"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:442
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Comandă nulă.\n"
"    \n"
"    Fără efect; comanda nu face nimic.\n"
"    \n"
"    Starea de ieșire:\n"
"    Întotdeauna reușește(0)."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help true», din «bash»;
# «bash -c "help true"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:453
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Returnează un rezultat de succes(0).\n"
"    \n"
"    Starea de ieșire:\n"
"    Întotdeauna reușește(0)."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help false», din «bash»;
# «bash -c "help false"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:462
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Returnează un rezultat nereușit(≠0).\n"
"    \n"
"    Starea de ieșire:\n"
"    Întotdeauna eșuează(≠0)."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help command», din «bash»;
# «bash -c "help command"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:471
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p    use a default value for PATH that is guaranteed to find all of\n"
"            the standard utilities\n"
"      -v    print a description of COMMAND similar to the `type' builtin\n"
"      -V    print a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Execută o comandă simplă sau afișează informații despre comenzi.\n"
"    \n"
"    Rulează COMANDA cu ARGumente care suprimă căutarea funcției shell sau afișează\n"
"    informații despre COMENZILE specificate.  Se poate utiliza pentru a invoca comenzi\n"
"    de pe disc atunci când există o funcție cu același nume.\n"
"    \n"
"    Opțiuni:\n"
"      -p    utilizează o valoare implicită pentru PATH ce garantează că se\n"
"            vor găsi toate utilitățile standard\n"
"      -v    imprimă o descriere a COMENZII, similară cu cea a comenzii\n"
"            interne «type».\n"
"      -V    imprimă o descriere mai detaliată pentru fiecare COMANDĂ\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea de ieșire a COMENZII sau eșuează dacă COMANDA nu este găsită."

# R-GC, scrie:
# am tradus:
# „-I	if ... with the same name at a previous scope”, ca:
# „-I	dacă ... cu același nume dintr-un scop anterior”
# ***
# Întrebare:
# dacă se traduce, ca:
# „-I	dacă ... cu același nume dintr-o sferă de aplicare anterioară”,
# ar fi o traducere mai bună?
# Opinii/Idei?
# ==================================
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help declare», din «bash»;
# «bash -c "help declare"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:490
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \t\tsource file when debugging)\n"
"      -g\tcreate global variables when used in a shell function; otherwise\n"
"    \t\tignored\n"
"      -I\tif creating a local variable, inherit the attributes and value\n"
"    \t\tof a variable with the same name at a previous scope\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert the value of each NAME to lower case on assignment\n"
"      -n\tmake NAME a reference to the variable named by its value\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert the value of each NAME to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the `local'\n"
"    command.  The `-g' option suppresses this behavior.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or a variable\n"
"    assignment error occurs."
msgstr ""
"Stabilește valorile și atributele variabilelor.\n"
"    \n"
"    Declară variabilele și-le atribuie atribute.  Dacă nu sunt date NUME,\n"
"    afișează atributele și valorile tuturor variabilelor.\n"
"    \n"
"    Opțiuni:\n"
"      -f\trestricționează acțiunea sau afișarea, la numele și definițiile funcțiilor\n"
"      -F\trestricționează afișarea numai la numele funcțiilor (plus numărul de\n"
"    \t\tlinie și fișierul sursă, la depanare)\n"
"      -g\tcreează variabile globale atunci când sunt utilizate într-o funcție shell;\n"
"    \t\taltfel sunt ignorate\n"
"      -I\tdacă se creează o variabilă locală, moștenește atributele și valoarea\n"
"    \t\tunei variabile cu același nume dintr-un scop anterior\n"
"      -p\tafișează atributele și valoarea fiecărui NUME\n"
"    \n"
"    Opțiuni care stabilesc atributele:\n"
"      -a\tstabilește NUME ca matrice indexată (dacă este acceptat)\n"
"      -A\tstabilește NUME ca matrice asociativă (dacă este acceptat)\n"
"      -i\tstabilește ca NUME să aibă atributul „integer”\n"
"      -l\tpentru a converti valoarea fiecărui NUME în minuscule, la atribuire\n"
"      -n\tface din NUME o referință la variabila numită după valoarea acesteia\n"
"      -r\tcreează NUME ca numai-citire\n"
"      -t\tstabilește ca NUME să aibă atributul „trace”\n"
"      -u\tpentru a converti valoarea fiecărui NUME în majuscule, la atribuire\n"
"      -x\tpentru a exporta NUME\n"
"    \n"
"    Utilizarea a „+” în loc de „-”, dezactivează atributul dat.\n"
"    \n"
"    Variabilele cu atributul întreg au o evaluare aritmetică (vezi comanda\n"
"    «let») efectuată atunci când variabilei i se atribuie o valoare.\n"
"    \n"
"    Când este folosită într-o funcție, «declare» face ca NUME să fie local, ca\n"
"    și în cazul comenzii «local».  Opțiunea „-g” suprimă acest comportament.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este furnizată o opțiune\n"
"    nevalidă sau apare o eroare de atribuire a variabilelor."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help typeset», din «bash»;
# «bash -c "help typeset"», din «bash», sau dintr-un
# shell, diferit de «bash».
#: builtins.c:532
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    A synonym for `declare'.  See `help declare'."
msgstr ""
"Stabilește valorile și atributele variabilelor.\n"
"    \n"
"    Un sinonim pentru „declare”.  A se vedea „help declare”."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help local», din «bash»;
# «bash -c "help local"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:540
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, a variable\n"
"    assignment error occurs, or the shell is not executing a function."
msgstr ""
"Definește variabilele locale.\n"
"    \n"
"    Creează o variabilă locală numită NUME și îi dă această VALOARE.\n"
"    OPȚIUNE poate fi orice opțiune acceptată de «declare».\n"
"    \n"
"    Variabilele locale pot fi utilizate numai în cadrul unei funcții; sunt\n"
"    vizibile numai pentru funcția în care sunt definite și pentru copiii\n"
"    acesteia.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes cu excepția cazului în care este furnizată o opțiune\n"
"    nevalidă, apare o eroare de atribuire a variabilei sau shell-ul nu execută\n"
"    o funcție."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help echo», din «bash»;
# «bash -c "help echo"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:557
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs, separated by a single space character and followed by a\n"
"    newline, on the standard output.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\E\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \t\tcan be one or two hex digits\n"
"      \\uHHHH\tthe Unicode character whose value is the hexadecimal value HHHH.\n"
"    \t\tHHHH can be one to four hex digits.\n"
"      \\UHHHHHHHH the Unicode character whose value is the hexadecimal value\n"
"    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Scrie argumente la ieșirea standard.\n"
"    \n"
"    Afișează ARGumentele, separate printr-un singur caracter de spațiu și urmate\n"
"    de o nouă linie, în ieșirea standard.\n"
"    \n"
"    Opțiuni:\n"
"      -n\tnu adaugă o nouă linie\n"
"      -e\tactivează interpretarea următoarelor eludări de bară oblică inversă\n"
"      -E\tsuprimă în mod explicit interpretarea eludărilor de bară oblică inversă\n"
"    \n"
"    «echo» interpretează următoarele caractere de eludare de bară oblică inversă:\n"
"      \a\talertă (clopoțel)\n"
"      \\b\tmută cursorul înapoi cu unul sau mai multe spații\n"
"      \\c\tsuprimă ieșirea ulterioară\n"
"      \\e\tcaracter de eludare\n"
"      \\E\tcaracter de eludare\n"
"      \\f\talimentare cu „hîrtie”\n"
"      \\n\tlinie nouă\n"
"      \\r\treturul de caret↵\n"
"      \\t\ttabulator orizontal\n"
"      \\v\ttabulator vertical\n"
"      \\\\\tbară oblică inversă\n"
"      \\0nnn\tcaracterul al cărui cod ASCII este NNN (octal).  NNN poate fi\n"
"    \t\tde la 0 la 3 digiți octali\n"
"      \\xHH\tcaracterul de opt biți a cărui valoare este HH (hexazecimal). HH\n"
"    \t\tpoate fi unu sau doi digiți hexazecimali\n"
"      \\uHHHH\tcaracterul Unicode a cărui valoare este valoarea hexazecimală HHHH.\n"
"    \t\tHHHH poate fi de la unu până la patru digiți hexazecimali.\n"
"      \\UHHHHHHHH caracterul Unicode a cărui valoare este valoarea hexazecimală\n"
"    \t\tHHHHHHHH. HHHHHHHH poate fi de la unu până la opt digiți hexazecimali.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes cu excepția cazului în care apare o eroare de scriere."

#: builtins.c:597
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Scrie argumente la ieșirea standard.\n"
"    \n"
"    Afișează ARGumentele la ieșirea standard urmate de o linie nouă.\n"
"    \n"
"    Opțiuni:\n"
"      -n\tnu adaugă o nouă linie\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes cu excepția cazului în care apare o eroare de scriere."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help enable», din «bash»;
# «bash -c "help enable"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:612
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Activează și dezactivează comenzile interne ale shell-ului.\n"
"    \n"
"    Activează și dezactivează comenzile interne ale shell-ului.  Dezactivarea\n"
"    vă permite să executați o comandă de pe disc care are același nume ca\n"
"    și comanda internă a shell-ului, fără a utiliza calea completă.\n"
"    \n"
"    Opțiuni:\n"
"      -a\tafișează lista comenzilor interne indicând dacă sunt activate sau nu\n"
"      -n\tdezactivează fiecare NUME sau afișează o listă de comenzi interne\n"
"    \t\tdezactivate\n"
"      -p\tafișează lista comenzilor interne într-un format reutilizabil\n"
"      -s\tafișează numai numele comenzilor interne „speciale” Posix\n"
"    \n"
"    Opțiuni care controlează încărcarea dinamică:\n"
"      -f\tÎncarcă comanda internă NUME de la obiectul partajat NUME_FIȘIER\n"
"      -d\tElimină o comandă internă încărcată cu -f\n"
"    \n"
"    Fără opțiuni, fiecare NUME este activat.\n"
"    \n"
"    Pentru a utiliza comanda «test» găsită în $PATH în loc de comanda internă\n"
"    de shell, tastați «enable -n test».\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care NUME nu este o comandă shell internă sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help eval», din «bash»;
# «bash -c "help eval"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:640
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Execută argumente ca o comandă de shell.\n"
"    \n"
"    Combină ARGumentele într-un singur șir, folosește rezultatul ca intrare în\n"
"    shell și execută comenzile rezultate.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea de ieșire a comenzii, sau succes dacă comanda este nulă."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help getopts», din «bash»;
# «bash -c "help getopts"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:652
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters, but if arguments\n"
"    are supplied as ARG values, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analizează argumentele opțiunii.\n"
"    \n"
"    «getopts» este folosit de procedurile shell pentru a analiza parametrii\n"
"    poziționali ca opțiuni.\n"
"    \n"
"    ȘIR_OPȚIUNI conține literele de opțiune care trebuie recunoscute; dacă\n"
"    o literă este urmată de două puncte, se așteaptă ca opțiunea să aibă un\n"
"    argument, care ar trebui să fie separat de aceasta prin spațiu alb.\n"
"    \n"
"    De fiecare dată când este invocată, «getopts» va plasa următoarea opțiune\n"
"    în variabila shell $nume, inițializând nume dacă nu există, iar indexul\n"
"    următorului argument va fi procesat în variabila shell OPTIND.  OPTIND este\n"
"    inițializată la 1 de fiecare dată când shell-ul sau un script shell este\n"
"    invocat.  Când o opțiune necesită un argument, «getopts» plasează acel\n"
"    argument în variabila shell OPTARG.\n"
"    \n"
"    «getopts» raportează erorile într-unul dintre următoarele două moduri.  Dacă\n"
"    primul caracter al lui  ȘIR_OPȚIUNI este două puncte, «getopts» utilizează \n"
"    raportarea silențioasă a erorilor.  În acest mod, nu este afișat niciun mesaj\n"
"    de eroare.  Dacă se găsește o opțiune nevalidă, «getopts» plasează caracterul\n"
"    de opțiune găsit în OPTARG.  Dacă nu este găsit un argument necesar, «getopts»\n"
"    plasează un „:” în NUME și pune în OPTARG caracterul de opțiune găsit.  Dacă\n"
"    «getopts» nu este în modul silențios și se găsește o opțiune nevalidă, «getopts»\n"
"    plasează „?” în NUME și dezactivează OPTARG.  Dacă nu este găsit un argument\n"
"    necesar, un „?” este plasat în NUME, OPTARG este dezactivată și este afișat un\n"
"    mesaj de diagnosticare.\n"
"    \n"
"    Dacă variabila shell OPTERR are valoarea 0, «getopts» dezactivează afișarea\n"
"    mesajelor de eroare, chiar dacă primul caracter al lui  ȘIR_OPȚIUNI nu este \n"
"    două puncte „:”.  OPTERR are valoarea 1 implicit.\n"
"    \n"
"    «getopts» analizează în mod normal parametrii de poziție, dar dacă argumentele\n"
"    sunt furnizate ca valori ARG, acestea sunt analizate în schimb.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes dacă este găsită o opțiune; eșuează dacă se întâlnește\n"
"    sfârșitul opțiunilor sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help exec», din «bash»;
# «bash -c "help exec"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:694
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\texecute COMMAND with an empty environment\n"
"      -l\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error occurs."
msgstr ""
"Înlocuiește shell-ul cu comanda dată.\n"
"    \n"
"    Execută COMANDA, înlocuind acest shell cu programul specificat.\n"
"    ARGUMENTELE devin argumente pentru COMANDA.  Dacă COMANDA nu este\n"
"    specificată, orice redirecționare va avea efect în shell-ul curent.\n"
"    \n"
"    Opțiuni:\n"
"      -a nume\tpasează NUME ca argument zero la COMANDA\n"
"      -c\texecută COMANDA într-un mediu gol\n"
"      -l\tplasează o liniuță în argumentul zero la COMANDA\n"
"    \n"
"    Dacă comanda nu poate fi executată, un shell non-interactiv se va închide, \n"
"    cu excepția cazului în care opțiunea shell „execfail” este setată.\n"
"    \n"
"    Starea de ieșire\n"
"    Returnează succes, cu excepția cazului în care COMANDA nu este găsită sau\n"
"    apare o eroare de redirecționare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help exit», din «bash»;
# «bash -c "help exit"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:715
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Iese din shell.\n"
"    \n"
"    Iese din shell cu starea lui N.  Dacă N este omis, starea de ieșire\n"
"    este starea ultimei comenzi executate."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help logout», din «bash»;
# «bash -c "help logout"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:724
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not executed\n"
"    in a login shell."
msgstr ""
"Iese din shell-ul de autentificare.\n"
"    \n"
"    Iese din shell-ul de autentificare cu starea de ieșire N. Returnează o eroare\n"
"    dacă nu este executată într-un shell de autentificare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help fc», din «bash»;
# «bash -c "help fc"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:734
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error occurs."
msgstr ""
"Afișează sau execută comenzi din lista istoricului.\n"
"    \n"
"    «fc» se utilizează pentru a lista sau edita și re-executa comenzi din lista\n"
"    istoricului.\n"
"    PRIMA și ULTIMA pot fi numere care specifică intervalul sau PRIMA poate fi\n"
"    un șir, ceea ce înseamnă cea mai recentă comandă care începe cu acel șir.\n"
"    \n"
"    Opțiuni:\n"
"      -e NUME_EDIT\n"
"    \t\tselectează ce editor să utilizat.  Implicit este FCEDIT, apoi \n"
"    \t\tEDITOR, apoi vi\n"
"      -l \tlistează linii în loc să editeze\n"
"      -n\tomite numerele de rând la listare\n"
"      -r\tinversează ordinea liniilor (cele mai noi sunt listate primele)\n"
"    \n"
"    Cu formatul «fc -s [tipar=înloc ...] [comanda]», COMANDA este re-executată\n"
"    după ce este efectuată înlocuirea VECHE=NOUĂ.\n"
"    \n"
"    Un alias util de folosit cu aceasta, este «r='fc -s'», astfel încât tastând \n"
"    «r cc» se execută ultima comandă ce începe cu „cc” și tastând «r» se execută\n"
"    din nou ultima comandă folosită.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succesul sau starea comenzii executate; diferit de zero dacă\n"
"    apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help fg», din «bash»;
# «bash -c "help fg"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:764
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Mută procesul în primul plan.\n"
"    \n"
"    Plasează procesul identificat de ID_PROC în primul plan, făcându-l procesul\n"
"    curent.  Dacă ID_PROC nu este prezent, este utilizată noțiunea shell-ului\n"
"    despre procesul curent\n"
"    \n"
"    Starea de ieșire:\n"
"    Starea comenzii plasată în prim-plan sau eșec dacă apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help bg», din «bash»;
# «bash -c "help bg"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:779
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Mută procesul în fundal.\n"
"    \n"
"    Plasează procesele identificate de fiecare ID_PROC în fundal, ca și cum ar fi\n"
"    fost pornite cu „&”.  Dacă ID_PROC nu este prezent, se folosește noțiunea\n"
"    shell-ului despre procesul curent.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care controlul procesului nu este\n"
"    activat sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help hash», din «bash»;
# «bash -c "help hash"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:793
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is displayed.\n"
"    \n"
"    Options:\n"
"      -d\tforget the remembered location of each NAME\n"
"      -l\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
"      -r\tforget all remembered locations\n"
"      -t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Memorizează sau afișează locațiile programelor.\n"
"    \n"
"    Determină și memorizează calea completă a fiecărei comenzi NUME.  Dacă nu\n"
"    sunt date argumente, sunt afișate informații despre comenzile memorate.\n"
"    \n"
"    Opțiuni:\n"
"      -d\tuită locația reținută pentru fiecare NUME\n"
"      -l\tafișează într-un format care poate fi reutilizat ca intrare\n"
"      -p calenume\n"
"        \tutilizează CALENUME drept calea completă a NUME\n"
"      -r\tuită toate locațiile memorizate\n"
"      -t\tafișează locația reținută a fiecărui NUME, precedând fiecare\n"
"    \t\tlocație cu NUMELE corespunzător dacă sunt date mai multe NUME\n"
"    Argumente:\n"
"      NUME\tFiecare NUME este căutat în $PATH și adăugat la lista comenzilor\n"
"    \t\tmemorate.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care NUME nu este găsit sau\n"
"    este dată o opțiune nevalidă."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help help», din «bash»;
# «bash -c "help help"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:818
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \t\tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is given."
msgstr ""
"Afișează informații despre comenzile interne.\n"
"    \n"
"    Afișează scurte rezumate ale comenzilor interne.  Dacă TIPAR, este\n"
"    specificat, oferă ajutor detaliat pentru toate comenzile care se potrivesc\n"
"    cu TIPARul, în caz contrar, este afișată lista temelor de ajutor.\n"
"    \n"
"    Opțiuni:\n"
"      -d\tafișează o scurtă descriere pentru fiecare temă\n"
"      -m\tafișează utilizarea în format pseudo-pagină de manual\n"
"      -s\tafișează doar un scurt rezumat de utilizare pentru\n"
"    \t\tfiecare temă care se potrivește cu TIPAR\n"
"    \n"
"    Argumente:\n"
"      TIPAR  \tTIPAR care specifică o temă de ajutor\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care TIPAR nu este găsit sau este\n"
"    dată o opțiune nevalidă."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help history», din «bash»;
# «bash -c "help history"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:842
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at position OFFSET. Negative\n"
"    \t\toffsets count back from the end of the history list\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"    \t\tand append them to the history list\n"
"      -r\tread the history file and append the contents to the history\n"
"    \t\tlist\n"
"      -w\twrite the current history to the history file\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \t\twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Afișează sau manipulează lista istoricului.\n"
"    \n"
"    Afișează lista istoricului cu numere de linie, prefixând fiecare intrare\n"
"    modificată cu un „*”.  Un argument de N, listează numai ultimele N intrări.\n"
"    \n"
"    Opțiuni:\n"
"      -c\tșterge lista istoricului ștergând toate intrările\n"
"      -d poziție\n"
"    \t\tșterge intrarea din istoric de la poziția POZIȚIE.  Pozițiile\n"
"    \t\tnegative se numără înapoi de la sfârșitul listei istoricului\n"
"    \n"
"      -a\tadaugă linii istorice din această sesiune la fișierul istoricului\n"
"      -n\tcitește toate liniile istorice care nu sunt deja citite din\n"
"    \t\tfișierul istoricului și le adaugă la lista istoricului\n"
"      -r\tcitește fișierul istoricului și îi adaugă conținutul la lista\n"
"    \t\tistoricului\n"
"      -w\tscrie istoricul curent în fișierul istoricului\n"
"    \n"
"      -p\tefectuează extinderea istoricului pentru fiecare ARG și afișează\n"
"    \t\trezultatul fără a-l stoca în lista istoricului\n"
"      -s\tadaugă ARGumentele la lista istoricului ca o singură intrare\n"
"    \n"
"    Dacă NUME_FIȘIER este dat, acesta este utilizat ca fișierul istoricului.\n"
"    Altfel, dacă HISTFILE are o valoare, aceasta este folosită, dacă nu are,\n"
"    se folosește ~/.bash_history.\n"
"    \n"
"    Dacă variabila HISTTIMEFORMAT este definită și nu este nulă, valoarea ei este\n"
"    utilizată ca șir de format pentru strftime(3) pentru a imprima marcajul de\n"
"    timp asociat cu fiecare intrare din istoric afișată.  În caz contrar, nu se\n"
"    imprimă marcajele de timp.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help jobs», din «bash»;
# «bash -c "help jobs"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:879
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlists only processes that have changed status since the last\n"
"    \t\tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Afișează starea proceselor.\n"
"    \n"
"    Listează procesele active.  ID_PROC, restrânge afișarea la acel proces.\n"
"    Fără opțiuni, se afișează starea tuturor proceselor active.\n"
"    \n"
"    Opțiuni:\n"
"      -l\tlistează ID-urile proceselor, pe lângă informațiile normale\n"
"      -n\tlistează numai procesele care s-au schimbat de la ultima notificare\n"
"      -p\tlistează numai ID-urile proceselor\n"
"      -r\trestrânge afișarea, la procesele în execuție\n"
"      -s\trestrânge afișarea, la procesele oprite\n"
"    \n"
"    Dacă este furnizată -x, COMANDA este rulată după ce toate specificațiile\n"
"    procesului care apar în ARGumente au fost înlocuite cu ID-ul de proces al\n"
"    liderului grupului de procese, al procesului respectiv.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau apare o eroare.\n"
"    Dacă se utilizează „-x”, returnează starea de ieșire a COMENZII."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help disown», din «bash»;
# «bash -c "help disown"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:906
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \t\tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Elimină procese din shell-ul actual.\n"
"    \n"
"    Elimină fiecare argument ID_PROC din tabelul de procese active.  Fără\n"
"    niciun ID_PROC, shell-ul folosește noțiunea sa de proces curent.\n"
"    \n"
"    Opțiuni:\n"
"      -a\telimină toate procesele dacă ID_PROC nu este furnizat\n"
"      -h\tmarchează fiecare ID_PROC astfel încât SIGHUP să nu fie trimis\n"
"    \t\tla proces dacă shell-ul primește un semnal SIGHUP\n"
"      -r\telimină numai procesele care rulează\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau ID_PROC."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help kill», din «bash»;
# «bash -c "help kill"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:925
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \t\tassumed to be signal numbers for which names should be listed\n"
"      -L\tsynonym for -l\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Trimite un semnal către un proces.\n"
"    \n"
"    Trimite proceselor identificate prin PID sau JOBSPEC semnalul numit de\n"
"    SIGSPEC sau de SIGNUM.  Dacă nici SIGSPEC, nici SIGNUM nu sunt\n"
"    prezente, atunci se presupune SIGTERM.\n"
"    \n"
"    Opțiuni:\n"
"      -s sig\tSIG este un nume de semnal\n"
"      -n sig\tSIG este un număr de semnal\n"
"      -l\tlistează numele semnalelor; dacă după „-l” urmează argumente, se\n"
"    \t\tpresupune că sunt numere de semnal pentru care ar trebui listate\n"
"    \t\tnume\n"
"      -L\tsinonim cu -l\n"
"    \n"
"    Kill este o comandă internă de shell din două motive: permite utilizarea\n"
"    ID-urilor de job în locul ID-urilor de proces și permite omorârea proceselor\n"
"    dacă este atinsă limita de procese pe care le puteți crea.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help let», din «bash»;
# «bash -c "help let"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:949
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise."
msgstr ""
"Evaluează expresii aritmetice.\n"
"    \n"
"    Evaluează fiecare ARGument ca o expresie aritmetică.  Evaluarea se face\n"
"    în numere întregi cu lățime fixă, fără verificarea depășirii, dar împărțirea\n"
"    la 0 este detectată și semnalată ca o eroare.  Următoarea listă de operatori\n"
"    este grupată în grupuri de operatori cu prioritate egală.  Nivelurile sunt\n"
"    listate în ordinea descrescătoare a priorității.\n"
"    \n"
"    \tid++, id--\tpost-incrementare, post-decrementare a variabilei\n"
"    \t++id, --id\tpre-incrementare, pre-decrementare a variabilei\n"
"    \t-, +\t\tminus unar, plus unar\n"
"    \t!, ~\t\tnegații logice și binare\n"
"    \t**\t\texponențial\n"
"    \t*, /, %\t\tînmulțire, împărțire, rest\n"
"    \t+, -\t\tadunare, scădere\n"
"    \t<<, >>\t\tdeplasare binară la stânga și la dreapta\n"
"    \t<=, >=, <, >\tcomparare\n"
"    \t==, !=\t\tegalitate, inegalitate\n"
"    \t&\t\tși (AND) binar\n"
"    \t^\t\tsau exclusiv (XOR) binar\n"
"    \t|\t\tsau (OR) binar\n"
"    \t&&\t\tlși (AND) logic\n"
"    \t||\t\tsau (OR) logic\n"
"    \texpr ? expr : expr\n"
"    \t\t\toperator condițional\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tasignare\n"
"    \n"
"    Variabilele shell sunt permise ca operanzi.  Numele variabilei este\n"
"    înlocuit cu valoarea acesteia (constrânsă la un număr întreg cu \n"
"    lățime fixă) în cadrul unei expresii.  Nu este necesar ca variabila să\n"
"    aibă atributul întreg activat pentru a fi utilizată într-o expresie.\n"
"    \n"
"    Operatorii sunt evaluați în ordinea de prioritate.  Subexpresiile din\n"
"    paranteze sunt evaluate mai întâi și pot suprascrie regulile de\n"
"    precedență de mai sus.\n"
"    \n"
"   Starea de ieșire:\n"
"   Dacă ultimul ARGument este evaluat la 0, «let» returnează 1; în caz contrar,\n"
"   «let» returnează 0."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help read», din «bash»;
# «bash -c "help read"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:994
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters. By default, the backslash character escapes delimiter characters\n"
"    and newline.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\tuse Readline to obtain the line\n"
"      -i text\tuse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than\n"
"    \t\tNCHARS characters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, unless\n"
"    \t\tEOF is encountered or read times out, ignoring any\n"
"    \t\tdelimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\tdo not allow backslashes to escape any characters\n"
"      -s\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of\n"
"    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
"    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
"    \t\timmediately, without trying to read any data, returning\n"
"    \t\tsuccess only if input is available on the specified\n"
"    \t\tfile descriptor.  The exit status is greater than 128\n"
"    \t\tif the timeout is exceeded\n"
"      -u fd\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times out\n"
"    (in which case it's greater than 128), a variable assignment error occurs,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Citește o linie din intrarea standard și o împarte în câmpuri.\n"
"    \n"
"    Citește o singură linie din intrarea standard sau din descriptorul de fișier\n"
"    FD dacă este furnizată opțiunea -u.  Linia este împărțită în câmpuri ca în\n"
"    cazul împărțirii cuvintelor, iar primul cuvânt este atribuit primului NUME, \n"
"    al doilea cuvânt celui de-al doilea NUME și așa mai departe, ultimul NUME\n"
"    preluând lista cuvintelor rămase.  Doar caracterele găsite în $IFS sunt\n"
"    recunoscute ca delimitatori de cuvinte. În mod implicit, caracterul bară oblică\n"
"    inversă eludează caracterele delimitatoare și linia nouă.\n"
"    \n"
"    Dacă nu sunt furnizate NUME, linia citită este stocată în variabila REPLY.\n"
"    \n"
"    Opțiuni:\n"
"      -a matrice\n"
"    \t\tatribuie cuvintele citite indicilor secvențiali ai variabilei\n"
"    \t\tmatrice MATRICE, începând de la zero\n"
"      -d delim\tcontinuă până când este citit primul caracter din DELIM, în loc\n"
"    \t\tde linia nouă\n"
"      -e\tutilizează Readline pentru a obține linia\n"
"      -i text\tutilizează TEXT ca text inițial pentru Readline\n"
"      -n ncarac\treturnează după citirea a NCARAC caractere în loc să aștepte\n"
"    \t\to nouă linie, dar respectă delimitatorul dacă sunt citite mai\n"
"    \t\tpuțin de NCARAC caractere înainte de delimitator\n"
"      -N ncarac\treturnează numai după citirea exactă a NCARAC caractere, cu\n"
"    \t\texcepția cazului în care se întâlnește sfârșitul fișierului sau \n"
"    \t\tdacă timpul de citire expiră, eliminând orice delimitatori\n"
"      -p prompt\tafișează șirul PROMPT fără un caracter de linie nouă la final,\n"
"    \t\tînainte de a încerca să citească\n"
"      -r\tnu permite barelor oblice inverse să eludeze niciun caracter\n"
"      -s\tnu afișează ieșirea ce vine de la un terminal\n"
"      -t timeout\n"
"    \t\texpiră și returnează un cod de eroare dacă o linie completă de\n"
"    \t\tintrare nu este citită în TIMEOUT secunde.  Valoarea variabilei\n"
"    \t\tTIMEOUT este timpul de expirare implicit.  TIMEOUT poate fi un\n"
"    \t\tnumăr fracțional.  Dacă TIMEOUT este zero, citirea se termină\n"
"    \t\timediat fără a încerca să citească date, și returnează un cod de\n"
"    \t\tsucces numai dacă intrarea este disponibilă pe descriptorul de\n"
"    \t\tfișier specificat.  Starea de ieșire este mai mare de 128 dacă\n"
"    \t\ttimpul de expirare este depășit\n"
"      -u fd\tcitește din descriptorul de fișier FD în loc de intrarea standard\n"
"    \n"
"    Starea de ieșire:\n"
"    Codul de returnare este zero, cu excepția cazului în care se întâlnește\n"
"    sfârșitul fișierului, expirarea timpului de citire (caz în care este mai mare\n"
"    de 128), apare o eroare de atribuire a variabilei sau este furnizat un\n"
"    descriptor de fișier nevalid ca argument pentru opțiunea „-u”."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help return», din «bash»;
# «bash -c "help return"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1042
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Returnează dintr-o funcție shell.\n"
"    \n"
"    Determină ieșirea unei funcții sau a unui script sursă cu valoarea de\n"
"    returnare specificată de N.  Dacă N este omis, starea de returnare\n"
"    este cea a ultimei comenzi executate în funcție sau script.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează N sau eșec dacă shell-ul nu execută o funcție sau un script."

# R-GC, scrie:
# unele dintre definițiile acestui(lung) mesaj,
# sunt adaptări ale muncii altor echipe din TP.
# ***
# Mulțumesc, tuturor acestor echipe: es, fr, pt_BR, pt, it, nl, pl, uk; sper să nu fi uitat
# niciuna dintre cele ce mi-au folosit ca
# inspirație, în traducerea acestui mesaj.
# =================================
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help set», din «bash»;
# «bash -c "help set"», din «bash», sau dintr-un
# shell, diferit de «bash».
#: builtins.c:1055
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not resolve symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n"
"      --  Assign any remaining arguments to the positional parameters.\n"
"          If there are no remaining arguments, the positional parameters\n"
"          are unset.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Stabilește sau anulează valorile opțiunilor de shell și ale parametrilor\n"
"poziționali.\n"
"    \n"
"    Modifică valoarea atributelor shell și a parametrilor poziționali sau \n"
"    afișează numele și valorile variabilelor shell.\n"
"    \n"
"    Opțiuni:\n"
"      -a  Marchează variabilele care sunt modificate sau create, pentru export.\n"
"      -b  Notifică imediat când o sarcină este finalizată.\n"
"      -e  Termină imediat dacă o comandă termină cu o stare diferită de zero.\n"
"      -f  Dezactivează folosirea metacaracterelor pentru completarea numelor\n"
"          fișierelor (fără „globbing”).\n"
"      -h  Memorizează locația comenzilor pe măsură ce sunt căutate.\n"
"      -k  Toate argumentele de atribuire sunt plasate în mediul(environment)\n"
"          unei comenzi, nu doar cele care preced numele comenzii.\n"
"      -m  Activează controlul sarcinii.\n"
"      -n  Citește comenzile, dar nu le execută.\n"
"      -o  nume-opțiune\n"
"          Stabilește variabila corespunzătoare → nume-opțiune:\n"
"              allexport    la fel ca -a\n"
"              braceexpand  la fel ca -B\n"
"              emacs        utilizează o interfață de editare a liniilor în\n"
"                           stilul «emacs»\n"
"              errexit      la fel ca -e\n"
"              errtrace     la fel ca -E\n"
"              functrace    la fel ca -T\n"
"              hashall      la fel ca -h\n"
"              histexpand   la fel ca -H\n"
"              history      activează istoricul comenzilor\n"
"              ignoreeof    shell-ul nu va termina după citirea „EOF”\n"
"              interactive-comments\n"
"                           permite comentariilor să apară în comenzile interactive\n"
"              keyword      la fel ca -k\n"
"              monitor      la fel ca -m\n"
"              noclobber    la fel ca -C\n"
"              noexec       la fel ca -n\n"
"              noglob       la fel ca -f\n"
"              nolog        acceptat în prezent, dar ignorat\n"
"              notify       la fel ca -b\n"
"              nounset      la fel ca -u\n"
"              onecmd       la fel ca -t\n"
"              physical     la fel ca -P\n"
"              pipefail     valoarea returnată a unei linii de conectare este\n"
"                           starea ultimei comenzi care a ieșit cu o stare diferită\n"
"                           de zero sau zero dacă nicio comandă nu a ieșit cu o\n"
"                           stare diferită de zero\n"
"              posix        modifică comportamentul lui «bash» în cazul în care\n"
"                           operația implicită diferă de standardul Posix, pentru\n"
"                           a se potrivi cu standardul Posix\n"
"              privileged   la fel ca -p\n"
"              verbose      la fel ca -v\n"
"              vi           utilizează o interfață de editare a liniilor în\n"
"                           stilul «vi»\n"
"              xtrace       la fel ca -x\n"
"      -p  Modul cu privilegii: Activat ori de câte ori ID-urile de utilizator\n"
"          reale și efective nu se potrivesc.  Dezactivează procesarea \n"
"          fișierului $ENV și importul funcțiilor shell. Dezactivarea acestei\n"
"          opțiuni face ca uid-ul și gid-ul efectiv să fie stabilite la uid-ul și\n"
"          gid-ul real\n"
"      -t  Termină după citirea și executarea unei comenzi.\n"
"      -u  Tratează variabilele nedefinite ca pe o eroare la substituire.\n"
"      -v  Afișează liniile de intrare ale shell-ului pe măsură ce sunt citite.\n"
"      -x  Afișează comenzile și argumentele lor pe măsură ce sunt executate.\n"
"      -B  Shell-ul va efectua înlocuirea acoladelor (de exp.: a{b,c} → ab ac)\n"
"      -C  Dacă este specificată, nu permite ca fișierele obișnuite existente să\n"
"          fie suprascrise prin redirecționarea ieșirii.\n"
"      -E  Dacă este specificată, capturarea ERR este moștenită de funcțiile shell.\n"
"      -H  Permite înlocuirea istoricului cu un „!”.  Această opțiune este activată\n"
"          în mod implicit atunci când shell-ul este interactiv.\n"
"      -P  Dacă este specificată, legăturile simbolice nu sunt urmate la executarea\n"
"          comenzilor precum «cd» care schimbă directorul curent.\n"
"      -T  Dacă este specificată, capturile DEBUG și RETURN sunt moștenite de\n"
"          funcțiile shell.\n"
"      --  Atribuie toate argumentele rămase parametrilor de poziție.\n"
"          Dacă nu există argumente rămase, parametrii de poziție sunt eliminați.\n"
"      -   Atribuie toate argumentele rămase parametrilor de poziție.\n"
"          Opțiunile -x și -v sunt dezactivate.\n"
"    \n"
"    Utilizarea lui „+” în loc de „-”, face ca aceste opțiuni să fie dezactivate.\n"
"    Opțiunile pot fi folosite și la invocarea shell-ului.  Setul actual de \n"
"    opțiuni poate fi găsit în $-.  Restul de n ARG sunt parametri poziționali și\n"
"    sunt alocați, în ordine, la $1, $2, .. $n.  Dacă nu sunt date ARG, toate \n"
"    variabilele shell sunt afișate.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes cu excepția cazului în care este dată o opțiune nevalidă."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help unset», din «bash»;
# «bash -c "help unset"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1140
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"      -n\ttreat each NAME as a name reference and unset the variable itself\n"
"    \t\trather than the variable it references\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Anulează valorile și atributele variabilelor și funcțiilor shell.\n"
"    \n"
"    Pentru fiecare NUME, elimină variabila sau funcția corespunzătoare.\n"
"    \n"
"    Opțiuni:\n"
"      -f\ttratează fiecare NUME ca pe o funcție shell\n"
"      -v\ttratează fiecare NUME ca pe o variabilă shell\n"
"      -n\ttratează fiecare NUME ca referință de nume și anulează variabila\n"
"    \t\tîn sine, în loc de variabila la care face referire\n"
"    \n"
"    Fără opțiuni, „unset” încearcă mai întâi să anuleze o variabilă și, dacă\n"
"    aceasta nu reușește, încearcă să anuleze o funcție.\n"
"    \n"
"    Unele variabile nu pot fi anulate; consultați, de asemenea, «readonly».\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau un NUME este doar pentru citire."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help export», din «bash»;
# «bash -c "help export"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1162
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Stabilește atributul de export pentru variabilele shell.\n"
"    \n"
"    Marchează fiecare NUME pentru export automat în mediul(environment)\n"
"    comenzilor executate ulterior.  Dacă este furnizată VALOAREa, atribuie\n"
"    VALOAREa înainte de a exporta.\n"
"    \n"
"    Opțiuni:\n"
"      -f\tse referă la funcțiile shell\n"
"      -n\telimină proprietatea de export din fiecare NUME\n"
"      -p\tafișează o listă cu toate variabilele și funcțiile exportate\n"
"    \n"
"    Un argument de „--” dezactivează procesarea ulterioară a opțiunilor.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau NUME nu este valid."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help readonly», din «bash»;
# «bash -c "help readonly"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1181
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables or functions,\n"
"    \t\tdepending on whether or not the -f option is given\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marchează variabilele shell ca neschimbabile.\n"
"    \n"
"    Marchează fiecare NUME ca fiind doar pentru citire; valorile acestor NUME\n"
"    nu pot fi modificate prin atribuirea ulterioară. Dacă este furnizată VALOARE,\n"
"    atribuie VALOARE înainte de a marca ca doar pentru citire.\n"
"    \n"
"    Opțiuni:\n"
"      -a\tse referă la variabilele matrice indexate\n"
"      -A\tse referă la variabile matrice asociative\n"
"      -f\tse referă la funcțiile shell\n"
"      -p\tafișează o listă cu toate variabilele sau funcțiile protejate\n"
"    \t\tla scriere, în funcție de dacă este dată sau nu opțiunea „-f”\n"
"    \n"
"    Un argument de „--” dezactivează procesarea ulterioară a opțiunilor.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau NUME nu este valid."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help shift», din «bash»;
# «bash -c "help shift"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1203
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Schimbă parametrii poziționali.\n"
"    \n"
"    Redenumește parametrii de poziție $N+1,$N+2 ... la $1,$2 ...  Dacă N\n"
"    nu este dat, se presupune că este 1.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care N este negativ sau mai\n"
"    mare decât $#."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help source», din «bash»;
# «bash -c "help source"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1215 builtins.c:1230
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Execută comenzi dintr-un fișier în shell-ul curent.\n"
"    \n"
"    Citește și execută comenzi din NUME_FIȘIER în shell-ul curent.  Intrările \n"
"    din $PATH sunt utilizate pentru a găsi directorul care conține NUME_FIȘIER.\n"
"    Dacă sunt furnizate ARGUMENTE, acestea devin parametrii de poziție atunci\n"
"    când este executat NUME_FIȘIER.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimei comenzi executate în NUME_FIȘIER; eșuează dacă\n"
"    NUME_FIȘIER nu poate fi citit."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help suspend», din «bash»;
# «bash -c "help suspend"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1246
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Suspendă execuția shell-ului.\n"
"    \n"
"    Suspendă execuția acestui shell până când primește un semnal SIGCONT.\n"
"    Cu excepția cazului în care sunt forțate, shell-urile de autentificare nu pot \n"
"    fi suspendate.\n"
"    \n"
"    Opțiuni:\n"
"      -f\tforțează suspendarea, chiar dacă shell-ul este un shell de\n"
"        \tautentificare\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care controlul sarcinii nu este\n"
"    activat sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help test», din «bash»;
# «bash -c "help test"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1262
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators and numeric comparison operators as well.\n"
"    \n"
"    The behavior of test depends on the number of arguments.  Read the\n"
"    bash manual page for the complete specification.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      -v VAR         True if the shell variable VAR is set.\n"
"      -R VAR         True if the shell variable VAR is set and is a name\n"
"                     reference.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Evaluează expresia condițională.\n"
"    \n"
"    Termină cu starea 0 (adevărat) sau 1 (fals) în funcție de evaluarea EXPR.\n"
"    Expresiile pot fi unare sau binare. Expresiile unare sunt adesea folosite\n"
"    pentru a examina starea unui fișier. Există de-asemeni operatori de șir și\n"
"    operatori de comparație numerică.\n"
"    \n"
"    Comportamentul testului depinde de numărul de argumente. Citiți pagina\n"
"    de manual, «bash», pentru specificația completă.\n"
"    \n"
"    Operatori de fișiere:\n"
"    \n"
"      -a FIȘIER      Adevărat dacă fișierul există.\n"
"      -b FIȘIER      Adevărat dacă fișierul este un dispozitiv de blocuri.\n"
"      -c FIȘIER      Adevărat dacă fișierul este un dispozitiv de caractere.\n"
"      -d FIȘIER      Adevărat dacă fișierul este un director.\n"
"      -e FIȘIER      Adevărat dacă fișierul există.\n"
"      -f FIȘIER      Adevărat dacă fișierul există și este un fișier normal.\n"
"      -g FIȘIER      Adevărat dacă fișierul are activat bitul „set-group-id”.\n"
"      -h FIȘIER      Adevărat dacă fișierul este o legătură simbolică.\n"
"      -L FIȘIER      Adevărat dacă fișierul este o legătură simbolică..\n"
"      -k FIȘIER      Adevărat dacă fișierul are activat bitul „sticky” (lipicios).\n"
"      -p FIȘIER      Adevărat dacă fișierul este o linie de conectare numită.\n"
"      -r FIȘIER      Adevărat dacă fișierul poate fi citit de dumneavoastră.\n"
"      -s FIȘIER      Adevărat dacă fișierul există și nu este gol.\n"
"      -S FIȘIER      Adevărat dacă fișierul este un soclu.\n"
"      -t DF          Adevărat dacă DF(descriptorul de fișier) este deschis pe un terminal.\n"
"      -u FIȘIER      Adevărat dacă fișierul are activat bitul „set-user-id”.\n"
"      -w FIȘIER      Adevărat dacă fișierul poate fi scris de dumneavoastră.\n"
"      -x FIȘIER      Adevărat dacă fișierul poate fi executat de dumneavoastră.\n"
"      -O FIȘIER      Adevărat dacă fișierul este deținut efectiv de dumneavoastră.\n"
"      -G FIȘIER      Adevărat dacă fișierul este deținut efectiv de grupul dumneavoastră.\n"
"      -N FIȘIER      Adevărat dacă fișierul a fost modificat de la ultima citire.\n"
"    \n"
"      FIȘI1 -nt FIȘI2  Adevărat dacă fișierul 1 este mai nou decât fișierul 2 (conform\n"
"                       datei modificării).\n"
"    \n"
"      FIȘI1 -ot FIȘI2  Adevărat dacă fișierul1 este mai vechi decât fișierul2.\n"
"    \n"
"      FIȘI1 -ef FIȘI2  Adevărat dacă fișierul1 este o legătură dură către fișierul2.\n"
"    \n"
"    Operatori de șir:\n"
"    \n"
"      -z ȘIR         Adevărat dacă șirul este gol.\n"
"    \n"
"      -n ȘIR         Adevărat dacă șirul nu este gol.\n"
"      ȘIR            Adevărat dacă șirul nu este gol.\n"
"    \n"
"      ȘIR1 = ȘIR2    Adevărat dacă șirurile sunt egale.\n"
"      ȘIR1 != ȘIR2   Adevărat dacă șirurile nu sunt egale.\n"
"      ȘIR1 < ȘIR2    Adevărat dacă ȘIR1 se ordonează lexicografic înainte de ȘIR2.\n"
"      ȘIR1 > ȘIR2    Adevărat dacă ȘIR1 se ordonează lexicografic după ȘIR2.n\n"
"    \n"
"    Alți operatori:\n"
"    \n"
"      -o OPȚIUNE     Adevărat dacă opțiunea shell OPȚIUNE este activată.\n"
"      -v VAR         Adevărat dacă este definită variabila shell VAR.\n"
"      -R VAR         Adevărat dacă variabila shell VAR este definită și este o referință\n"
"                     de nume.\n"
"      ! EXPR         Adevărat dacă expresia EXPR este falsă.\n"
"      EXPR1 -a EXPR2 Adevărat dacă amândouă expresiile EXPR1 și EXPR2 sunt adevărate.\n"
"      EXPR1 -o EXPR2 Adevărat dacă fie expresia EXPR1, fie expresia EXPR2 este adevărată.\n"
"    \n"
"      ARG1 OP ARG2   Teste aritmetice.  OP este unul dintre -eq, -ne, -lt, -le, -gt, sau -ge.\n"
"    \n"
"    Operatorii binari aritmetici returnează adevărat dacă ARG1 este egal, inegal, mai mic\n"
"    decât, mai mic decât sau egal, mai mare decât, sau mai mare decât sau egal cu ARG2.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes dacă EXPR este evaluată ca adevărată; eșuează dacă EXPR este\n"
"    evaluată ca fiind falsă sau este dat un argument nevalid."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help [», din «bash»;
# «bash -c "help ["», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1344
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Evaluează expresia condițională.\n"
"    \n"
"    Acesta este un sinonim pentru comanda internă «test», dar ultimul argument\n"
"    trebuie să fie un „]” literal, pentru a se potrivi cu „[” de deschidere."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help times», din «bash»;
# «bash -c "help times"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1353
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Afișează timpii procesului.\n"
"    \n"
"    Afișează timpii acumulați de utilizator și sistem pentru shell și pentru toate\n"
"    procesele sale secundare.\n"
"    \n"
"    Starea de ieșire:\n"
"    Întotdeauna reușește(0)."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help trap», din «bash»;
# «bash -c "help trap"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1365
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  If\n"
"    a SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or a\n"
"    script run by the . or source builtins finishes executing.  A SIGNAL_SPEC\n"
"    of ERR means to execute ARG each time a command's failure would cause the\n"
"    shell to exit when the -e option is enabled.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is given."
msgstr ""
"Capturează semnale și alte evenimente.\n"
"    \n"
"    Definește și activează operatorii care urmează să fie rulați atunci când\n"
"    shell-ul primește semnale sau apar alte evenimente.\n"
"    \n"
"    ARG este o comandă care trebuie citită și executată atunci când shell-ul\n"
"    primește semnalul(ele) SIGNAL_SPEC.  Dacă ARG este absentă (și este\n"
"    furnizat un singur SIGNAL_SPEC) sau „-”, fiecare semnal specificat este\n"
"    restabilit la valoarea sa originală.  Dacă ARG este un șir nul, fiecare\n"
"    SIGNAL_SPEC este ignorat de către shell și de comenzile pe care le invocă.\n"
"    \n"
"    Dacă un SIGNAL_SPEC este EXIT (0), ARG este executat la ieșirea din shell.\n"
"    Dacă un SIGNAL_SPEC este DEBUG, ARG este executat înainte de fiecare comandă\n"
"    simplă.  Dacă un SIGNAL_SPEC este RETURN, ARG este executat de fiecare dată \n"
"    când o funcție shell sau un script rulat din . sau comanda internă «source»\n"
"    se termină de executat.  Un SIGNAL_SPEC de ERR face ca ARG să fie executat\n"
"    de fiecare dată când eșecul unei comenzi ar determina terminarea shell-ului\n"
"    atunci când opțiunea „-e” este activată. \n"
"    \n"
"    Dacă nu sunt furnizate argumente, «trap» afișează lista de comenzi asociate\n"
"    fiecărui semnal.\n"
"    \n"
"    Opțiuni:\n"
"      -l\tafișează o listă de nume de semnale și numerele corespunzătoare\n"
"        \tale acestora\n"
"      -p\tafișează comenzile de captură asociate fiecărui SIGNAL_SPEC\n"
"    \n"
"    Fiecare SIGNAL_SPEC este fie un nume de semnal în <signal.h>, fie un număr\n"
"    de semnal.  Numele semnalelor nu fac distincție între majuscule și minuscule,\n"
"    iar prefixul SIG este opțional.  Un semnal poate fi trimis către shell cu\n"
"    «kill -signal $$».\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care un SIGSPEC este nevalid sau \n"
"    este dată o opțiune nevalidă."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help type», din «bash»;
# «bash -c "help type"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1401
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \t\tincludes aliases, builtins, and functions, if and only if\n"
"    \t\tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \t\tbuiltin, or function, and returns the name of the disk file\n"
"    \t\tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \t\tor nothing if `type -t NAME' would not return `file'\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t\t`function', `builtin', `file' or `', if NAME is an alias,\n"
"    \t\tshell reserved word, shell function, shell builtin, disk file,\n"
"    \t\tor not found, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not found."
msgstr ""
"Afișează informații despre comanda «type».\n"
"    \n"
"    Pentru fiecare NUME, indică cum ar fi interpretat dacă ar fi folosit ca\n"
"    nume de comandă.\n"
"    \n"
"    Opțiuni:\n"
"      -a\tafișează toate locațiile care conțin un executabil numit NUME; \n"
"    \t\tinclude alias, componente integrate și funcții, dacă și numai\n"
"    \t\tdacă opțiunea „-p” nu este, de asemenea, utilizată\n"
"      -f\tsuprimă căutarea funcției de shell\n"
"      -P\tforțează o căutare PATH pentru fiecare NUME, chiar dacă este un\n"
"    \t\talias, o comandă internă sau o funcție, și returnează numele\n"
"    \t\tfișierului din disc care va fi executat\n"
"      -p\treturnează fie numele fișierului de pe disc care va fi executat,\n"
"    \t\tfie nimic dacă «type -t NUME» nu va returna „file”\n"
"      -t\tafișează un singur cuvânt care este unul dintre „alias”, „keyword”,\n"
"    \t\t„function”, „builtin”, „file” sau „”, dacă NUME este un alias,\n"
"    \t\tcuvânt rezervat shell, funcție shell, comandă internă shell,\n"
"    \t\tfișier pe disc, sau, respectiv, negăsit\n"
"    \n"
"    Argumente:\n"
"      NUME\tNumele comenzii de interpretat.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes dacă toate NUMEle sunt găsite; eșuează dacă nu sunt găsite."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help ulimit», din «bash»;
# «bash -c "help ulimit"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1432
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -k\tthe maximum number of kqueues allocated for this process\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"      -P\tthe maximum number of pseudoterminals\n"
"      -R\tthe maximum time a real-time process can run before blocking\n"
"      -T\tthe maximum number of threads\n"
"    \n"
"    Not all options are available on all platforms.\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modifică limitele resurselor shell.\n"
"    \n"
"    Oferă control asupra resurselor disponibile shell-ului și proceselor pe care\n"
"    acesta le creează, pe sisteme care permit un astfel de control.\n"
"    \n"
"    Opțiuni:\n"
"      -S\tutilizează limita de resurse „soft”\n"
"      -H\tutilizează limita de resurse „hard”\n"
"      -a\tsunt raportate toate limitele curente\n"
"      -b\tdimensiunea memoriei tampon a soclului\n"
"      -c\tdimensiunea maximă a fișierelor create cu conținutul memoriei (core)\n"
"      -d\tdimensiunea maximă a segmentului de date al unui proces\n"
"      -e\tprioritatea maximă de planificare („nice”)\n"
"      -f\tdimensiunea maximă a fișierelor scrise de shell și subprocesele sale\n"
"      -i\tnumărul maxim de semnale în așteptare\n"
"      -k\tnumărul maxim de Kcozi alocate pentru acest proces\n"
"      -l\tdimensiunea maximă pe care un proces o poate bloca în memorie\n"
"      -m\tcantitatea maximă de memorie fizică a unui proces\n"
"      -n\tnumărul maxim de descriptori de fișier deschise\n"
"      -p\tdimensiunea memoriei tampon a liniei de conectare\n"
"      -q\tnumărul maxim de octeți din cozile de mesaje POSIX\n"
"      -r\tprioritatea maximă a procesului în timp real\n"
"      -s\tdimensiunea maximă a stivei\n"
"      -t\tcantitatea maximă de timp a CPU-ului în secunde\n"
"      -u\tnumărul maxim de procese ale utilizatorului\n"
"      -v\tdimensiunea memoriei virtuale\n"
"      -x\tnumărul maxim de blocări ale fișierelor\n"
"      -P\tnumărul maxim de pseudoterminale\n"
"      -R\ttimpul maxim pe care îl poate rula un proces în timp real înainte\n"
"        \tde blocare\n"
"      -T\tnumărul maxim de fire(threads)\n"
"    \n"
"    Nu toate opțiunile sunt disponibile pe toate platformele.\n"
"    \n"
"    Dacă se dă LIMITA, aceasta este noua valoare a resursei specificate;\n"
"    valorile speciale de LIMITĂ: „soft”, „hard” și „unlimited” reprezintă\n"
"    limita curentă maleabilă, limita curentă dură și, respectiv, fără limită.\n"
"    Altminteri, este afișată valoarea curentă a resursei specificate. Dacă\n"
"    nu este dată nicio opțiune, atunci se presupune „-f”.\n"
"    \n"
"    Valorile sunt în incremente de 1024 de octeți, cu excepția lui „-t”, care\n"
"    este în secunde, a lui „-p”, care este în incremente de 512 octeți și a lui\n"
"    „-u”, care este un număr nescalat de procese.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este furnizată o opțiune\n"
"    nevalidă sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help umask», din «bash»;
# «bash -c "help umask"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1483
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Afișează sau modifică masca pentru accesarea fișierelor nou create.\n"
"    \n"
"    Stabilește masca de creare a fișierelor de utilizator la MOD.  Dacă MOD\n"
"    este omis, afișează valoarea curentă a măștii.\n"
"    \n"
"    Dacă MOD începe cu o cifră, acesta este interpretat ca un număr octal;\n"
"    altminteri este interpretat ca un șir în format simbolic ca cel acceptat\n"
"    de chmod(1).\n"
"    \n"
"    Opșiuni\n"
"      -p\tdacă MOD este omis, arată ieșirea într-o formă care poate fi\n"
"          \treutilizată ca intrare\n"
"      -S\tafișează MODul în formatul simbolic; altminteri în formatul octal\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care MOD este nevalid sau\n"
"    este dată o opțiune nevalidă."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help wait», din «bash»;
# «bash -c "help wait"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1503
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for each process identified by an ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a job specification, waits for all processes\n"
"    in that job's pipeline.\n"
"    \n"
"    If the -n option is supplied, waits for a single job from the list of IDs,\n"
"    or, if no IDs are supplied, for the next job to complete and returns its\n"
"    exit status.\n"
"    \n"
"    If the -p option is supplied, the process or job identifier of the job\n"
"    for which the exit status is returned is assigned to the variable VAR\n"
"    named by the option argument. The variable will be unset initially, before\n"
"    any assignment. This is useful only when the -n option is supplied.\n"
"    \n"
"    If the -f option is supplied, and job control is enabled, waits for the\n"
"    specified ID to terminate, instead of waiting for it to change status.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last ID; fails if ID is invalid or an invalid\n"
"    option is given, or if -n is supplied and the shell has no unwaited-for\n"
"    children."
msgstr ""
"Așteaptă finalizarea lucrării și returnează starea de ieșire.\n"
"    \n"
"    Așteaptă fiecare proces identificat printr-un ID, care poate fi un ID de\n"
"    proces sau o specificație de lucrare și raportează starea de terminare\n"
"    a acestuia.  Dacă ID-ul nu este dat, așteaptă toate procesele secundare\n"
"    active în prezent și starea de returnare este zero.  Dacă ID-ul este o\n"
"    specificație de lucrare, așteaptă toate procesele din secvența de comenzi\n"
"    respectivă a lucrării.\n"
"    \n"
"    Dacă este furnizată opțiunea „-n”, așteaptă o singură lucrare din lista de\n"
"    ID-uri sau, dacă nu sunt furnizate ID-uri, pentru finalizarea următoarei\n"
"    lucrări și returnează starea de ieșire.\n"
"    \n"
"    Dacă este furnizată opțiunea „-p”, identificatorul de proces sau de lucrare al\n"
"    lucrării pentru care este returnată starea de ieșire este atribuit variabilei\n"
"    VAR numită de argumentul opțiunii.  Variabila va fi anulată inițial, înainte\n"
"    de orice atribuire.  Acest lucru este util numai atunci când este furnizată\n"
"    opțiunea „-n”.\n"
"    \n"
"    Dacă este furnizată opțiunea „-f” și controlul lucrării este activat, \n"
"    așteaptă ca ID-ul specificat să se termine, în loc să aștepte ca acesta să\n"
"    își schimbe starea.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimului ID; eșuează dacă ID-ul este nevalid sau este\n"
"    dată o opțiune nevalidă sau dacă „-n” este furnizată și shell-ul nu are\n"
"    niciun copil pe care să-l aștepte."

#: builtins.c:1534
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for each process specified by a PID and reports its termination status.\n"
"    If PID is not given, waits for all currently active child processes,\n"
"    and the return status is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last PID; fails if PID is invalid or an invalid\n"
"    option is given."
msgstr ""
"Așteaptă finalizarea procesului și returnează starea de ieșire.\n"
"    \n"
"    Așteaptă fiecare proces specificat de un PID și raportează starea de terminare a\n"
"    acestuia.  Dacă nu este dat PID, așteaptă toate procesele copil active în prezent,\n"
"    iar starea returnată este zero.  PID trebuie să fie un ID de proces.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimului PID; eșuează dacă PID este nevalid sau este dată\n"
"    o opțiune nevalidă."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help for», din «bash»;
# «bash -c "help for"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1549
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Execută comenzi pentru fiecare membru dintr-o listă.\n"
"    \n"
"    Bucla „for” execută o secvență de comenzi pentru fiecare membru dintr-o\n"
"    listă de elemente.  Dacă „in CUVINTE ...;” nu este prezent, atunci se\n"
"    presupune „in \"$@\"”.  Pentru fiecare element din CUVINTE, se definește\n"
"    NUME ca acel element, și se execută COMENZILE.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimei comenzi executate."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help 'for (('», din «bash»;
# «bash -c "help 'for (('"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1563
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Buclă aritmetică „for”.\n"
"    \n"
"    Echivalentă cu:\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMENZI\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, și EXP3 sunt expresii aritmetice.  Dacă orice expresie este\n"
"    omisă, se comportă ca și cum aceasta ar avea valoarea 1.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimei comenzi executate."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help select», din «bash»;
# «bash -c "help select"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1581
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Selectează cuvinte dintr-o listă și execută comenzi.\n"
"    \n"
"    CUVINTELE sunt expandate, generând o listă de cuvinte.  Setul\n"
"    de cuvinte expandate este afișat la ieșirea de eroare standard,\n"
"    fiecare precedat de un număr.  Dacă „în CUVINTE” nu este prezent,\n"
"    se presupune „in \"$@\"”.  Se afișează apoi promptul PS3 și se citește\n"
"    o linie de la intrarea standard.  Dacă linia constă din numărul\n"
"    corespunzător unuia dintre cuvintele afișate, atunci se definește NUME\n"
"    ca acest cuvânt.  Dacă linia este goală, CUVINTE și promptul sunt\n"
"    reafișate.  Dacă este citit sfârșitul fișierului(EOF), comanda se\n"
"    finalizează.  Orice altă valoare citită face ca NUME să fie definit ca\n"
"    null.  Linia citită este salvată în variabila „REPLY”.  COMENZILE sunt\n"
"    executate după fiecare selecție până când este executată o comandă\n"
"    de întrerupere(break).\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimei comenzi executate."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help time», din «bash»;
# «bash -c "help time"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1602
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Raportează timpul consumat de execuția secvenței de comenzi.\n"
"    \n"
"    Execută SECVENȚA_DE_COMENZI și imprimă un rezumat al timpului real,\n"
"    al timpului CPU al utilizatorului și al timpului CPU al sistemului\n"
"    petrecut executând SECVENȚA_DE_COMENZI atunci când aceasta termină.\n"
"    \n"
"    Opțiuni:\n"
"      -p\tafișează rezumatul cronometrajului în formatul Posix portabil\n"
"    \n"
"    Valoarea variabilei TIMEFORMAT este utilizată drept format de ieșire.\n"
"    \n"
"    Starea de ieșire:\n"
"    Starea de returnare este starea de returnare a SECVENȚEI_DE_COMENZI."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help case», din «bash»;
# «bash -c "help case"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1619
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Execută comenzi bazate pe potrivirea modelelor.\n"
"    \n"
"    Execută COMENZI selectiv, pe baza potrivirilor dintre CUVÂNT și MODEL.\n"
"    „|” este folosit pentru a separa mai multe modele.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimei comenzi executate."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help if», din «bash»;
# «bash -c "help if"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1631
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Execută comenzi bazate pe condițional.\n"
"    \n"
"    Lista „if COMENZI” este executată.  Dacă starea sa de ieșire este zero,\n"
"    atunci este executată lista „then COMENZI”.  În caz contrar, fiecare listă \n"
"    „elif COMENZI” este executată pe rând, iar dacă starea sa de ieșire este\n"
"    zero, lista corespunzătoare „then COMENZI” este executată și comanda\n"
"    «if» se completează.  În caz contrar, lista „else COMENZI” este executată,\n"
"    dacă este prezentă.  Starea de ieșire a întregii construcții este starea de\n"
"    ieșire a ultimei comenzi executate sau zero dacă nicio condiție nu a fost\n"
"    evaluată ca adevărată.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimei comenzi executate."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help while», din «bash»;
# «bash -c "help while"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1648
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Execută comenzi atâta timp cât un test reușește.\n"
"    \n"
"    Expandează și execută COMENZI-2 atâta timp cât comanda finală din\n"
"    COMENZI are o stare de ieșire zero.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimei comenzi executate."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help until», din «bash»;
# «bash -c "help until"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1660
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS-2 as long as the final command in COMMANDS has\n"
"    an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Execută comenzi atâta timp cât un test nu reușește.\n"
"    \n"
"    Expandează și execută COMENZI-2 atâta timp cât comanda finală din\n"
"    COMENZI are o stare de ieșire diferită de zero.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimei comenzi executate."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help coproc», din «bash»;
# «bash -c "help coproc"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1672
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    The coproc command returns an exit status of 0."
msgstr ""
"Creează un coproces numit NUME.\n"
"    \n"
"    Execută COMANDA în mod asincron, cu ieșirea standard și intrarea standard a\n"
"    comenzii conectate printr-o conductă la descriptorii de fișiere alocați\n"
"    indicilor 0 și 1 ai unei variabile matrice NUME din shell-ul de execuție.\n"
"    NUMELE implicit este „COPROC”.\n"
"    \n"
"    Starea de ieșire:\n"
"    Comanda «coproc» returnează o stare de ieșire de 0."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help function», din «bash»;
# «bash -c "help function"», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1686
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Definește funcția shell.\n"
"    \n"
"    Creează o funcție de shell numită NUME.  Când se invocă ca o comandă simplă,\n"
"    NUME rulează COMENZI în contextul shell-ului apelant.  Când NUME este \n"
"    invocat, argumentele sunt transmise funcției ca $1...$n, iar numele\n"
"    funcției este în $FUNCNAME.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care NUME este protejat la scriere"

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help -m {», din «bash»;
# «bash -c "help -m {», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1700
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Grupează comenzile ca o unitate.\n"
"    \n"
"    Rulează un set de comenzi dintr-un grup. Aceasta este o modalitate\n"
"    de a redirecționa un întreg set de comenzi.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea ultimei comenzi executate."

#: builtins.c:1712
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Reia lucrarea în prim-plan.\n"
"    \n"
"    Echivalent cu argumentul JOB_SPEC al comenzii «fg».  Reia o lucrare\n"
"    oprită sau în fundal.  JOB_SPEC poate specifica fie un nume de lucrare,\n"
"    fie un număr de lucrare.  JOB_SPEC urmat de un „&” plasează lucrarea\n"
"    în fundal, ca și cum specificația lucrării ar fi fost furnizată ca argument\n"
"    pentru «bg».\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează starea lucrării reluate."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help '(('», din «bash»;
# «bash -c "help '(('», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1727
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Evaluează expresia aritmetică.\n"
"    \n"
"    EXPRESIA este evaluată conform regulilor de evaluare aritmetică.\n"
"    Echivalent cu „let \"EXPRESIA\"”.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează 1 dacă EXPRESIA este evaluată la 0; în caz contrar, returnează 0."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help '[['», din «bash»;
# «bash -c "help '[['», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1739
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Execută comanda condițională.\n"
"    \n"
"    Returnează o stare de 0 sau 1, în funcție de evaluarea expresiei condiționale\n"
"    EXPRESIA.  Expresiile sunt compuse din aceleași elemente primare folosite de\n"
"    comanda INTERNĂ «test» și pot fi combinate folosind următorii operatori:\n"
"    \n"
"      ( EXPRESIA )\tReturnează valoarea EXPRESIEI\n"
"      ! EXPRESIA\tAdevărat dacă EXPRESIA este falsă; altfel fals\n"
"      EXPR1 && EXPR2\tAdevărat dacă atât EXPR1 cât și EXPR2 sunt adevărate;\n"
"      \t\t\taltfel fals\n"
"      EXPR1 || EXPR2\tAdevărat dacă fie EXPR1, fie EXPR2 este adevărată;\n"
"      \t\t\taltfel fals\n"
"    \n"
"    Când se utilizează operatorii „==” și „!=”, șirul din dreapta operatorului\n"
"    este utilizat ca model și se realizează potrivirea modelului.\n"
"    Când se utilizează operatorul „=~”, șirul din dreapta operatorului se\n"
"    potrivește ca expresie regulată.\n"
"    \n"
"    Operatorii „&&” și „||” nu evaluează EXPR2 dacă EXPR1 este suficientă pentru\n"
"    a determina valoarea expresiei.\n"
"    \n"
"    Starea de ieșire:\n"
"    0 sau 1, în funcție de valoarea EXPRESIEI."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help variables», din «bash»;
# «bash -c "help variables», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1765
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Numele și utilizarea variabilelor shell comune.\n"
"    \n"
"    BASH_VERSION\n"
"         \tInformații despre versiunea acestui Bash.\n"
"    CDPATH\tO listă de directoare separate prin două puncte\n"
"    \t\tpentru a căuta directoare date ca argumente pentru «cd».\n"
"    GLOBIGNORE\tO listă de modele, separate prin două puncte, care descriu nume\n"
"    \t\tde fișiere care trebuie ignorate de extinderea numelui de cale.\n"
"    HISTFILE\tNumele fișierului în care este stocat istoricul comenzilor.\n"
"    HISTFILESIZE\n"
"         \tNumărul maxim de linii pe care acest fișier le poate conține.\n"
"    HISTSIZE\tNumărul maxim de linii de istoric pe care le poate accesa un\n"
"    \t\tshell care rulează.\n"
"    HOME\tCalea completă către directorul dumneavoastră de conectare.\n"
"    HOSTNAME\tNumele gazdei curente.\n"
"    HOSTTYPE\tTipul de CPU pe care rulează această versiune de Bash.\n"
"    IGNOREEOF\tControlează acțiunea shell-ului la primirea unui caracter „EOF”\n"
"    \t\tca unică intrare.  Dacă este definită, atunci valoarea acesteia\n"
"    \t\teste numărul de caractere „EOF” care pot fi văzute într-un rând\n"
"    \t\tpe o linie goală înainte ca shell-ul să iasă (implicit 10).\n"
"    \t\tCând nu este definită, „EOF” înseamnă sfârșitul intrării.\n"
"    MACHTYPE\tUn șir care descrie sistemul curent pe care rulează Bash.\n"
"    MAILCHECK\tCât de des, în secunde, verifică Bash dacă există e-mailuri noi.\n"
"    MAILPATH\tO listă de nume de fișiere, separate prin două puncte, pe care\n"
"    \t\tBash le verifică pentru e-mailuri noi.\n"
"    OSTYPE\tVersiunea de Unix pe care rulează această versiune de Bash.\n"
"    PATH\tO listă de directoare separate prin două puncte în care se caută,\n"
"    \t\tatunci când se caută comenzi.\n"
"    PROMPT_COMMAND\n"
"         \tO comandă care trebuie executată înainte de afișarea\n"
"    \t\tfiecărui prompt primar.\n"
"    PS1\t\tȘirul de prompt primar.\n"
"    PS2\t\tȘirul de prompt secundar.\n"
"    PWD\t\tCalea completă a directorului curent.\n"
"    SHELLOPTS\tO listă separată de două puncte, de opțiuni de shell activate.\n"
"    TERM\tNumele tipului actual de terminal.\n"
"    TIMEFORMAT\tFormatul de ieșire pentru statisticile de timp afișat de\n"
"    \t\tcuvântul rezervat „time”.\n"
"    auto_resume\tNon-null înseamnă că un cuvânt de comandă care apare singur pe o\n"
"    \t\tlinie este căutat mai întâi în lista de lucrări opriteîn prezent.\n"
"    \t\tDacă se găsește acolo, lucrarea este în prim plan.  O valoare\n"
"    \t\t„exact” înseamnă că cuvântul de comandă trebuie să se potrivească\n"
"    \t\texact cu o comandă din lista de lucrări oprite.  O valoare „sub-\n"
"    \t\tstring” înseamnă că cuvântul de comandă trebuie să se potrivească\n"
"    \t\tcu un subșir al lucrării.  Orice altă valoare înseamnă  că\n"
"    \t\tcomanda trebuie să fie un prefix al unei lucrări oprite.\n"
"    histchars\tCaractere care controlează extinderea istoricului și\n"
"    \t\tînlocuirea rapidă.  Primul caracter este caracterul\n"
"    \t\tde înlocuire a istoricului, de obicei „!”.  Al doilea este\n"
"    \t\tcaracterul „înlocuire rapidă”, de obicei „^”.  Al treilea\n"
"    \t\teste caracterul „comentare istoric”, de obicei „#”.\n"
"    HISTIGNORE\tO listă de modele separate prin două puncte, utilizată pentru a\n"
"    \t\tdecide ce comenzi ar trebui salvate în lista istoricului.\n"

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help pushd», din «bash»;
# «bash -c "help pushd», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1822
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \t\tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the left of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \t\tfrom the right of the list shown by `dirs', starting with\n"
"    \t\tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \t\tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Adaugă directoare la stivă.\n"
"    \n"
"    Adaugă un director în partea de sus a stivei de directoare sau \n"
"    rotește stiva, făcând din partea de sus a stivei directorul de lucru\n"
"    curent.  Fără argumente, interschimbă primele două directoare.\n"
"    \n"
"    Opțiuni:\n"
"      -n\tSuprimă schimbarea normală a directorului atunci când se adaugă\n"
"    \t\tdirectoare la stivă, astfel încât numai stiva este manipulată.\n"
"    \n"
"    Argumente:\n"
"      +N\tRotește stiva astfel încât al N-lea director (numărând \n"
"    \t\tdin stânga listei afișate de «dirs», începând cu zero) să fie\n"
"    \t\tîn partea de sus.\n"
"    \n"
"      -N\tRotește stiva astfel încât al N-lea director (numărând \n"
"    \t\tdin dreapta listei afișate de «dirs», începând cu zero) să fie\n"
"    \t\tîn partea de sus.\n"
"    \n"
"      dir\tAdaugă DIR la stiva de directoare din partea de sus, făcându-l\n"
"    \t\tnoul director de lucru curent.\n"
"    \n"
"    Comanda internă «dirs» afișează stiva de directoare.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este furnizat un argument\n"
"    nevalid sau dacă schimbarea directorului eșuează."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help popd», din «bash»;
# «bash -c "help popd», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1856
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \t\tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \t\tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \t\tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Elimină directoare din stivă.\n"
"    \n"
"    Elimină intrările din stiva de directoare. Fără argumente, elimină\n"
"    directorul de sus din stivă, și trece la noul director de sus.\n"
"    \n"
"    Opțiuni:\n"
"      -n\tSuprimă schimbarea normală a directorului atunci când se elimină\n"
"    \t\tdirectoare la stivă, astfel încât numai stiva este manipulată.\n"
"    \n"
"    Argumente:\n"
"      +N\tElimină intrarea a N-a numărând din stânga listei afișate\n"
"    \t\tde «dirs», începând cu zero.  De exemplu: «popd +0»\n"
"    \t\telimină primul director, «popd +1» al doilea.\n"
"    \n"
"      -N\tElimină intrarea a N-a numărând din dreapta listei afișate\n"
"    \t\tde «dirs», începând cu zero.  De exemplu: «popd -0»\n"
"    \t\telimină ultimul director, «popd -1» penultimul.\n"
"    \n"
"    Comanda internă «dirs» afișează stiva de directoare.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este furnizat un argument\n"
"    nevalid sau dacă schimbarea directorului eșuează."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help dirs», din «bash»;
# «bash -c "help dirs», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1886
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \t\tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \t\twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list\n"
"    \t\tshown by dirs when invoked without options, starting with\n"
"    \t\tzero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Afișează stiva de directoare.\n"
"    \n"
"    Afișează lista directoarelor memorate în prezent.  Directoarele\n"
"    sunt adăugate la această listă cu comanda «pushd» și eliminate\n"
"    cu comanda «popd».\n"
"    \n"
"    Opțiuni:\n"
"      -c\tcurăță stiva de directoare ștergând toate elementele\n"
"      -l\tnu afișează versiuni de directoare cu prefix „~” în raport \n"
"    \t\tcu directorul dumneavoastră «acasă»\n"
"      -p\tafișează stiva de directoare cu o intrare pe linie\n"
"      -v\tafișează stiva de directoare cu o intrare pe linie, prefixată\n"
"    \t\tcu poziția sa în stivă\n"
"    \n"
"    Argumente:\n"
"      +N\tAfișează a N-a intrare numărând din stânga listei afișate\n"
"    \t\tde «dirs» atunci când este invocată fără opțiuni, începând\n"
"    \t\tcu zero.\n"
"    \n"
"      -N\tAfișează a N-a intrare numărând din dreapta listei afișate\n"
"    \t\tde «dirs» atunci când este invocată fără opțiuni, începând\n"
"    \t\tcu zero.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este furnizată o opțiune\n"
"    nevalidă sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help shopt», din «bash»;
# «bash -c "help shopt», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1917
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list each supplied OPTNAME, or all shell options if no\n"
"    OPTNAMEs are given, with an indication of whether or not each is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Activează sau dezactivează opțiunile de shell.\n"
"    \n"
"    Schimbă configurarea fiecărei opțiuni de shell NUME_OPȚIUNE.  Fără\n"
"    niciun argument de opțiune, listează fiecare NUME_OPȚIUNE furnizat, \n"
"    sau toate opțiunile de shell dacă nu sunt date NUME_OPȚIUNE, cu o\n"
"    indicație dacă fiecare este sau nu definită.\n"
"    \n"
"    Opțiuni:\n"
"      -o\trestricționează NUME_OPȚIUNE la cele definite pentru a fi\n"
"           \tutilizate cu «set -o»\n"
"      -p\tafișează fiecare opțiune de shell cu o indicație a stării acesteia\n"
"      -q\tsuprimă ieșirea\n"
"      -s\tactivează (definește) fiecare NUME_OPȚIUNE\n"
"      -u\tdezactivează (șterge) fiecare NUME_OPȚIUNE\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes dacă NUME_OPȚIUNE este activată; eșuează dacă\n"
"    este dată o opțiune nevalidă sau NUME_OPȚIUNE este dezactivată."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help printf», din «bash»;
# «bash -c "help printf», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1938
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output; character escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf(1),\n"
"    printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"      %Q\tlike %q, but apply any precision to the unquoted argument before\n"
"    \t\tquoting\n"
"      %(fmt)T\toutput the date-time string resulting from using FMT as a format\n"
"    \t        string for strftime(3)\n"
"    \n"
"    The format is re-used as necessary to consume all of the arguments.  If\n"
"    there are fewer arguments than the format requires,  extra format\n"
"    specifications behave as if a zero value or null string, as appropriate,\n"
"    had been supplied.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or assignment\n"
"    error occurs."
msgstr ""
"Formatează și imprimă ARGUMENTELE sub controlul FORMATului.\n"
"    \n"
"    Opțiuni:\n"
"      -v var\tasignează ieșirea variabilei shell VAR, în loc să o\n"
"    \t\tafișeze la ieșirea standard\n"
"    \n"
"    FORMAT este un șir de caractere care conține trei tipuri de obiecte: \n"
"    caractere simple, care sunt pur și simplu copiate la ieșirea standard; \n"
"    secvențe de eludare de caractere, care sunt convertite și copiate la \n"
"    ieșirea standard; și specificații de format, fiecare dintre acestea \n"
"    determinând imprimarea următorului argument succesiv.\n"
"    \n"
"    În plus față de specificațiile de format standard descrise în printf(1),\n"
"    «printf» interpretează:\n"
"    \n"
"      %b\texpandează secvențele de eludare de bară inversată,\n"
"          \tîn argumentul corespunzător\n"
"      %q\tcitează argumentul într-un mod care poate fi reutilizat\n"
"          \tca intrare shell\n"
"      %Q\tprecum %q, dar aplică orice precizie argumentului necitat\n"
"    \t\tînainte de al cita\n"
"      %(fmt)T\tafișează șirul dată-oră rezultat din utilizarea FMT,\n"
"          \tca șir de format pentru strftime(3)\n"
"    \n"
"    Formatul este reutilizat după cum este necesar pentru a consuma toate\n"
"    argumentele. Dacă există mai puține argumente decât necesită formatul,\n"
"    specificațiile de format suplimentare se comportă ca și cum ar fi fost\n"
"    furnizată o valoare zero sau un șir nul, după caz.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau apare o eroare de scriere sau de atribuire."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help complete», din «bash»;
# «bash -c "help complete», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:1974
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no options\n"
"    are supplied, existing completion specifications are printed in a way that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \t\tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \t\twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \t\tcompletion attempted on a blank line\n"
"      -I\tapply the completions and actions to the initial (usually the\n"
"    \t\tcommand) word\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above. If multiple options are supplied,\n"
"    the -D option takes precedence over -E, and both take precedence over -I.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Specifică modul în care argumentele vor fi completate de Readline.\n"
"    \n"
"    Pentru fiecare NUME, specifică cum vor fi completate argumentele. Dacă\n"
"    nu sunt furnizate opțiuni, specificațiile de completare existente sunt\n"
"    imprimate într-un mod care să permită reutilizarea lor ca intrare\n"
"    \n"
"    Opțiuni:\n"
"      -p\tafișează specificațiile de completare existente într-un format\n"
"    \t\treutilizabil\n"
"      -r\telimină o specificație de completare pentru fiecare NUME sau,\n"
"    \t\tdacă nu sunt furnizate NUME, toate specificațiile de completare\n"
"      -D\taplicați completările și acțiunile ca implicite pentru comenzi\n"
"    \t\tfără nicio completare specifică definită\n"
"      -E\taplică completările și acțiunile pentru comenzile „goale” --\n"
"    \t\tcând se încearcă completarea într-o linie goală\n"
"      -I\taplică completările și acțiunile la cuvântul inițial (de obicei\n"
"    \t\tcomanda).\n"
"    \n"
"    Când se încearcă completarea, acțiunile sunt aplicate în ordinea în care\n"
"    opțiunile cu litere mari sunt listate mai sus.  Dacă sunt furnizate mai multe\n"
"    opțiuni, opțiunea „-D” are prioritate față de „-E” și ambele au prioritate\n"
"    față de opțiunea „-I”.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este furnizată o opțiune\n"
"    nevalidă sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help compgen», din «bash»;
# «bash -c "help compgen», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:2004
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Afișează posibilele completări în funcție de opțiuni.\n"
"    \n"
"    Aceasta este destinată să fie utilizată dintr-o funcție shell care generează\n"
"    posibile completări.  Dacă este furnizat argumentul opțional CUVÂNT, se\n"
"    generează potriviri cu CUVÂNT.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este furnizată o opțiune\n"
"    nevalidă sau apare o eroare."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help compopt», din «bash»;
# «bash -c "help compopt», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:2019
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are supplied,\n"
"    the completion currently being executed.  If no OPTIONs are given, print\n"
"    the completion options for each NAME or the current completion specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \t-I\t\tChange options for completion on the initial word\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Modifică sau afișează opțiunile de completare.\n"
"    \n"
"    Modifică opțiunile de completare pentru fiecare NUME sau, dacă nu sunt \n"
"    furnizate NUME, completarea aflată în curs de executare.  Dacă nu sunt \n"
"    date OPȚIUNI, afișează opțiunile de completare pentru fiecare NUME sau \n"
"    specificația de completare curentă.\n"
"    \n"
"    Opțiuni:\n"
"    \t-o opțiune\n"
"      \t\tStabilește opțiunea de completare OPȚIUNE pentru fiecare NUME\n"
"    \t-D\tSchimbă opțiunile pentru completarea comenzii „implicite”.\n"
"    \t-E\tSchimbă opțiunile pentru completarea comenzii „goale”.\n"
"    \t-I\tSchimbă opțiunile de completare a cuvântului inițial\n"
"    \n"
"    Utilizarea lui „+o” în loc de „-o” dezactivează opțiunea specificată.\n"
"    \n"
"    Argumente:\n"
"    \n"
"    Fiecare NUME se referă la o comandă pentru care o specificație de completare\n"
"    trebuie să fi fost definită anterior folosind comanda internă «complete».  \n"
"    Dacă nu sunt furnizate NUME, «compopt» trebuie să fie apelată de o funcție \n"
"    care generează completări în acest moment și opțiunile pentru acest \n"
"   generator de completare care se execută acum, sunt modificate.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este furnizată o opțiune \n"
"    nevalidă sau NUME nu are o specificație de completare definită."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help mapfile», din «bash»;
# «bash -c "help mapfile», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:2050
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -d delim\tUse DELIM to terminate lines, instead of newline\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n"
"      -s count\tDiscard the first COUNT lines read\n"
"      -t\tRemove a trailing DELIM from each line read (default newline)\n"
"      -u fd\tRead lines from file descriptor FD instead of the standard input\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n"
"      -c quantum\tSpecify the number of lines read between each call to\n"
"    \t\t\tCALLBACK\n"
"    \n"
"    Arguments:\n"
"      ARRAY\tArray variable name to use for file data\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned and the line to be assigned to that element\n"
"    as additional arguments.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly or\n"
"    not an indexed array."
msgstr ""
"Citește linii de la intrarea standard într-o variabilă matrice indexată.\n"
"    \n"
"    Citește linii de la intrarea standard în variabila matrice indexată MATRICE,\n"
"    sau din descriptorul de fișier „FD” dacă este furnizată opțiunea „-u”.\n"
"    Variabila MAPFILE este MATRICEA implicită.\n"
"    \n"
"    Opțiuni:\n"
"      -d delim  Utilizează DELIM pentru a termina liniile, în loc de linie nouă\n"
"      -n număr  Copiază cel mult NUMĂRul de rânduri. Dacă NUMĂR este 0,\n"
"                toate liniile sunt copiate\n"
"      -O origin Începe alocarea către MATRICE la indexul ORIGIN.  Indicele\n"
"                implicit este 0\n"
"      -s count  Renunță la primele COUNT rânduri citite\n"
"      -t        Elimină un DELIM final din fiecare linie citită (implicit,\n"
"                linie nouă)\n"
"      -u fd     Citește linii din descriptorul de fișier „FD” în loc de la\n"
"                intrarea standard\n"
"      -C apelare\n"
"                Evaluează APELARE de fiecare dată când sunt citite linii CANTITATE\n"
"      -c cantitate\n"
"                Specifică numărul de linii citite între fiecare apel către APELARE\n"
"    \n"
"    Argumente:\n"
"      MATRICE\tNume variabilă matrice de utilizat pentru datele fișierului\n"
"    \n"
"    Dacă „-C” este furnizată fără „-c”, cantitatea implicită este 5000.  Când se\n"
"    evaluează APELARE, i se furnizează indexul următorului element din matrice\n"
"    care urmează să fie atribuit și linia care urmează să fie atribuită\n"
"    acelui element ca argumente suplimentare.\n"
"    \n"
"    Dacă nu este furnizat cu o origine explicită, «mapfile» va șterge MATRICE\n"
"    înainte de a-o utiliza pentru asignare.\n"
"    \n"
"    Starea de ieșire:\n"
"    Returnează succes, cu excepția cazului în care este dată o opțiune nevalidă\n"
"    sau MATRICE este protejată la scriere sau nu este o matrice indexată."

# R-GC, scrie:
# acest mesaj, poate să fie vizualizat, rulînd
# comanda:
# «help readarray», din «bash»;
# «bash -c "help array», din «bash», sau
# dintr-un shell, diferit de «bash».
#: builtins.c:2086
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Citește linii dintr-un fișier într-o variabilă de tip matrice.\n"
"    \n"
"    Un sinonim pentru «mapfile»."

#~ msgid "%s: invalid associative array key"
#~ msgstr "%s: cheie de matrice asociativă nevalidă"
